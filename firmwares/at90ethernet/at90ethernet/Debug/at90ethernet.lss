
at90ethernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000007e  00800100  00002f72  00003006  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002f72  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012e5  0080017e  0080017e  00003084  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003084  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000030b4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004d8  00000000  00000000  000030f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009641  00000000  00000000  000035cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002dc4  00000000  00000000  0000cc0d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00011832  00000000  00000000  0000f9d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000da0  00000000  00000000  00021204  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000196d4  00000000  00000000  00021fa4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000057ed  00000000  00000000  0003b678  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006b0  00000000  00000000  00040e65  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000a7cb  00000000  00000000  00041515  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
       2:	00 00       	nop
       4:	2d c2       	rjmp	.+1114   	; 0x460 <__bad_interrupt>
       6:	00 00       	nop
       8:	2b c2       	rjmp	.+1110   	; 0x460 <__bad_interrupt>
       a:	00 00       	nop
       c:	29 c2       	rjmp	.+1106   	; 0x460 <__bad_interrupt>
       e:	00 00       	nop
      10:	27 c2       	rjmp	.+1102   	; 0x460 <__bad_interrupt>
      12:	00 00       	nop
      14:	25 c2       	rjmp	.+1098   	; 0x460 <__bad_interrupt>
      16:	00 00       	nop
      18:	23 c2       	rjmp	.+1094   	; 0x460 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	21 c2       	rjmp	.+1090   	; 0x460 <__bad_interrupt>
      1e:	00 00       	nop
      20:	1f c2       	rjmp	.+1086   	; 0x460 <__bad_interrupt>
      22:	00 00       	nop
      24:	1d c2       	rjmp	.+1082   	; 0x460 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 d3 14 	jmp	0x29a6	; 0x29a6 <__vector_10>
      2c:	19 c2       	rjmp	.+1074   	; 0x460 <__bad_interrupt>
      2e:	00 00       	nop
      30:	17 c2       	rjmp	.+1070   	; 0x460 <__bad_interrupt>
      32:	00 00       	nop
      34:	15 c2       	rjmp	.+1066   	; 0x460 <__bad_interrupt>
      36:	00 00       	nop
      38:	13 c2       	rjmp	.+1062   	; 0x460 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	11 c2       	rjmp	.+1058   	; 0x460 <__bad_interrupt>
      3e:	00 00       	nop
      40:	0f c2       	rjmp	.+1054   	; 0x460 <__bad_interrupt>
      42:	00 00       	nop
      44:	0d c2       	rjmp	.+1050   	; 0x460 <__bad_interrupt>
      46:	00 00       	nop
      48:	0b c2       	rjmp	.+1046   	; 0x460 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	09 c2       	rjmp	.+1042   	; 0x460 <__bad_interrupt>
      4e:	00 00       	nop
      50:	07 c2       	rjmp	.+1038   	; 0x460 <__bad_interrupt>
      52:	00 00       	nop
      54:	05 c2       	rjmp	.+1034   	; 0x460 <__bad_interrupt>
      56:	00 00       	nop
      58:	03 c2       	rjmp	.+1030   	; 0x460 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	01 c2       	rjmp	.+1026   	; 0x460 <__bad_interrupt>
      5e:	00 00       	nop
      60:	ff c1       	rjmp	.+1022   	; 0x460 <__bad_interrupt>
      62:	00 00       	nop
      64:	fd c1       	rjmp	.+1018   	; 0x460 <__bad_interrupt>
      66:	00 00       	nop
      68:	fb c1       	rjmp	.+1014   	; 0x460 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f9 c1       	rjmp	.+1010   	; 0x460 <__bad_interrupt>
      6e:	00 00       	nop
      70:	f7 c1       	rjmp	.+1006   	; 0x460 <__bad_interrupt>
      72:	00 00       	nop
      74:	f5 c1       	rjmp	.+1002   	; 0x460 <__bad_interrupt>
      76:	00 00       	nop
      78:	f3 c1       	rjmp	.+998    	; 0x460 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f1 c1       	rjmp	.+994    	; 0x460 <__bad_interrupt>
      7e:	00 00       	nop
      80:	ef c1       	rjmp	.+990    	; 0x460 <__bad_interrupt>
      82:	00 00       	nop
      84:	ed c1       	rjmp	.+986    	; 0x460 <__bad_interrupt>
      86:	00 00       	nop
      88:	eb c1       	rjmp	.+982    	; 0x460 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e9 c1       	rjmp	.+978    	; 0x460 <__bad_interrupt>
      8e:	00 00       	nop
      90:	e7 c1       	rjmp	.+974    	; 0x460 <__bad_interrupt>
      92:	00 00       	nop
      94:	e5 c1       	rjmp	.+970    	; 0x460 <__bad_interrupt>
	...

00000098 <ProductString>:
      98:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
      a8:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
      b8:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

000000c2 <ManufacturerString>:
      c2:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      d2:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000dc <LanguageString>:
      dc:	04 03 09 04                                         ....

000000e0 <ConfigurationDescriptor>:
      e0:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      f0:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
     100:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
     110:	07 05 02 02 40 00 05 07 05 81 02 40 00 05           ....@......@..

0000011e <DeviceDescriptor>:
     11e:	12 01 10 01 02 00 00 08 69 69 50 55 01 00 01 02     ........iiPU....
     12e:	00 01                                               ..

00000130 <HTTPPage>:
     130:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     140:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     150:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     160:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     170:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     180:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     190:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     1a0:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     1b0:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     1c0:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     1d0:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     1e0:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     1f0:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     200:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     210:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     220:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     230:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     240:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     250:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     260:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     270:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     280:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     290:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     2a0:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     2b0:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     2c0:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     2d0:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     2e0:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     2f0:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     300:	3c 2f 69 3e 31 37 30 34 31 38 09 09 3c 2f 70 3e     </i>170418..</p>
     310:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

00000320 <HTTP404Header>:
     320:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     330:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     340:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     350:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     360:	0a 00                                               ..

00000362 <HTTP200Header>:
     362:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     372:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     382:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     392:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     3a2:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     3b2:	0a 0d 0a 00                                         ....

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	11 e0       	ldi	r17, 0x01	; 1
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	e2 e7       	ldi	r30, 0x72	; 114
     436:	ff e2       	ldi	r31, 0x2F	; 47
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+
     440:	0d 92       	st	X+, r0
     442:	ae 37       	cpi	r26, 0x7E	; 126
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>

00000448 <__do_clear_bss>:
     448:	24 e1       	ldi	r18, 0x14	; 20
     44a:	ae e7       	ldi	r26, 0x7E	; 126
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	01 c0       	rjmp	.+2      	; 0x452 <.do_clear_bss_start>

00000450 <.do_clear_bss_loop>:
     450:	1d 92       	st	X+, r1

00000452 <.do_clear_bss_start>:
     452:	a3 36       	cpi	r26, 0x63	; 99
     454:	b2 07       	cpc	r27, r18
     456:	e1 f7       	brne	.-8      	; 0x450 <.do_clear_bss_loop>
     458:	0e 94 bd 0c 	call	0x197a	; 0x197a <main>
     45c:	0c 94 b7 17 	jmp	0x2f6e	; 0x2f6e <_exit>

00000460 <__bad_interrupt>:
     460:	cf cd       	rjmp	.-1122   	; 0x0 <__vectors>

00000462 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint16_t wIndex,
                                    const void** const DescriptorAddress)
{
    const uint8_t  DescriptorType   = (wValue >> 8);
     462:	29 2f       	mov	r18, r25
     464:	33 27       	eor	r19, r19
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;

    switch (DescriptorType)
     466:	22 30       	cpi	r18, 0x02	; 2
     468:	31 05       	cpc	r19, r1
     46a:	59 f0       	breq	.+22     	; 0x482 <CALLBACK_USB_GetDescriptor+0x20>
     46c:	23 30       	cpi	r18, 0x03	; 3
     46e:	31 05       	cpc	r19, r1
     470:	69 f0       	breq	.+26     	; 0x48c <CALLBACK_USB_GetDescriptor+0x2a>
     472:	21 30       	cpi	r18, 0x01	; 1
     474:	31 05       	cpc	r19, r1
     476:	21 f1       	breq	.+72     	; 0x4c0 <CALLBACK_USB_GetDescriptor+0x5e>
{
    const uint8_t  DescriptorType   = (wValue >> 8);
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;
     478:	80 e0       	ldi	r24, 0x00	; 0
     47a:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
    const uint8_t  DescriptorType   = (wValue >> 8);
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
     47c:	20 e0       	ldi	r18, 0x00	; 0
     47e:	30 e0       	ldi	r19, 0x00	; 0
     480:	28 c0       	rjmp	.+80     	; 0x4d2 <CALLBACK_USB_GetDescriptor+0x70>
            Address = &DeviceDescriptor;
            Size    = sizeof(USB_Descriptor_Device_t);
            break;
        case DTYPE_Configuration:
            Address = &ConfigurationDescriptor;
            Size    = sizeof(USB_Descriptor_Configuration_t);
     482:	8e e3       	ldi	r24, 0x3E	; 62
     484:	90 e0       	ldi	r25, 0x00	; 0
        case DTYPE_Device:
            Address = &DeviceDescriptor;
            Size    = sizeof(USB_Descriptor_Device_t);
            break;
        case DTYPE_Configuration:
            Address = &ConfigurationDescriptor;
     486:	20 ee       	ldi	r18, 0xE0	; 224
     488:	30 e0       	ldi	r19, 0x00	; 0
            Size    = sizeof(USB_Descriptor_Configuration_t);
            break;
     48a:	23 c0       	rjmp	.+70     	; 0x4d2 <CALLBACK_USB_GetDescriptor+0x70>
        case DTYPE_String:
            switch (DescriptorNumber)
     48c:	99 27       	eor	r25, r25
     48e:	81 30       	cpi	r24, 0x01	; 1
     490:	91 05       	cpc	r25, r1
     492:	51 f0       	breq	.+20     	; 0x4a8 <CALLBACK_USB_GetDescriptor+0x46>
     494:	18 f0       	brcs	.+6      	; 0x49c <CALLBACK_USB_GetDescriptor+0x3a>
     496:	02 97       	sbiw	r24, 0x02	; 2
     498:	69 f0       	breq	.+26     	; 0x4b4 <CALLBACK_USB_GetDescriptor+0x52>
     49a:	17 c0       	rjmp	.+46     	; 0x4ca <CALLBACK_USB_GetDescriptor+0x68>
            {
                case STRING_ID_Language:
                    Address = &LanguageString;
                    Size    = pgm_read_byte(&LanguageString.Header.Size);
     49c:	ec ed       	ldi	r30, 0xDC	; 220
     49e:	f0 e0       	ldi	r31, 0x00	; 0
     4a0:	84 91       	lpm	r24, Z
     4a2:	90 e0       	ldi	r25, 0x00	; 0
            break;
        case DTYPE_String:
            switch (DescriptorNumber)
            {
                case STRING_ID_Language:
                    Address = &LanguageString;
     4a4:	9f 01       	movw	r18, r30
                    Size    = pgm_read_byte(&LanguageString.Header.Size);
                    break;
     4a6:	15 c0       	rjmp	.+42     	; 0x4d2 <CALLBACK_USB_GetDescriptor+0x70>
                case STRING_ID_Manufacturer:
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     4a8:	e2 ec       	ldi	r30, 0xC2	; 194
     4aa:	f0 e0       	ldi	r31, 0x00	; 0
     4ac:	84 91       	lpm	r24, Z
     4ae:	90 e0       	ldi	r25, 0x00	; 0
                case STRING_ID_Language:
                    Address = &LanguageString;
                    Size    = pgm_read_byte(&LanguageString.Header.Size);
                    break;
                case STRING_ID_Manufacturer:
                    Address = &ManufacturerString;
     4b0:	9f 01       	movw	r18, r30
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
                    break;
     4b2:	0f c0       	rjmp	.+30     	; 0x4d2 <CALLBACK_USB_GetDescriptor+0x70>
                case STRING_ID_Product:
                    Address = &ProductString;
                    Size    = pgm_read_byte(&ProductString.Header.Size);
     4b4:	e8 e9       	ldi	r30, 0x98	; 152
     4b6:	f0 e0       	ldi	r31, 0x00	; 0
     4b8:	84 91       	lpm	r24, Z
     4ba:	90 e0       	ldi	r25, 0x00	; 0
                case STRING_ID_Manufacturer:
                    Address = &ManufacturerString;
                    Size    = pgm_read_byte(&ManufacturerString.Header.Size);
                    break;
                case STRING_ID_Product:
                    Address = &ProductString;
     4bc:	9f 01       	movw	r18, r30
                    Size    = pgm_read_byte(&ProductString.Header.Size);
                    break;
     4be:	09 c0       	rjmp	.+18     	; 0x4d2 <CALLBACK_USB_GetDescriptor+0x70>

    switch (DescriptorType)
    {
        case DTYPE_Device:
            Address = &DeviceDescriptor;
            Size    = sizeof(USB_Descriptor_Device_t);
     4c0:	82 e1       	ldi	r24, 0x12	; 18
     4c2:	90 e0       	ldi	r25, 0x00	; 0
    uint16_t    Size    = NO_DESCRIPTOR;

    switch (DescriptorType)
    {
        case DTYPE_Device:
            Address = &DeviceDescriptor;
     4c4:	2e e1       	ldi	r18, 0x1E	; 30
     4c6:	31 e0       	ldi	r19, 0x01	; 1
     4c8:	04 c0       	rjmp	.+8      	; 0x4d2 <CALLBACK_USB_GetDescriptor+0x70>
{
    const uint8_t  DescriptorType   = (wValue >> 8);
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
    uint16_t    Size    = NO_DESCRIPTOR;
     4ca:	80 e0       	ldi	r24, 0x00	; 0
     4cc:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
    const uint8_t  DescriptorType   = (wValue >> 8);
    const uint8_t  DescriptorNumber = (wValue & 0xFF);

    const void* Address = NULL;
     4ce:	20 e0       	ldi	r18, 0x00	; 0
     4d0:	30 e0       	ldi	r19, 0x00	; 0
            }

            break;
    }

    *DescriptorAddress = Address;
     4d2:	fa 01       	movw	r30, r20
     4d4:	31 83       	std	Z+1, r19	; 0x01
     4d6:	20 83       	st	Z, r18
    return Size;
}
     4d8:	08 95       	ret

000004da <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
     4da:	0f 93       	push	r16
     4dc:	1f 93       	push	r17
     4de:	cf 93       	push	r28
     4e0:	df 93       	push	r29
     4e2:	ec 01       	movw	r28, r24
     4e4:	8b 01       	movw	r16, r22
	DecodeARPHeader(InDataStart);
     4e6:	c0 d2       	rcall	.+1408   	; 0xa68 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
     4e8:	2a 81       	ldd	r18, Y+2	; 0x02
     4ea:	3b 81       	ldd	r19, Y+3	; 0x03

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
     4ec:	83 2f       	mov	r24, r19
     4ee:	92 2f       	mov	r25, r18
     4f0:	81 15       	cp	r24, r1
     4f2:	98 40       	sbci	r25, 0x08	; 8
     4f4:	09 f0       	breq	.+2      	; 0x4f8 <ARP_ProcessARPPacket+0x1e>
     4f6:	58 c0       	rjmp	.+176    	; 0x5a8 <ARP_ProcessARPPacket+0xce>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
     4f8:	2e 81       	ldd	r18, Y+6	; 0x06
     4fa:	3f 81       	ldd	r19, Y+7	; 0x07
     4fc:	83 2f       	mov	r24, r19
     4fe:	92 2f       	mov	r25, r18

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
     500:	01 97       	sbiw	r24, 0x01	; 1
     502:	09 f0       	breq	.+2      	; 0x506 <ARP_ProcessARPPacket+0x2c>
     504:	54 c0       	rjmp	.+168    	; 0x5ae <ARP_ProcessARPPacket+0xd4>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
     506:	44 e0       	ldi	r20, 0x04	; 4
     508:	50 e0       	ldi	r21, 0x00	; 0
     50a:	6e e3       	ldi	r22, 0x3E	; 62
     50c:	71 e0       	ldi	r23, 0x01	; 1
     50e:	ce 01       	movw	r24, r28
     510:	48 96       	adiw	r24, 0x18	; 24
     512:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
     516:	89 2b       	or	r24, r25
     518:	59 f0       	breq	.+22     	; 0x530 <ARP_ProcessARPPacket+0x56>
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
     51a:	46 e0       	ldi	r20, 0x06	; 6
     51c:	50 e0       	ldi	r21, 0x00	; 0
     51e:	62 e4       	ldi	r22, 0x42	; 66
     520:	71 e0       	ldi	r23, 0x01	; 1
     522:	ce 01       	movw	r24, r28
     524:	42 96       	adiw	r24, 0x12	; 18
     526:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
     52a:	89 2b       	or	r24, r25
     52c:	09 f0       	breq	.+2      	; 0x530 <ARP_ProcessARPPacket+0x56>
     52e:	42 c0       	rjmp	.+132    	; 0x5b4 <ARP_ProcessARPPacket+0xda>
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
     530:	88 81       	ld	r24, Y
     532:	99 81       	ldd	r25, Y+1	; 0x01
     534:	f8 01       	movw	r30, r16
     536:	91 83       	std	Z+1, r25	; 0x01
     538:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
     53a:	8a 81       	ldd	r24, Y+2	; 0x02
     53c:	9b 81       	ldd	r25, Y+3	; 0x03
     53e:	93 83       	std	Z+3, r25	; 0x03
     540:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
     542:	8c 81       	ldd	r24, Y+4	; 0x04
     544:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
     546:	8d 81       	ldd	r24, Y+5	; 0x05
     548:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
     54a:	80 e0       	ldi	r24, 0x00	; 0
     54c:	92 e0       	ldi	r25, 0x02	; 2
     54e:	97 83       	std	Z+7, r25	; 0x07
     550:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
     552:	86 e0       	ldi	r24, 0x06	; 6
     554:	fe 01       	movw	r30, r28
     556:	38 96       	adiw	r30, 0x08	; 8
     558:	d8 01       	movw	r26, r16
     55a:	52 96       	adiw	r26, 0x12	; 18
     55c:	01 90       	ld	r0, Z+
     55e:	0d 92       	st	X+, r0
     560:	8a 95       	dec	r24
     562:	e1 f7       	brne	.-8      	; 0x55c <ARP_ProcessARPPacket+0x82>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
     564:	8e 85       	ldd	r24, Y+14	; 0x0e
     566:	9f 85       	ldd	r25, Y+15	; 0x0f
     568:	a8 89       	ldd	r26, Y+16	; 0x10
     56a:	b9 89       	ldd	r27, Y+17	; 0x11
     56c:	f8 01       	movw	r30, r16
     56e:	80 8f       	std	Z+24, r24	; 0x18
     570:	91 8f       	std	Z+25, r25	; 0x19
     572:	a2 8f       	std	Z+26, r26	; 0x1a
     574:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
     576:	86 e0       	ldi	r24, 0x06	; 6
     578:	e2 e4       	ldi	r30, 0x42	; 66
     57a:	f1 e0       	ldi	r31, 0x01	; 1
     57c:	d8 01       	movw	r26, r16
     57e:	18 96       	adiw	r26, 0x08	; 8
     580:	01 90       	ld	r0, Z+
     582:	0d 92       	st	X+, r0
     584:	8a 95       	dec	r24
     586:	e1 f7       	brne	.-8      	; 0x580 <ARP_ProcessARPPacket+0xa6>
			ARPHeaderOUT->SPA = ServerIPAddress;
     588:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <ServerIPAddress>
     58c:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <ServerIPAddress+0x1>
     590:	a0 91 40 01 	lds	r26, 0x0140	; 0x800140 <ServerIPAddress+0x2>
     594:	b0 91 41 01 	lds	r27, 0x0141	; 0x800141 <ServerIPAddress+0x3>
     598:	f8 01       	movw	r30, r16
     59a:	86 87       	std	Z+14, r24	; 0x0e
     59c:	97 87       	std	Z+15, r25	; 0x0f
     59e:	a0 8b       	std	Z+16, r26	; 0x10
     5a0:	b1 8b       	std	Z+17, r27	; 0x11

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
     5a2:	8c e1       	ldi	r24, 0x1C	; 28
     5a4:	90 e0       	ldi	r25, 0x00	; 0
     5a6:	08 c0       	rjmp	.+16     	; 0x5b8 <ARP_ProcessARPPacket+0xde>
		}
	}

	return NO_RESPONSE;
     5a8:	80 e0       	ldi	r24, 0x00	; 0
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	05 c0       	rjmp	.+10     	; 0x5b8 <ARP_ProcessARPPacket+0xde>
     5ae:	80 e0       	ldi	r24, 0x00	; 0
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	02 c0       	rjmp	.+4      	; 0x5b8 <ARP_ProcessARPPacket+0xde>
     5b4:	80 e0       	ldi	r24, 0x00	; 0
     5b6:	90 e0       	ldi	r25, 0x00	; 0
}
     5b8:	df 91       	pop	r29
     5ba:	cf 91       	pop	r28
     5bc:	1f 91       	pop	r17
     5be:	0f 91       	pop	r16
     5c0:	08 95       	ret

000005c2 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
     5c2:	8f 92       	push	r8
     5c4:	9f 92       	push	r9
     5c6:	af 92       	push	r10
     5c8:	bf 92       	push	r11
     5ca:	cf 92       	push	r12
     5cc:	df 92       	push	r13
     5ce:	ef 92       	push	r14
     5d0:	ff 92       	push	r15
     5d2:	0f 93       	push	r16
     5d4:	1f 93       	push	r17
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     5da:	6c 01       	movw	r12, r24
     5dc:	7b 01       	movw	r14, r22
     5de:	8a 01       	movw	r16, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = ((uint8_t*)DHCPHeaderInStart  + sizeof(DHCP_Header_t));
     5e0:	eb 01       	movw	r28, r22
     5e2:	c0 51       	subi	r28, 0x10	; 16
     5e4:	df 4f       	sbci	r29, 0xFF	; 255
	uint8_t* DHCPOptionsOUTStart = ((uint8_t*)DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
     5e6:	cb 01       	movw	r24, r22
     5e8:	44 d2       	rcall	.+1160   	; 0xa72 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
     5ea:	80 ef       	ldi	r24, 0xF0	; 240
     5ec:	f8 01       	movw	r30, r16
     5ee:	11 92       	st	Z+, r1
     5f0:	8a 95       	dec	r24
     5f2:	e9 f7       	brne	.-6      	; 0x5ee <DHCP_ProcessDHCPPacket+0x2c>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
     5f4:	f7 01       	movw	r30, r14
     5f6:	81 81       	ldd	r24, Z+1	; 0x01
     5f8:	f8 01       	movw	r30, r16
     5fa:	81 83       	std	Z+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
     5fc:	82 e0       	ldi	r24, 0x02	; 2
     5fe:	80 83       	st	Z, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
     600:	f7 01       	movw	r30, r14
     602:	82 81       	ldd	r24, Z+2	; 0x02
     604:	f8 01       	movw	r30, r16
     606:	82 83       	std	Z+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
     608:	13 82       	std	Z+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
     60a:	f7 01       	movw	r30, r14
     60c:	84 81       	ldd	r24, Z+4	; 0x04
     60e:	95 81       	ldd	r25, Z+5	; 0x05
     610:	a6 81       	ldd	r26, Z+6	; 0x06
     612:	b7 81       	ldd	r27, Z+7	; 0x07
     614:	f8 01       	movw	r30, r16
     616:	84 83       	std	Z+4, r24	; 0x04
     618:	95 83       	std	Z+5, r25	; 0x05
     61a:	a6 83       	std	Z+6, r26	; 0x06
     61c:	b7 83       	std	Z+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
     61e:	11 86       	std	Z+9, r1	; 0x09
     620:	10 86       	std	Z+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
     622:	f7 01       	movw	r30, r14
     624:	82 85       	ldd	r24, Z+10	; 0x0a
     626:	93 85       	ldd	r25, Z+11	; 0x0b
     628:	f8 01       	movw	r30, r16
     62a:	93 87       	std	Z+11, r25	; 0x0b
     62c:	82 87       	std	Z+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
     62e:	80 90 30 01 	lds	r8, 0x0130	; 0x800130 <ClientIPAddress>
     632:	90 90 31 01 	lds	r9, 0x0131	; 0x800131 <ClientIPAddress+0x1>
     636:	a0 90 32 01 	lds	r10, 0x0132	; 0x800132 <ClientIPAddress+0x2>
     63a:	b0 90 33 01 	lds	r11, 0x0133	; 0x800133 <ClientIPAddress+0x3>
     63e:	80 8a       	std	Z+16, r8	; 0x10
     640:	91 8a       	std	Z+17, r9	; 0x11
     642:	a2 8a       	std	Z+18, r10	; 0x12
     644:	b3 8a       	std	Z+19, r11	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
     646:	b7 01       	movw	r22, r14
     648:	64 5e       	subi	r22, 0xE4	; 228
     64a:	7f 4f       	sbci	r23, 0xFF	; 255
     64c:	46 e0       	ldi	r20, 0x06	; 6
     64e:	50 e0       	ldi	r21, 0x00	; 0
     650:	c8 01       	movw	r24, r16
     652:	4c 96       	adiw	r24, 0x1c	; 28
     654:	0e 94 98 17 	call	0x2f30	; 0x2f30 <memmove>
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
     658:	f8 01       	movw	r30, r16
     65a:	e4 51       	subi	r30, 0x14	; 20
     65c:	ff 4f       	sbci	r31, 0xFF	; 255
     65e:	83 e6       	ldi	r24, 0x63	; 99
     660:	92 e8       	ldi	r25, 0x82	; 130
     662:	a3 e5       	ldi	r26, 0x53	; 83
     664:	b3 e6       	ldi	r27, 0x63	; 99
     666:	80 83       	st	Z, r24
     668:	91 83       	std	Z+1, r25	; 0x01
     66a:	a2 83       	std	Z+2, r26	; 0x02
     66c:	b3 83       	std	Z+3, r27	; 0x03

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
     66e:	f6 01       	movw	r30, r12
     670:	84 86       	std	Z+12, r8	; 0x0c
     672:	95 86       	std	Z+13, r9	; 0x0d
     674:	a6 86       	std	Z+14, r10	; 0x0e
     676:	b7 86       	std	Z+15, r11	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
     678:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <ServerIPAddress>
     67c:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <ServerIPAddress+0x1>
     680:	a0 91 40 01 	lds	r26, 0x0140	; 0x800140 <ServerIPAddress+0x2>
     684:	b0 91 41 01 	lds	r27, 0x0141	; 0x800141 <ServerIPAddress+0x3>
     688:	80 8b       	std	Z+16, r24	; 0x10
     68a:	91 8b       	std	Z+17, r25	; 0x11
     68c:	a2 8b       	std	Z+18, r26	; 0x12
     68e:	b3 8b       	std	Z+19, r27	; 0x13

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
     690:	5a c0       	rjmp	.+180    	; 0x746 <DHCP_ProcessDHCPPacket+0x184>
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
     692:	85 33       	cpi	r24, 0x35	; 53
     694:	09 f0       	breq	.+2      	; 0x698 <DHCP_ProcessDHCPPacket+0xd6>
     696:	4d c0       	rjmp	.+154    	; 0x732 <DHCP_ProcessDHCPPacket+0x170>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
     698:	9a 81       	ldd	r25, Y+2	; 0x02
     69a:	91 30       	cpi	r25, 0x01	; 1
     69c:	19 f0       	breq	.+6      	; 0x6a4 <DHCP_ProcessDHCPPacket+0xe2>
     69e:	93 30       	cpi	r25, 0x03	; 3
     6a0:	09 f0       	breq	.+2      	; 0x6a4 <DHCP_ProcessDHCPPacket+0xe2>
     6a2:	47 c0       	rjmp	.+142    	; 0x732 <DHCP_ProcessDHCPPacket+0x170>
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
     6a4:	85 e3       	ldi	r24, 0x35	; 53
     6a6:	f8 01       	movw	r30, r16
     6a8:	e0 51       	subi	r30, 0x10	; 16
     6aa:	ff 4f       	sbci	r31, 0xFF	; 255
     6ac:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 1;
     6ae:	81 e0       	ldi	r24, 0x01	; 1
     6b0:	31 96       	adiw	r30, 0x01	; 1
     6b2:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
     6b4:	8a 81       	ldd	r24, Y+2	; 0x02
     6b6:	81 30       	cpi	r24, 0x01	; 1
     6b8:	11 f4       	brne	.+4      	; 0x6be <DHCP_ProcessDHCPPacket+0xfc>
     6ba:	82 e0       	ldi	r24, 0x02	; 2
     6bc:	01 c0       	rjmp	.+2      	; 0x6c0 <DHCP_ProcessDHCPPacket+0xfe>
     6be:	85 e0       	ldi	r24, 0x05	; 5
     6c0:	f8 01       	movw	r30, r16
     6c2:	ee 50       	subi	r30, 0x0E	; 14
     6c4:	ff 4f       	sbci	r31, 0xFF	; 255
     6c6:	80 83       	st	Z, r24
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
     6c8:	31 96       	adiw	r30, 0x01	; 1
     6ca:	21 e0       	ldi	r18, 0x01	; 1
     6cc:	20 83       	st	Z, r18
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
     6ce:	31 96       	adiw	r30, 0x01	; 1
     6d0:	94 e0       	ldi	r25, 0x04	; 4
     6d2:	90 83       	st	Z, r25
				*(DHCPOptionsOUTStart++) = 0xFF;
     6d4:	31 96       	adiw	r30, 0x01	; 1
     6d6:	8f ef       	ldi	r24, 0xFF	; 255
     6d8:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0xFF;
     6da:	31 96       	adiw	r30, 0x01	; 1
     6dc:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0xFF;
     6de:	31 96       	adiw	r30, 0x01	; 1
     6e0:	80 83       	st	Z, r24
				*(DHCPOptionsOUTStart++) = 0x00;
     6e2:	31 96       	adiw	r30, 0x01	; 1
     6e4:	10 82       	st	Z, r1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_LEASETIME;
     6e6:	31 96       	adiw	r30, 0x01	; 1
     6e8:	33 e3       	ldi	r19, 0x33	; 51
     6ea:	30 83       	st	Z, r19
				*(DHCPOptionsOUTStart++) = sizeof(uint32_t);
     6ec:	31 96       	adiw	r30, 0x01	; 1
     6ee:	90 83       	st	Z, r25
				/* Lease Time 86400s (ONE_DAY) */
				*(DHCPOptionsOUTStart++) = 0x00;
     6f0:	31 96       	adiw	r30, 0x01	; 1
     6f2:	10 82       	st	Z, r1
				*(DHCPOptionsOUTStart++) = 0x01;
     6f4:	31 96       	adiw	r30, 0x01	; 1
     6f6:	20 83       	st	Z, r18
				*(DHCPOptionsOUTStart++) = 0x51;
     6f8:	31 96       	adiw	r30, 0x01	; 1
     6fa:	21 e5       	ldi	r18, 0x51	; 81
     6fc:	20 83       	st	Z, r18
				*(DHCPOptionsOUTStart++) = 0x80;
     6fe:	31 96       	adiw	r30, 0x01	; 1
     700:	20 e8       	ldi	r18, 0x80	; 128
     702:	20 83       	st	Z, r18

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
     704:	31 96       	adiw	r30, 0x01	; 1
     706:	26 e3       	ldi	r18, 0x36	; 54
     708:	20 83       	st	Z, r18
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
     70a:	31 96       	adiw	r30, 0x01	; 1
     70c:	90 83       	st	Z, r25
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
     70e:	31 96       	adiw	r30, 0x01	; 1
     710:	40 91 3e 01 	lds	r20, 0x013E	; 0x80013e <ServerIPAddress>
     714:	50 91 3f 01 	lds	r21, 0x013F	; 0x80013f <ServerIPAddress+0x1>
     718:	60 91 40 01 	lds	r22, 0x0140	; 0x800140 <ServerIPAddress+0x2>
     71c:	70 91 41 01 	lds	r23, 0x0141	; 0x800141 <ServerIPAddress+0x3>
     720:	40 83       	st	Z, r20
     722:	51 83       	std	Z+1, r21	; 0x01
     724:	62 83       	std	Z+2, r22	; 0x02
     726:	73 83       	std	Z+3, r23	; 0x03
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
     728:	34 96       	adiw	r30, 0x04	; 4
     72a:	80 83       	st	Z, r24

				return (sizeof(DHCP_Header_t) + 18 + sizeof(IP_Address_t));
     72c:	86 e0       	ldi	r24, 0x06	; 6
     72e:	91 e0       	ldi	r25, 0x01	; 1
     730:	10 c0       	rjmp	.+32     	; 0x752 <DHCP_ProcessDHCPPacket+0x190>
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
     732:	88 23       	and	r24, r24
     734:	21 f0       	breq	.+8      	; 0x73e <DHCP_ProcessDHCPPacket+0x17c>
     736:	89 81       	ldd	r24, Y+1	; 0x01
     738:	90 e0       	ldi	r25, 0x00	; 0
     73a:	02 96       	adiw	r24, 0x02	; 2
     73c:	02 c0       	rjmp	.+4      	; 0x742 <DHCP_ProcessDHCPPacket+0x180>
     73e:	81 e0       	ldi	r24, 0x01	; 1
     740:	90 e0       	ldi	r25, 0x00	; 0
     742:	c8 0f       	add	r28, r24
     744:	d9 1f       	adc	r29, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
     746:	88 81       	ld	r24, Y
     748:	8f 3f       	cpi	r24, 0xFF	; 255
     74a:	09 f0       	breq	.+2      	; 0x74e <DHCP_ProcessDHCPPacket+0x18c>
     74c:	a2 cf       	rjmp	.-188    	; 0x692 <DHCP_ProcessDHCPPacket+0xd0>

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
     74e:	80 e0       	ldi	r24, 0x00	; 0
     750:	90 e0       	ldi	r25, 0x00	; 0
}
     752:	df 91       	pop	r29
     754:	cf 91       	pop	r28
     756:	1f 91       	pop	r17
     758:	0f 91       	pop	r16
     75a:	ff 90       	pop	r15
     75c:	ef 90       	pop	r14
     75e:	df 90       	pop	r13
     760:	cf 90       	pop	r12
     762:	bf 90       	pop	r11
     764:	af 90       	pop	r10
     766:	9f 90       	pop	r9
     768:	8f 90       	pop	r8
     76a:	08 95       	ret

0000076c <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     76c:	0f 93       	push	r16
     76e:	1f 93       	push	r17
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	ec 01       	movw	r28, r24
     776:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN->FrameData);
     778:	76 d1       	rcall	.+748    	; 0xa66 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     77a:	46 e0       	ldi	r20, 0x06	; 6
     77c:	50 e0       	ldi	r21, 0x00	; 0
     77e:	62 e4       	ldi	r22, 0x42	; 66
     780:	71 e0       	ldi	r23, 0x01	; 1
     782:	ce 01       	movw	r24, r28
     784:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
     788:	89 2b       	or	r24, r25
     78a:	51 f0       	breq	.+20     	; 0x7a0 <Ethernet_ProcessPacket+0x34>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     78c:	46 e0       	ldi	r20, 0x06	; 6
     78e:	50 e0       	ldi	r21, 0x00	; 0
     790:	68 e3       	ldi	r22, 0x38	; 56
     792:	71 e0       	ldi	r23, 0x01	; 1
     794:	ce 01       	movw	r24, r28
     796:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     79a:	89 2b       	or	r24, r25
     79c:	09 f0       	breq	.+2      	; 0x7a0 <Ethernet_ProcessPacket+0x34>
     79e:	49 c0       	rjmp	.+146    	; 0x832 <Ethernet_ProcessPacket+0xc6>
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
     7a0:	fe 01       	movw	r30, r28
     7a2:	e4 52       	subi	r30, 0x24	; 36
     7a4:	fa 4f       	sbci	r31, 0xFA	; 250
     7a6:	20 81       	ld	r18, Z
     7a8:	31 81       	ldd	r19, Z+1	; 0x01
     7aa:	83 2f       	mov	r24, r19
     7ac:	92 2f       	mov	r25, r18

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
     7ae:	81 30       	cpi	r24, 0x01	; 1
     7b0:	96 40       	sbci	r25, 0x06	; 6
     7b2:	08 f4       	brcc	.+2      	; 0x7b6 <Ethernet_ProcessPacket+0x4a>
     7b4:	41 c0       	rjmp	.+130    	; 0x838 <Ethernet_ProcessPacket+0xcc>
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     7b6:	2c 85       	ldd	r18, Y+12	; 0x0c
     7b8:	3d 85       	ldd	r19, Y+13	; 0x0d
     7ba:	83 2f       	mov	r24, r19
     7bc:	92 2f       	mov	r25, r18
     7be:	81 15       	cp	r24, r1
     7c0:	e8 e0       	ldi	r30, 0x08	; 8
     7c2:	9e 07       	cpc	r25, r30
     7c4:	51 f0       	breq	.+20     	; 0x7da <Ethernet_ProcessPacket+0x6e>
     7c6:	86 30       	cpi	r24, 0x06	; 6
     7c8:	98 40       	sbci	r25, 0x08	; 8
     7ca:	81 f4       	brne	.+32     	; 0x7ec <Ethernet_ProcessPacket+0x80>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
     7cc:	b8 01       	movw	r22, r16
     7ce:	62 5f       	subi	r22, 0xF2	; 242
     7d0:	7f 4f       	sbci	r23, 0xFF	; 255
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     7d2:	ce 01       	movw	r24, r28
     7d4:	0e 96       	adiw	r24, 0x0e	; 14
     7d6:	81 de       	rcall	.-766    	; 0x4da <ARP_ProcessARPPacket>
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     7d8:	0b c0       	rjmp	.+22     	; 0x7f0 <Ethernet_ProcessPacket+0x84>
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     7da:	a8 01       	movw	r20, r16
     7dc:	42 5f       	subi	r20, 0xF2	; 242
     7de:	5f 4f       	sbci	r21, 0xFF	; 255
     7e0:	be 01       	movw	r22, r28
     7e2:	62 5f       	subi	r22, 0xF2	; 242
     7e4:	7f 4f       	sbci	r23, 0xFF	; 255
     7e6:	ce 01       	movw	r24, r28
     7e8:	a9 d0       	rcall	.+338    	; 0x93c <IP_ProcessIPPacket>
				                             &FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
     7ea:	02 c0       	rjmp	.+4      	; 0x7f0 <Ethernet_ProcessPacket+0x84>

	/* Cast the incoming Ethernet frame to the Ethernet header type */
	Ethernet_Frame_Header_t* FrameINHeader  = (Ethernet_Frame_Header_t*)&FrameIN->FrameData;
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;
     7ec:	80 e0       	ldi	r24, 0x00	; 0
     7ee:	90 e0       	ldi	r25, 0x00	; 0
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     7f0:	18 16       	cp	r1, r24
     7f2:	19 06       	cpc	r1, r25
     7f4:	1c f5       	brge	.+70     	; 0x83c <Ethernet_ProcessPacket+0xd0>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     7f6:	26 e0       	ldi	r18, 0x06	; 6
     7f8:	e2 e4       	ldi	r30, 0x42	; 66
     7fa:	f1 e0       	ldi	r31, 0x01	; 1
     7fc:	d8 01       	movw	r26, r16
     7fe:	16 96       	adiw	r26, 0x06	; 6
     800:	01 90       	ld	r0, Z+
     802:	0d 92       	st	X+, r0
     804:	2a 95       	dec	r18
     806:	e1 f7       	brne	.-8      	; 0x800 <Ethernet_ProcessPacket+0x94>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     808:	26 e0       	ldi	r18, 0x06	; 6
     80a:	fe 01       	movw	r30, r28
     80c:	36 96       	adiw	r30, 0x06	; 6
     80e:	d8 01       	movw	r26, r16
     810:	01 90       	ld	r0, Z+
     812:	0d 92       	st	X+, r0
     814:	2a 95       	dec	r18
     816:	e1 f7       	brne	.-8      	; 0x810 <Ethernet_ProcessPacket+0xa4>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     818:	2c 85       	ldd	r18, Y+12	; 0x0c
     81a:	3d 85       	ldd	r19, Y+13	; 0x0d
     81c:	f8 01       	movw	r30, r16
     81e:	35 87       	std	Z+13, r19	; 0x0d
     820:	24 87       	std	Z+12, r18	; 0x0c

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     822:	e4 52       	subi	r30, 0x24	; 36
     824:	fa 4f       	sbci	r31, 0xFA	; 250
     826:	9c 01       	movw	r18, r24
     828:	22 5f       	subi	r18, 0xF2	; 242
     82a:	3f 4f       	sbci	r19, 0xFF	; 255
     82c:	31 83       	std	Z+1, r19	; 0x01
     82e:	20 83       	st	Z, r18
     830:	05 c0       	rjmp	.+10     	; 0x83c <Ethernet_ProcessPacket+0xd0>

	/* Cast the incoming Ethernet frame to the Ethernet header type */
	Ethernet_Frame_Header_t* FrameINHeader  = (Ethernet_Frame_Header_t*)&FrameIN->FrameData;
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;
     832:	80 e0       	ldi	r24, 0x00	; 0
     834:	90 e0       	ldi	r25, 0x00	; 0
     836:	02 c0       	rjmp	.+4      	; 0x83c <Ethernet_ProcessPacket+0xd0>
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	90 e0       	ldi	r25, 0x00	; 0
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     83c:	01 96       	adiw	r24, 0x01	; 1
     83e:	21 f0       	breq	.+8      	; 0x848 <Ethernet_ProcessPacket+0xdc>
	{
		/* Clear the frame buffer */
		FrameIN->FrameLength = 0;
     840:	c4 52       	subi	r28, 0x24	; 36
     842:	da 4f       	sbci	r29, 0xFA	; 250
     844:	19 82       	std	Y+1, r1	; 0x01
     846:	18 82       	st	Y, r1
	}
}
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	1f 91       	pop	r17
     84e:	0f 91       	pop	r16
     850:	08 95       	ret

00000852 <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     852:	cf 93       	push	r28
     854:	df 93       	push	r29
     856:	ec 01       	movw	r28, r24
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     858:	20 e0       	ldi	r18, 0x00	; 0
     85a:	30 e0       	ldi	r19, 0x00	; 0
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;
     85c:	80 e0       	ldi	r24, 0x00	; 0
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	dc 01       	movw	r26, r24

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     862:	0d c0       	rjmp	.+26     	; 0x87e <Ethernet_Checksum16+0x2c>
	  Checksum += Words[CurrWord];
     864:	f9 01       	movw	r30, r18
     866:	ee 0f       	add	r30, r30
     868:	ff 1f       	adc	r31, r31
     86a:	ec 0f       	add	r30, r28
     86c:	fd 1f       	adc	r31, r29
     86e:	40 81       	ld	r20, Z
     870:	51 81       	ldd	r21, Z+1	; 0x01
     872:	84 0f       	add	r24, r20
     874:	95 1f       	adc	r25, r21
     876:	a1 1d       	adc	r26, r1
     878:	b1 1d       	adc	r27, r1
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     87a:	2f 5f       	subi	r18, 0xFF	; 255
     87c:	3f 4f       	sbci	r19, 0xFF	; 255
     87e:	ab 01       	movw	r20, r22
     880:	56 95       	lsr	r21
     882:	47 95       	ror	r20
     884:	24 17       	cp	r18, r20
     886:	35 07       	cpc	r19, r21
     888:	68 f3       	brcs	.-38     	; 0x864 <Ethernet_Checksum16+0x12>
     88a:	0b c0       	rjmp	.+22     	; 0x8a2 <Ethernet_Checksum16+0x50>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     88c:	ac 01       	movw	r20, r24
     88e:	bd 01       	movw	r22, r26
     890:	66 27       	eor	r22, r22
     892:	77 27       	eor	r23, r23
     894:	cd 01       	movw	r24, r26
     896:	aa 27       	eor	r26, r26
     898:	bb 27       	eor	r27, r27
     89a:	84 0f       	add	r24, r20
     89c:	95 1f       	adc	r25, r21
     89e:	a6 1f       	adc	r26, r22
     8a0:	b7 1f       	adc	r27, r23
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     8a2:	ac 01       	movw	r20, r24
     8a4:	bd 01       	movw	r22, r26
     8a6:	44 27       	eor	r20, r20
     8a8:	55 27       	eor	r21, r21
     8aa:	45 2b       	or	r20, r21
     8ac:	46 2b       	or	r20, r22
     8ae:	47 2b       	or	r20, r23
     8b0:	69 f7       	brne	.-38     	; 0x88c <Ethernet_Checksum16+0x3a>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
     8b2:	80 95       	com	r24
     8b4:	90 95       	com	r25
}
     8b6:	df 91       	pop	r29
     8b8:	cf 91       	pop	r28
     8ba:	08 95       	ret

000008bc <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     8bc:	ef 92       	push	r14
     8be:	ff 92       	push	r15
     8c0:	0f 93       	push	r16
     8c2:	1f 93       	push	r17
     8c4:	cf 93       	push	r28
     8c6:	df 93       	push	r29
     8c8:	8c 01       	movw	r16, r24
     8ca:	eb 01       	movw	r28, r22
     8cc:	7a 01       	movw	r14, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     8ce:	cb 01       	movw	r24, r22
     8d0:	cd d0       	rcall	.+410    	; 0xa6c <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     8d2:	88 81       	ld	r24, Y
     8d4:	88 30       	cpi	r24, 0x08	; 8
     8d6:	49 f5       	brne	.+82     	; 0x92a <ICMP_ProcessICMPPacket+0x6e>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     8d8:	f7 01       	movw	r30, r14
     8da:	10 82       	st	Z, r1
		ICMPHeaderOUT->Code     = 0;
     8dc:	11 82       	std	Z+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     8de:	13 82       	std	Z+3, r1	; 0x03
     8e0:	12 82       	std	Z+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     8e2:	8c 81       	ldd	r24, Y+4	; 0x04
     8e4:	9d 81       	ldd	r25, Y+5	; 0x05
     8e6:	95 83       	std	Z+5, r25	; 0x05
     8e8:	84 83       	std	Z+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     8ea:	8e 81       	ldd	r24, Y+6	; 0x06
     8ec:	9f 81       	ldd	r25, Y+7	; 0x07
     8ee:	97 83       	std	Z+7, r25	; 0x07
     8f0:	86 83       	std	Z+6, r24	; 0x06

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     8f2:	f8 01       	movw	r30, r16
     8f4:	e4 52       	subi	r30, 0x24	; 36
     8f6:	fa 4f       	sbci	r31, 0xFA	; 250
     8f8:	80 81       	ld	r24, Z
     8fa:	91 81       	ldd	r25, Z+1	; 0x01
     8fc:	0c 1b       	sub	r16, r28
     8fe:	1d 0b       	sbc	r17, r29
     900:	08 0f       	add	r16, r24
     902:	19 1f       	adc	r17, r25
     904:	a8 01       	movw	r20, r16
     906:	48 50       	subi	r20, 0x08	; 8
     908:	51 09       	sbc	r21, r1

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     90a:	be 01       	movw	r22, r28
     90c:	68 5f       	subi	r22, 0xF8	; 248
     90e:	7f 4f       	sbci	r23, 0xFF	; 255
     910:	c7 01       	movw	r24, r14
     912:	08 96       	adiw	r24, 0x08	; 8
     914:	0e 94 98 17 	call	0x2f30	; 0x2f30 <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     918:	b8 01       	movw	r22, r16
     91a:	c7 01       	movw	r24, r14
     91c:	9a df       	rcall	.-204    	; 0x852 <Ethernet_Checksum16>
     91e:	f7 01       	movw	r30, r14
     920:	93 83       	std	Z+3, r25	; 0x03
     922:	82 83       	std	Z+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     924:	80 2f       	mov	r24, r16
     926:	91 2f       	mov	r25, r17
     928:	02 c0       	rjmp	.+4      	; 0x92e <ICMP_ProcessICMPPacket+0x72>
	}

	return NO_RESPONSE;
     92a:	80 e0       	ldi	r24, 0x00	; 0
     92c:	90 e0       	ldi	r25, 0x00	; 0
}
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	1f 91       	pop	r17
     934:	0f 91       	pop	r16
     936:	ff 90       	pop	r15
     938:	ef 90       	pop	r14
     93a:	08 95       	ret

0000093c <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
     93c:	af 92       	push	r10
     93e:	bf 92       	push	r11
     940:	cf 92       	push	r12
     942:	df 92       	push	r13
     944:	ef 92       	push	r14
     946:	ff 92       	push	r15
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
     950:	6c 01       	movw	r12, r24
     952:	7b 01       	movw	r14, r22
     954:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
     956:	cb 01       	movw	r24, r22
     958:	88 d0       	rcall	.+272    	; 0xa6a <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
     95a:	f7 01       	movw	r30, r14
     95c:	60 81       	ld	r22, Z
     95e:	6f 70       	andi	r22, 0x0F	; 15
     960:	70 e0       	ldi	r23, 0x00	; 0
     962:	8b 01       	movw	r16, r22
     964:	00 0f       	add	r16, r16
     966:	11 1f       	adc	r17, r17
     968:	00 0f       	add	r16, r16
     96a:	11 1f       	adc	r17, r17

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
     96c:	57 01       	movw	r10, r14
     96e:	f0 e1       	ldi	r31, 0x10	; 16
     970:	af 0e       	add	r10, r31
     972:	b1 1c       	adc	r11, r1
     974:	44 e0       	ldi	r20, 0x04	; 4
     976:	50 e0       	ldi	r21, 0x00	; 0
     978:	6e e3       	ldi	r22, 0x3E	; 62
     97a:	71 e0       	ldi	r23, 0x01	; 1
     97c:	c5 01       	movw	r24, r10
     97e:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
     982:	89 2b       	or	r24, r25
     984:	51 f0       	breq	.+20     	; 0x99a <IP_ProcessIPPacket+0x5e>
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
     986:	44 e0       	ldi	r20, 0x04	; 4
     988:	50 e0       	ldi	r21, 0x00	; 0
     98a:	64 e3       	ldi	r22, 0x34	; 52
     98c:	71 e0       	ldi	r23, 0x01	; 1
     98e:	c5 01       	movw	r24, r10
     990:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
     994:	89 2b       	or	r24, r25
     996:	09 f0       	breq	.+2      	; 0x99a <IP_ProcessIPPacket+0x5e>
     998:	56 c0       	rjmp	.+172    	; 0xa46 <IP_ProcessIPPacket+0x10a>
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
     99a:	f7 01       	movw	r30, r14
     99c:	81 85       	ldd	r24, Z+9	; 0x09
     99e:	86 30       	cpi	r24, 0x06	; 6
     9a0:	71 f0       	breq	.+28     	; 0x9be <IP_ProcessIPPacket+0x82>
     9a2:	81 31       	cpi	r24, 0x11	; 17
     9a4:	b1 f0       	breq	.+44     	; 0x9d2 <IP_ProcessIPPacket+0x96>
     9a6:	81 30       	cpi	r24, 0x01	; 1
     9a8:	f1 f4       	brne	.+60     	; 0x9e6 <IP_ProcessIPPacket+0xaa>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
     9aa:	b7 01       	movw	r22, r14
     9ac:	60 0f       	add	r22, r16
     9ae:	71 1f       	adc	r23, r17
     9b0:	ae 01       	movw	r20, r28
     9b2:	4c 5e       	subi	r20, 0xEC	; 236
     9b4:	5f 4f       	sbci	r21, 0xFF	; 255
     9b6:	c6 01       	movw	r24, r12
     9b8:	81 df       	rcall	.-254    	; 0x8bc <ICMP_ProcessICMPPacket>
     9ba:	8c 01       	movw	r16, r24
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
     9bc:	16 c0       	rjmp	.+44     	; 0x9ea <IP_ProcessIPPacket+0xae>
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
     9be:	b7 01       	movw	r22, r14
     9c0:	60 0f       	add	r22, r16
     9c2:	71 1f       	adc	r23, r17
     9c4:	ae 01       	movw	r20, r28
     9c6:	4c 5e       	subi	r20, 0xEC	; 236
     9c8:	5f 4f       	sbci	r21, 0xFF	; 255
     9ca:	c7 01       	movw	r24, r14
     9cc:	e4 d3       	rcall	.+1992   	; 0x1196 <TCP_ProcessTCPPacket>
     9ce:	8c 01       	movw	r16, r24
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
     9d0:	0c c0       	rjmp	.+24     	; 0x9ea <IP_ProcessIPPacket+0xae>
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
     9d2:	b7 01       	movw	r22, r14
     9d4:	60 0f       	add	r22, r16
     9d6:	71 1f       	adc	r23, r17
     9d8:	ae 01       	movw	r20, r28
     9da:	4c 5e       	subi	r20, 0xEC	; 236
     9dc:	5f 4f       	sbci	r21, 0xFF	; 255
     9de:	c7 01       	movw	r24, r14
     9e0:	44 d6       	rcall	.+3208   	; 0x166a <UDP_ProcessUDPPacket>
     9e2:	8c 01       	movw	r16, r24
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
     9e4:	02 c0       	rjmp	.+4      	; 0x9ea <IP_ProcessIPPacket+0xae>
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));

	int16_t  RetSize = NO_RESPONSE;
     9e6:	00 e0       	ldi	r16, 0x00	; 0
     9e8:	10 e0       	ldi	r17, 0x00	; 0
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
     9ea:	10 16       	cp	r1, r16
     9ec:	11 06       	cpc	r1, r17
     9ee:	74 f5       	brge	.+92     	; 0xa4c <IP_ProcessIPPacket+0x110>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
     9f0:	0c 5e       	subi	r16, 0xEC	; 236
     9f2:	1f 4f       	sbci	r17, 0xFF	; 255
     9f4:	1a 83       	std	Y+2, r17	; 0x02
     9f6:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
     9f8:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
     9fa:	85 e4       	ldi	r24, 0x45	; 69
     9fc:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
     9fe:	1e 82       	std	Y+6, r1	; 0x06
     a00:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
     a02:	1d 82       	std	Y+5, r1	; 0x05
     a04:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
     a06:	1b 86       	std	Y+11, r1	; 0x0b
     a08:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
     a0a:	f7 01       	movw	r30, r14
     a0c:	81 85       	ldd	r24, Z+9	; 0x09
     a0e:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
     a10:	80 e8       	ldi	r24, 0x80	; 128
     a12:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
     a14:	80 89       	ldd	r24, Z+16	; 0x10
     a16:	91 89       	ldd	r25, Z+17	; 0x11
     a18:	a2 89       	ldd	r26, Z+18	; 0x12
     a1a:	b3 89       	ldd	r27, Z+19	; 0x13
     a1c:	8c 87       	std	Y+12, r24	; 0x0c
     a1e:	9d 87       	std	Y+13, r25	; 0x0d
     a20:	ae 87       	std	Y+14, r26	; 0x0e
     a22:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
     a24:	84 85       	ldd	r24, Z+12	; 0x0c
     a26:	95 85       	ldd	r25, Z+13	; 0x0d
     a28:	a6 85       	ldd	r26, Z+14	; 0x0e
     a2a:	b7 85       	ldd	r27, Z+15	; 0x0f
     a2c:	88 8b       	std	Y+16, r24	; 0x10
     a2e:	99 8b       	std	Y+17, r25	; 0x11
     a30:	aa 8b       	std	Y+18, r26	; 0x12

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
     a32:	bb 8b       	std	Y+19, r27	; 0x13
     a34:	64 e1       	ldi	r22, 0x14	; 20
     a36:	70 e0       	ldi	r23, 0x00	; 0
     a38:	ce 01       	movw	r24, r28
     a3a:	0b df       	rcall	.-490    	; 0x852 <Ethernet_Checksum16>
     a3c:	9b 87       	std	Y+11, r25	; 0x0b
     a3e:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
     a40:	80 2f       	mov	r24, r16
     a42:	91 2f       	mov	r25, r17
     a44:	05 c0       	rjmp	.+10     	; 0xa50 <IP_ProcessIPPacket+0x114>

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
	    !(IP_COMPARE(&IPHeaderIN->DestinationAddress, &BroadcastIPAddress)))
	{
		return NO_RESPONSE;
     a46:	80 e0       	ldi	r24, 0x00	; 0
     a48:	90 e0       	ldi	r25, 0x00	; 0
     a4a:	02 c0       	rjmp	.+4      	; 0xa50 <IP_ProcessIPPacket+0x114>

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
	}

	return RetSize;
     a4c:	80 2f       	mov	r24, r16
     a4e:	91 2f       	mov	r25, r17
}
     a50:	df 91       	pop	r29
     a52:	cf 91       	pop	r28
     a54:	1f 91       	pop	r17
     a56:	0f 91       	pop	r16
     a58:	ff 90       	pop	r15
     a5a:	ef 90       	pop	r14
     a5c:	df 90       	pop	r13
     a5e:	cf 90       	pop	r12
     a60:	bf 90       	pop	r11
     a62:	af 90       	pop	r10
     a64:	08 95       	ret

00000a66 <DecodeEthernetFrameHeader>:
/** Decodes an Ethernet frame header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of an Ethernet frame of data
 */
void DecodeEthernetFrameHeader(void* InDataStart)
{
     a66:	08 95       	ret

00000a68 <DecodeARPHeader>:
/** Decodes an ARP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of an ARP packet header
 */
void DecodeARPHeader(void* InDataStart)
{
     a68:	08 95       	ret

00000a6a <DecodeIPHeader>:
/** Decodes an IP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of an IP packet header
 */
void DecodeIPHeader(void* InDataStart)
{
     a6a:	08 95       	ret

00000a6c <DecodeICMPHeader>:
/** Decodes an ICMP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of an ICMP packet header
 */
void DecodeICMPHeader(void* InDataStart)
{
     a6c:	08 95       	ret

00000a6e <DecodeTCPHeader>:
/** Decodes a TCP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of a TCP packet header
 */
void DecodeTCPHeader(void* InDataStart)
{
     a6e:	08 95       	ret

00000a70 <DecodeUDPHeader>:
/** Decodes an UDP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of a UDP packet header
 */
void DecodeUDPHeader(void* InDataStart)
{
     a70:	08 95       	ret

00000a72 <DecodeDHCPHeader>:
/** Decodes an DHCP header and prints its contents to through the USART in a human readable format.
 *
 *  \param[in] InDataStart  Pointer to the start of a DHCP packet header
 */
void DecodeDHCPHeader(void* InDataStart)
{
     a72:	08 95       	ret

00000a74 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t* SourceAddress,
                               const IP_Address_t* DestinationAddress,
                               uint16_t TCPOutSize)
{
     a74:	cf 93       	push	r28
     a76:	df 93       	push	r29
     a78:	ec 01       	movw	r28, r24
	uint32_t Checksum = 0;

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)SourceAddress)[0];
     a7a:	db 01       	movw	r26, r22
     a7c:	ed 91       	ld	r30, X+
     a7e:	fc 91       	ld	r31, X
     a80:	11 97       	sbiw	r26, 0x01	; 1
	Checksum += ((uint16_t*)SourceAddress)[1];
     a82:	12 96       	adiw	r26, 0x02	; 2
     a84:	8d 91       	ld	r24, X+
     a86:	9c 91       	ld	r25, X
     a88:	13 97       	sbiw	r26, 0x03	; 3
     a8a:	a0 e0       	ldi	r26, 0x00	; 0
     a8c:	b0 e0       	ldi	r27, 0x00	; 0
     a8e:	8e 0f       	add	r24, r30
     a90:	9f 1f       	adc	r25, r31
     a92:	a1 1d       	adc	r26, r1
     a94:	b1 1d       	adc	r27, r1
	Checksum += ((uint16_t*)DestinationAddress)[0];
     a96:	fa 01       	movw	r30, r20
     a98:	60 81       	ld	r22, Z
     a9a:	71 81       	ldd	r23, Z+1	; 0x01
     a9c:	86 0f       	add	r24, r22
     a9e:	97 1f       	adc	r25, r23
     aa0:	a1 1d       	adc	r26, r1
     aa2:	b1 1d       	adc	r27, r1
	Checksum += ((uint16_t*)DestinationAddress)[1];
     aa4:	42 81       	ldd	r20, Z+2	; 0x02
     aa6:	53 81       	ldd	r21, Z+3	; 0x03
     aa8:	84 0f       	add	r24, r20
     aaa:	95 1f       	adc	r25, r21
     aac:	a1 1d       	adc	r26, r1
     aae:	b1 1d       	adc	r27, r1
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     ab0:	9a 5f       	subi	r25, 0xFA	; 250
     ab2:	af 4f       	sbci	r26, 0xFF	; 255
     ab4:	bf 4f       	sbci	r27, 0xFF	; 255
     ab6:	43 2f       	mov	r20, r19
     ab8:	52 2f       	mov	r21, r18
	Checksum += SwapEndian_16(TCPOutSize);
     aba:	84 0f       	add	r24, r20
     abc:	95 1f       	adc	r25, r21
     abe:	a1 1d       	adc	r26, r1
     ac0:	b1 1d       	adc	r27, r1

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     ac2:	40 e0       	ldi	r20, 0x00	; 0
     ac4:	50 e0       	ldi	r21, 0x00	; 0
     ac6:	0d c0       	rjmp	.+26     	; 0xae2 <TCP_Checksum16+0x6e>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     ac8:	fa 01       	movw	r30, r20
     aca:	ee 0f       	add	r30, r30
     acc:	ff 1f       	adc	r31, r31
     ace:	ec 0f       	add	r30, r28
     ad0:	fd 1f       	adc	r31, r29
     ad2:	60 81       	ld	r22, Z
     ad4:	71 81       	ldd	r23, Z+1	; 0x01
     ad6:	86 0f       	add	r24, r22
     ad8:	97 1f       	adc	r25, r23
     ada:	a1 1d       	adc	r26, r1
     adc:	b1 1d       	adc	r27, r1
	Checksum += ((uint16_t*)DestinationAddress)[0];
	Checksum += ((uint16_t*)DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     ade:	4f 5f       	subi	r20, 0xFF	; 255
     ae0:	5f 4f       	sbci	r21, 0xFF	; 255
     ae2:	b9 01       	movw	r22, r18
     ae4:	76 95       	lsr	r23
     ae6:	67 95       	ror	r22
     ae8:	46 17       	cp	r20, r22
     aea:	57 07       	cpc	r21, r23
     aec:	68 f3       	brcs	.-38     	; 0xac8 <TCP_Checksum16+0x54>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     aee:	20 ff       	sbrs	r18, 0
     af0:	18 c0       	rjmp	.+48     	; 0xb22 <TCP_Checksum16+0xae>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     af2:	66 0f       	add	r22, r22
     af4:	77 1f       	adc	r23, r23
     af6:	fe 01       	movw	r30, r28
     af8:	e6 0f       	add	r30, r22
     afa:	f7 1f       	adc	r31, r23
     afc:	20 81       	ld	r18, Z
     afe:	31 81       	ldd	r19, Z+1	; 0x01
     b00:	33 27       	eor	r19, r19
     b02:	82 0f       	add	r24, r18
     b04:	93 1f       	adc	r25, r19
     b06:	a1 1d       	adc	r26, r1
     b08:	b1 1d       	adc	r27, r1
     b0a:	0b c0       	rjmp	.+22     	; 0xb22 <TCP_Checksum16+0xae>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     b0c:	ac 01       	movw	r20, r24
     b0e:	bd 01       	movw	r22, r26
     b10:	66 27       	eor	r22, r22
     b12:	77 27       	eor	r23, r23
     b14:	cd 01       	movw	r24, r26
     b16:	aa 27       	eor	r26, r26
     b18:	bb 27       	eor	r27, r27
     b1a:	84 0f       	add	r24, r20
     b1c:	95 1f       	adc	r25, r21
     b1e:	a6 1f       	adc	r26, r22
     b20:	b7 1f       	adc	r27, r23
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     b22:	ac 01       	movw	r20, r24
     b24:	bd 01       	movw	r22, r26
     b26:	44 27       	eor	r20, r20
     b28:	55 27       	eor	r21, r21
     b2a:	45 2b       	or	r20, r21
     b2c:	46 2b       	or	r20, r22
     b2e:	47 2b       	or	r20, r23
     b30:	69 f7       	brne	.-38     	; 0xb0c <TCP_Checksum16+0x98>
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
     b32:	80 95       	com	r24
     b34:	90 95       	com	r25
}
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	08 95       	ret

00000b3c <TCP_TCPTask>:
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
     b3c:	8f 92       	push	r8
     b3e:	9f 92       	push	r9
     b40:	af 92       	push	r10
     b42:	bf 92       	push	r11
     b44:	cf 92       	push	r12
     b46:	df 92       	push	r13
     b48:	ef 92       	push	r14
     b4a:	ff 92       	push	r15
     b4c:	0f 93       	push	r16
     b4e:	1f 93       	push	r17
     b50:	cf 93       	push	r28
     b52:	df 93       	push	r29
     b54:	8b 01       	movw	r16, r22
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     b56:	d0 e0       	ldi	r29, 0x00	; 0
     b58:	4e c0       	rjmp	.+156    	; 0xbf6 <TCP_TCPTask+0xba>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     b5a:	8c 2f       	mov	r24, r28
     b5c:	90 e0       	ldi	r25, 0x00	; 0
     b5e:	fc 01       	movw	r30, r24
     b60:	ee 0f       	add	r30, r30
     b62:	ff 1f       	adc	r31, r31
     b64:	ee 0f       	add	r30, r30
     b66:	ff 1f       	adc	r31, r31
     b68:	e8 0f       	add	r30, r24
     b6a:	f9 1f       	adc	r31, r25
     b6c:	e3 5c       	subi	r30, 0xC3	; 195
     b6e:	fb 4e       	sbci	r31, 0xEB	; 235
     b70:	60 81       	ld	r22, Z
     b72:	71 81       	ldd	r23, Z+1	; 0x01
     b74:	2d 2f       	mov	r18, r29
     b76:	30 e0       	ldi	r19, 0x00	; 0
     b78:	46 e1       	ldi	r20, 0x16	; 22
     b7a:	52 e0       	ldi	r21, 0x02	; 2
     b7c:	24 9f       	mul	r18, r20
     b7e:	f0 01       	movw	r30, r0
     b80:	25 9f       	mul	r18, r21
     b82:	f0 0d       	add	r31, r0
     b84:	34 9f       	mul	r19, r20
     b86:	f0 0d       	add	r31, r0
     b88:	11 24       	eor	r1, r1
     b8a:	e5 50       	subi	r30, 0x05	; 5
     b8c:	f2 4f       	sbci	r31, 0xF2	; 242
     b8e:	40 81       	ld	r20, Z
     b90:	51 81       	ldd	r21, Z+1	; 0x01
     b92:	64 17       	cp	r22, r20
     b94:	75 07       	cpc	r23, r21
     b96:	41 f5       	brne	.+80     	; 0xbe8 <TCP_TCPTask+0xac>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
     b98:	fc 01       	movw	r30, r24
     b9a:	ee 0f       	add	r30, r30
     b9c:	ff 1f       	adc	r31, r31
     b9e:	ee 0f       	add	r30, r30
     ba0:	ff 1f       	adc	r31, r31
     ba2:	e8 0f       	add	r30, r24
     ba4:	f9 1f       	adc	r31, r25
     ba6:	e3 5c       	subi	r30, 0xC3	; 195
     ba8:	fb 4e       	sbci	r31, 0xEB	; 235
     baa:	42 81       	ldd	r20, Z+2	; 0x02
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
     bac:	41 30       	cpi	r20, 0x01	; 1
     bae:	e1 f4       	brne	.+56     	; 0xbe8 <TCP_TCPTask+0xac>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
     bb0:	fc 01       	movw	r30, r24
     bb2:	ee 0f       	add	r30, r30
     bb4:	ff 1f       	adc	r31, r31
     bb6:	ee 0f       	add	r30, r30
     bb8:	ff 1f       	adc	r31, r31
     bba:	8e 0f       	add	r24, r30
     bbc:	9f 1f       	adc	r25, r31
     bbe:	fc 01       	movw	r30, r24
     bc0:	e3 5c       	subi	r30, 0xC3	; 195
     bc2:	fb 4e       	sbci	r31, 0xEB	; 235
     bc4:	03 80       	ldd	r0, Z+3	; 0x03
     bc6:	f4 81       	ldd	r31, Z+4	; 0x04
     bc8:	e0 2d       	mov	r30, r0
     bca:	46 e1       	ldi	r20, 0x16	; 22
     bcc:	52 e0       	ldi	r21, 0x02	; 2
     bce:	24 9f       	mul	r18, r20
     bd0:	c0 01       	movw	r24, r0
     bd2:	25 9f       	mul	r18, r21
     bd4:	90 0d       	add	r25, r0
     bd6:	34 9f       	mul	r19, r20
     bd8:	90 0d       	add	r25, r0
     bda:	11 24       	eor	r1, r1
     bdc:	bc 01       	movw	r22, r24
     bde:	65 5f       	subi	r22, 0xF5	; 245
     be0:	71 4f       	sbci	r23, 0xF1	; 241
     be2:	85 50       	subi	r24, 0x05	; 5
     be4:	92 4f       	sbci	r25, 0xF2	; 242
     be6:	09 95       	icall
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
     be8:	cf 5f       	subi	r28, 0xFF	; 255
     bea:	01 c0       	rjmp	.+2      	; 0xbee <TCP_TCPTask+0xb2>
     bec:	c0 e0       	ldi	r28, 0x00	; 0
     bee:	cc 23       	and	r28, r28
     bf0:	09 f4       	brne	.+2      	; 0xbf4 <TCP_TCPTask+0xb8>
     bf2:	b3 cf       	rjmp	.-154    	; 0xb5a <TCP_TCPTask+0x1e>
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     bf4:	df 5f       	subi	r29, 0xFF	; 255
     bf6:	d3 30       	cpi	r29, 0x03	; 3
     bf8:	c8 f3       	brcs	.-14     	; 0xbec <TCP_TCPTask+0xb0>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
     bfa:	f8 01       	movw	r30, r16
     bfc:	e4 52       	subi	r30, 0x24	; 36
     bfe:	fa 4f       	sbci	r31, 0xFA	; 250
     c00:	80 81       	ld	r24, Z
     c02:	91 81       	ldd	r25, Z+1	; 0x01
     c04:	89 2b       	or	r24, r25
     c06:	09 f0       	breq	.+2      	; 0xc0a <TCP_TCPTask+0xce>
     c08:	ce c0       	rjmp	.+412    	; 0xda6 <TCP_TCPTask+0x26a>
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	c9 c0       	rjmp	.+402    	; 0xda0 <TCP_TCPTask+0x264>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
     c0e:	28 2f       	mov	r18, r24
     c10:	30 e0       	ldi	r19, 0x00	; 0
     c12:	46 e1       	ldi	r20, 0x16	; 22
     c14:	52 e0       	ldi	r21, 0x02	; 2
     c16:	24 9f       	mul	r18, r20
     c18:	f0 01       	movw	r30, r0
     c1a:	25 9f       	mul	r18, r21
     c1c:	f0 0d       	add	r31, r0
     c1e:	34 9f       	mul	r19, r20
     c20:	f0 0d       	add	r31, r0
     c22:	11 24       	eor	r1, r1
     c24:	e3 5f       	subi	r30, 0xF3	; 243
     c26:	ff 4e       	sbci	r31, 0xEF	; 239
     c28:	90 81       	ld	r25, Z
     c2a:	99 23       	and	r25, r25
     c2c:	09 f4       	brne	.+2      	; 0xc30 <TCP_TCPTask+0xf4>
     c2e:	b7 c0       	rjmp	.+366    	; 0xd9e <TCP_TCPTask+0x262>
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
     c30:	24 9f       	mul	r18, r20
     c32:	f0 01       	movw	r30, r0
     c34:	25 9f       	mul	r18, r21
     c36:	f0 0d       	add	r31, r0
     c38:	34 9f       	mul	r19, r20
     c3a:	f0 0d       	add	r31, r0
     c3c:	11 24       	eor	r1, r1
     c3e:	e2 5f       	subi	r30, 0xF2	; 242
     c40:	ff 4e       	sbci	r31, 0xEF	; 239
     c42:	90 81       	ld	r25, Z

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
     c44:	99 23       	and	r25, r25
     c46:	09 f4       	brne	.+2      	; 0xc4a <TCP_TCPTask+0x10e>
     c48:	aa c0       	rjmp	.+340    	; 0xd9e <TCP_TCPTask+0x262>
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
     c4a:	58 01       	movw	r10, r16
     c4c:	8e e0       	ldi	r24, 0x0E	; 14
     c4e:	a8 0e       	add	r10, r24
     c50:	b1 1c       	adc	r11, r1
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
     c52:	48 01       	movw	r8, r16
     c54:	e2 e2       	ldi	r30, 0x22	; 34
     c56:	8e 0e       	add	r8, r30
     c58:	91 1c       	adc	r9, r1
			                                                                              sizeof(IP_Header_t)];
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
     c5a:	86 e1       	ldi	r24, 0x16	; 22
     c5c:	92 e0       	ldi	r25, 0x02	; 2
     c5e:	28 9f       	mul	r18, r24
     c60:	70 01       	movw	r14, r0
     c62:	29 9f       	mul	r18, r25
     c64:	f0 0c       	add	r15, r0
     c66:	38 9f       	mul	r19, r24
     c68:	f0 0c       	add	r15, r0
     c6a:	11 24       	eor	r1, r1
     c6c:	e7 01       	movw	r28, r14
     c6e:	c5 50       	subi	r28, 0x05	; 5
     c70:	d2 4f       	sbci	r29, 0xF2	; 242
     c72:	c8 88       	ldd	r12, Y+16	; 0x10
     c74:	d9 88       	ldd	r13, Y+17	; 0x11

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
     c76:	88 81       	ld	r24, Y
     c78:	99 81       	ldd	r25, Y+1	; 0x01
     c7a:	f8 01       	movw	r30, r16
     c7c:	93 a3       	std	Z+35, r25	; 0x23
     c7e:	82 a3       	std	Z+34, r24	; 0x22
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
     c80:	8a 81       	ldd	r24, Y+2	; 0x02
     c82:	9b 81       	ldd	r25, Y+3	; 0x03
     c84:	95 a3       	std	Z+37, r25	; 0x25
     c86:	84 a3       	std	Z+36, r24	; 0x24
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
     c88:	8c 85       	ldd	r24, Y+12	; 0x0c
     c8a:	9d 85       	ldd	r25, Y+13	; 0x0d
     c8c:	2e 85       	ldd	r18, Y+14	; 0x0e
     c8e:	3f 85       	ldd	r19, Y+15	; 0x0f
     c90:	36 a3       	std	Z+38, r19	; 0x26
     c92:	27 a3       	std	Z+39, r18	; 0x27
     c94:	90 a7       	std	Z+40, r25	; 0x28
     c96:	81 a7       	std	Z+41, r24	; 0x29
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
     c98:	88 85       	ldd	r24, Y+8	; 0x08
     c9a:	99 85       	ldd	r25, Y+9	; 0x09
     c9c:	2a 85       	ldd	r18, Y+10	; 0x0a
     c9e:	3b 85       	ldd	r19, Y+11	; 0x0b
     ca0:	32 a7       	std	Z+42, r19	; 0x2a
     ca2:	23 a7       	std	Z+43, r18	; 0x2b
     ca4:	94 a7       	std	Z+44, r25	; 0x2c
     ca6:	85 a7       	std	Z+45, r24	; 0x2d
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
     ca8:	82 e0       	ldi	r24, 0x02	; 2
     caa:	90 e0       	ldi	r25, 0x00	; 0
     cac:	91 ab       	std	Z+49, r25	; 0x31
     cae:	80 ab       	std	Z+48, r24	; 0x30

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
     cb0:	80 e1       	ldi	r24, 0x10	; 16
     cb2:	87 a7       	std	Z+47, r24	; 0x2f
			TCPHeaderOUT->UrgentPointer        = 0;
     cb4:	15 aa       	std	Z+53, r1	; 0x35
     cb6:	14 aa       	std	Z+52, r1	; 0x34
			TCPHeaderOUT->Checksum             = 0;
     cb8:	13 aa       	std	Z+51, r1	; 0x33
     cba:	12 aa       	std	Z+50, r1	; 0x32
			TCPHeaderOUT->Reserved             = 0;
     cbc:	80 e5       	ldi	r24, 0x50	; 80
     cbe:	86 a7       	std	Z+46, r24	; 0x2e

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
     cc0:	b7 01       	movw	r22, r14
     cc2:	63 5f       	subi	r22, 0xF3	; 243
     cc4:	71 4f       	sbci	r23, 0xF1	; 241
     cc6:	a6 01       	movw	r20, r12
     cc8:	c8 01       	movw	r24, r16
     cca:	c6 96       	adiw	r24, 0x36	; 54
     ccc:	0e 94 8f 17 	call	0x2f1e	; 0x2f1e <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
     cd0:	8c 85       	ldd	r24, Y+12	; 0x0c
     cd2:	9d 85       	ldd	r25, Y+13	; 0x0d
     cd4:	ae 85       	ldd	r26, Y+14	; 0x0e
     cd6:	bf 85       	ldd	r27, Y+15	; 0x0f
     cd8:	8c 0d       	add	r24, r12
     cda:	9d 1d       	adc	r25, r13
     cdc:	a1 1d       	adc	r26, r1
     cde:	b1 1d       	adc	r27, r1
     ce0:	8c 87       	std	Y+12, r24	; 0x0c
     ce2:	9d 87       	std	Y+13, r25	; 0x0d
     ce4:	ae 87       	std	Y+14, r26	; 0x0e
     ce6:	bf 87       	std	Y+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
			                                                    &ConnectionStateTable[CSTableEntry].RemoteAddress,
     ce8:	a7 01       	movw	r20, r14
     cea:	41 50       	subi	r20, 0x01	; 1
     cec:	52 4f       	sbci	r21, 0xF2	; 242

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &ServerIPAddress,
     cee:	96 01       	movw	r18, r12
     cf0:	2c 5e       	subi	r18, 0xEC	; 236
     cf2:	3f 4f       	sbci	r19, 0xFF	; 255
     cf4:	6e e3       	ldi	r22, 0x3E	; 62
     cf6:	71 e0       	ldi	r23, 0x01	; 1
     cf8:	c4 01       	movw	r24, r8
     cfa:	bc de       	rcall	.-648    	; 0xa74 <TCP_Checksum16>
     cfc:	f8 01       	movw	r30, r16
     cfe:	93 ab       	std	Z+51, r25	; 0x33
     d00:	82 ab       	std	Z+50, r24	; 0x32
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
     d02:	c6 01       	movw	r24, r12
     d04:	88 96       	adiw	r24, 0x28	; 40
     d06:	90 8b       	std	Z+16, r25	; 0x10
     d08:	81 8b       	std	Z+17, r24	; 0x11
			IPHeaderOUT->TypeOfService      = 0;
     d0a:	17 86       	std	Z+15, r1	; 0x0f
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
     d0c:	85 e4       	ldi	r24, 0x45	; 69
     d0e:	86 87       	std	Z+14, r24	; 0x0e
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
     d10:	14 8a       	std	Z+20, r1	; 0x14
     d12:	15 8a       	std	Z+21, r1	; 0x15
			IPHeaderOUT->Identification     = 0;
     d14:	13 8a       	std	Z+19, r1	; 0x13
     d16:	12 8a       	std	Z+18, r1	; 0x12
			IPHeaderOUT->HeaderChecksum     = 0;
     d18:	11 8e       	std	Z+25, r1	; 0x19
     d1a:	10 8e       	std	Z+24, r1	; 0x18
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
     d1c:	86 e0       	ldi	r24, 0x06	; 6
     d1e:	87 8b       	std	Z+23, r24	; 0x17
			IPHeaderOUT->TTL                = DEFAULT_TTL;
     d20:	80 e8       	ldi	r24, 0x80	; 128
     d22:	86 8b       	std	Z+22, r24	; 0x16
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
     d24:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <ServerIPAddress>
     d28:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <ServerIPAddress+0x1>
     d2c:	a0 91 40 01 	lds	r26, 0x0140	; 0x800140 <ServerIPAddress+0x2>
     d30:	b0 91 41 01 	lds	r27, 0x0141	; 0x800141 <ServerIPAddress+0x3>
     d34:	82 8f       	std	Z+26, r24	; 0x1a
     d36:	93 8f       	std	Z+27, r25	; 0x1b
     d38:	a4 8f       	std	Z+28, r26	; 0x1c
     d3a:	b5 8f       	std	Z+29, r27	; 0x1d
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
     d3c:	8c 81       	ldd	r24, Y+4	; 0x04
     d3e:	9d 81       	ldd	r25, Y+5	; 0x05
     d40:	ae 81       	ldd	r26, Y+6	; 0x06
     d42:	bf 81       	ldd	r27, Y+7	; 0x07
     d44:	86 8f       	std	Z+30, r24	; 0x1e
     d46:	97 8f       	std	Z+31, r25	; 0x1f
     d48:	a0 a3       	std	Z+32, r26	; 0x20
     d4a:	b1 a3       	std	Z+33, r27	; 0x21

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
     d4c:	64 e1       	ldi	r22, 0x14	; 20
     d4e:	70 e0       	ldi	r23, 0x00	; 0
     d50:	c5 01       	movw	r24, r10
     d52:	7f dd       	rcall	.-1282   	; 0x852 <Ethernet_Checksum16>
     d54:	f8 01       	movw	r30, r16
     d56:	91 8f       	std	Z+25, r25	; 0x19
     d58:	80 8f       	std	Z+24, r24	; 0x18

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     d5a:	86 e0       	ldi	r24, 0x06	; 6
     d5c:	e2 e4       	ldi	r30, 0x42	; 66
     d5e:	f1 e0       	ldi	r31, 0x01	; 1
     d60:	d8 01       	movw	r26, r16
     d62:	16 96       	adiw	r26, 0x06	; 6
     d64:	01 90       	ld	r0, Z+
     d66:	0d 92       	st	X+, r0
     d68:	8a 95       	dec	r24
     d6a:	e1 f7       	brne	.-8      	; 0xd64 <TCP_TCPTask+0x228>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
     d6c:	86 e0       	ldi	r24, 0x06	; 6
     d6e:	e2 e2       	ldi	r30, 0x22	; 34
     d70:	f1 e0       	ldi	r31, 0x01	; 1
     d72:	d8 01       	movw	r26, r16
     d74:	01 90       	ld	r0, Z+
     d76:	0d 92       	st	X+, r0
     d78:	8a 95       	dec	r24
     d7a:	e1 f7       	brne	.-8      	; 0xd74 <TCP_TCPTask+0x238>
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
     d7c:	88 e0       	ldi	r24, 0x08	; 8
     d7e:	90 e0       	ldi	r25, 0x00	; 0
     d80:	f8 01       	movw	r30, r16
     d82:	95 87       	std	Z+13, r25	; 0x0d
     d84:	84 87       	std	Z+12, r24	; 0x0c

			PacketSize += sizeof(Ethernet_Frame_Header_t);
     d86:	f6 e3       	ldi	r31, 0x36	; 54
     d88:	cf 0e       	add	r12, r31
     d8a:	d1 1c       	adc	r13, r1

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
     d8c:	f8 01       	movw	r30, r16
     d8e:	e4 52       	subi	r30, 0x24	; 36
     d90:	fa 4f       	sbci	r31, 0xFA	; 250
     d92:	d1 82       	std	Z+1, r13	; 0x01
     d94:	c0 82       	st	Z, r12

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
     d96:	cd 5e       	subi	r28, 0xED	; 237
     d98:	dd 4f       	sbci	r29, 0xFD	; 253
     d9a:	18 82       	st	Y, r1

			break;
     d9c:	04 c0       	rjmp	.+8      	; 0xda6 <TCP_TCPTask+0x26a>
	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
	  return;

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     d9e:	8f 5f       	subi	r24, 0xFF	; 255
     da0:	83 30       	cpi	r24, 0x03	; 3
     da2:	08 f4       	brcc	.+2      	; 0xda6 <TCP_TCPTask+0x26a>
     da4:	34 cf       	rjmp	.-408    	; 0xc0e <TCP_TCPTask+0xd2>
			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;

			break;
		}
	}
}
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	1f 91       	pop	r17
     dac:	0f 91       	pop	r16
     dae:	ff 90       	pop	r15
     db0:	ef 90       	pop	r14
     db2:	df 90       	pop	r13
     db4:	cf 90       	pop	r12
     db6:	bf 90       	pop	r11
     db8:	af 90       	pop	r10
     dba:	9f 90       	pop	r9
     dbc:	8f 90       	pop	r8
     dbe:	08 95       	ret

00000dc0 <TCP_Init>:
 *  processed.
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
     dc0:	20 e0       	ldi	r18, 0x00	; 0
     dc2:	0e c0       	rjmp	.+28     	; 0xde0 <TCP_Init+0x20>
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     dc4:	82 2f       	mov	r24, r18
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	fc 01       	movw	r30, r24
     dca:	ee 0f       	add	r30, r30
     dcc:	ff 1f       	adc	r31, r31
     dce:	ee 0f       	add	r30, r30
     dd0:	ff 1f       	adc	r31, r31
     dd2:	8e 0f       	add	r24, r30
     dd4:	9f 1f       	adc	r25, r31
     dd6:	fc 01       	movw	r30, r24
     dd8:	e3 5c       	subi	r30, 0xC3	; 195
     dda:	fb 4e       	sbci	r31, 0xEB	; 235
     ddc:	12 82       	std	Z+2, r1	; 0x02
 *  processed.
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
     dde:	2f 5f       	subi	r18, 0xFF	; 255
     de0:	22 23       	and	r18, r18
     de2:	81 f3       	breq	.-32     	; 0xdc4 <TCP_Init+0x4>
     de4:	80 e0       	ldi	r24, 0x00	; 0
     de6:	0c c0       	rjmp	.+24     	; 0xe00 <TCP_Init+0x40>
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     de8:	26 e1       	ldi	r18, 0x16	; 22
     dea:	32 e0       	ldi	r19, 0x02	; 2
     dec:	82 9f       	mul	r24, r18
     dee:	f0 01       	movw	r30, r0
     df0:	83 9f       	mul	r24, r19
     df2:	f0 0d       	add	r31, r0
     df4:	11 24       	eor	r1, r1
     df6:	e0 5f       	subi	r30, 0xF0	; 240
     df8:	ff 4e       	sbci	r31, 0xEF	; 239
     dfa:	9a e0       	ldi	r25, 0x0A	; 10
     dfc:	90 83       	st	Z, r25
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     dfe:	8f 5f       	subi	r24, 0xFF	; 255
     e00:	83 30       	cpi	r24, 0x03	; 3
     e02:	90 f3       	brcs	.-28     	; 0xde8 <TCP_Init+0x28>
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
}
     e04:	08 95       	ret

00000e06 <TCP_SetPortState>:
 *  \return Boolean \c true if the port state was set, \c false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     e06:	cf 93       	push	r28
     e08:	df 93       	push	r29
     e0a:	dc 01       	movw	r26, r24
     e0c:	ea 01       	movw	r28, r20
	/* Note, Port number should be specified in BIG endian to simplify network code */

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
     e0e:	80 e0       	ldi	r24, 0x00	; 0
     e10:	20 c0       	rjmp	.+64     	; 0xe52 <TCP_SetPortState+0x4c>
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     e12:	28 2f       	mov	r18, r24
     e14:	30 e0       	ldi	r19, 0x00	; 0
     e16:	f9 01       	movw	r30, r18
     e18:	ee 0f       	add	r30, r30
     e1a:	ff 1f       	adc	r31, r31
     e1c:	ee 0f       	add	r30, r30
     e1e:	ff 1f       	adc	r31, r31
     e20:	e2 0f       	add	r30, r18
     e22:	f3 1f       	adc	r31, r19
     e24:	e3 5c       	subi	r30, 0xC3	; 195
     e26:	fb 4e       	sbci	r31, 0xEB	; 235
     e28:	40 81       	ld	r20, Z
     e2a:	51 81       	ldd	r21, Z+1	; 0x01
     e2c:	4a 17       	cp	r20, r26
     e2e:	5b 07       	cpc	r21, r27
     e30:	79 f4       	brne	.+30     	; 0xe50 <TCP_SetPortState+0x4a>
		{
			PortStateTable[PTableEntry].State = State;
     e32:	f9 01       	movw	r30, r18
     e34:	ee 0f       	add	r30, r30
     e36:	ff 1f       	adc	r31, r31
     e38:	ee 0f       	add	r30, r30
     e3a:	ff 1f       	adc	r31, r31
     e3c:	2e 0f       	add	r18, r30
     e3e:	3f 1f       	adc	r19, r31
     e40:	f9 01       	movw	r30, r18
     e42:	e3 5c       	subi	r30, 0xC3	; 195
     e44:	fb 4e       	sbci	r31, 0xEB	; 235
     e46:	62 83       	std	Z+2, r22	; 0x02
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     e48:	d4 83       	std	Z+4, r29	; 0x04
     e4a:	c3 83       	std	Z+3, r28	; 0x03
			return true;
     e4c:	81 e0       	ldi	r24, 0x01	; 1
     e4e:	2c c0       	rjmp	.+88     	; 0xea8 <TCP_SetPortState+0xa2>
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
     e50:	8f 5f       	subi	r24, 0xFF	; 255
     e52:	88 23       	and	r24, r24
     e54:	f1 f2       	breq	.-68     	; 0xe12 <TCP_SetPortState+0xc>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     e56:	61 30       	cpi	r22, 0x01	; 1
     e58:	19 f1       	breq	.+70     	; 0xea0 <TCP_SetPortState+0x9a>
		return false;
	}
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	25 c0       	rjmp	.+74     	; 0xea8 <TCP_SetPortState+0xa2>
	if (State == TCP_Port_Open)
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     e5e:	29 2f       	mov	r18, r25
     e60:	30 e0       	ldi	r19, 0x00	; 0
     e62:	f9 01       	movw	r30, r18
     e64:	ee 0f       	add	r30, r30
     e66:	ff 1f       	adc	r31, r31
     e68:	ee 0f       	add	r30, r30
     e6a:	ff 1f       	adc	r31, r31
     e6c:	e2 0f       	add	r30, r18
     e6e:	f3 1f       	adc	r31, r19
     e70:	e3 5c       	subi	r30, 0xC3	; 195
     e72:	fb 4e       	sbci	r31, 0xEB	; 235
     e74:	52 81       	ldd	r21, Z+2	; 0x02
     e76:	51 11       	cpse	r21, r1
     e78:	11 c0       	rjmp	.+34     	; 0xe9c <TCP_SetPortState+0x96>
			{
				PortStateTable[PTableEntry].Port  = Port;
     e7a:	f9 01       	movw	r30, r18
     e7c:	ee 0f       	add	r30, r30
     e7e:	ff 1f       	adc	r31, r31
     e80:	ee 0f       	add	r30, r30
     e82:	ff 1f       	adc	r31, r31
     e84:	2e 0f       	add	r18, r30
     e86:	3f 1f       	adc	r19, r31
     e88:	f9 01       	movw	r30, r18
     e8a:	e3 5c       	subi	r30, 0xC3	; 195
     e8c:	fb 4e       	sbci	r31, 0xEB	; 235
     e8e:	b1 83       	std	Z+1, r27	; 0x01
     e90:	a0 83       	st	Z, r26
				PortStateTable[PTableEntry].State = State;
     e92:	62 83       	std	Z+2, r22	; 0x02
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     e94:	d4 83       	std	Z+4, r29	; 0x04
     e96:	c3 83       	std	Z+3, r28	; 0x03
				return true;
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	06 c0       	rjmp	.+12     	; 0xea8 <TCP_SetPortState+0xa2>
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
     e9c:	9f 5f       	subi	r25, 0xFF	; 255
     e9e:	01 c0       	rjmp	.+2      	; 0xea2 <TCP_SetPortState+0x9c>
     ea0:	90 e0       	ldi	r25, 0x00	; 0
     ea2:	99 23       	and	r25, r25
     ea4:	e1 f2       	breq	.-72     	; 0xe5e <TCP_SetPortState+0x58>
				return true;
			}
		}

		/* Port not in table and no room to add it, return failure */
		return false;
     ea6:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     ea8:	df 91       	pop	r29
     eaa:	cf 91       	pop	r28
     eac:	08 95       	ret

00000eae <TCP_GetPortState>:
 *  \param[in] Port  TCP port whose state is to be retrieved, given in big-endian
 *
 *  \return A value from the \ref TCP_PortStates_t enum
 */
uint8_t TCP_GetPortState(const uint16_t Port)
{
     eae:	ac 01       	movw	r20, r24
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	1d c0       	rjmp	.+58     	; 0xeee <TCP_GetPortState+0x40>
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     eb4:	29 2f       	mov	r18, r25
     eb6:	30 e0       	ldi	r19, 0x00	; 0
     eb8:	f9 01       	movw	r30, r18
     eba:	ee 0f       	add	r30, r30
     ebc:	ff 1f       	adc	r31, r31
     ebe:	ee 0f       	add	r30, r30
     ec0:	ff 1f       	adc	r31, r31
     ec2:	e2 0f       	add	r30, r18
     ec4:	f3 1f       	adc	r31, r19
     ec6:	e3 5c       	subi	r30, 0xC3	; 195
     ec8:	fb 4e       	sbci	r31, 0xEB	; 235
     eca:	60 81       	ld	r22, Z
     ecc:	71 81       	ldd	r23, Z+1	; 0x01
     ece:	64 17       	cp	r22, r20
     ed0:	75 07       	cpc	r23, r21
     ed2:	61 f4       	brne	.+24     	; 0xeec <TCP_GetPortState+0x3e>
		  return PortStateTable[PTableEntry].State;
     ed4:	f9 01       	movw	r30, r18
     ed6:	ee 0f       	add	r30, r30
     ed8:	ff 1f       	adc	r31, r31
     eda:	ee 0f       	add	r30, r30
     edc:	ff 1f       	adc	r31, r31
     ede:	2e 0f       	add	r18, r30
     ee0:	3f 1f       	adc	r19, r31
     ee2:	f9 01       	movw	r30, r18
     ee4:	e3 5c       	subi	r30, 0xC3	; 195
     ee6:	fb 4e       	sbci	r31, 0xEB	; 235
     ee8:	82 81       	ldd	r24, Z+2	; 0x02
     eea:	08 95       	ret
 */
uint8_t TCP_GetPortState(const uint16_t Port)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
     eec:	9f 5f       	subi	r25, 0xFF	; 255
     eee:	99 23       	and	r25, r25
     ef0:	09 f3       	breq	.-62     	; 0xeb4 <TCP_GetPortState+0x6>
		if (PortStateTable[PTableEntry].Port == Port)
		  return PortStateTable[PTableEntry].State;
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
     ef2:	80 e0       	ldi	r24, 0x00	; 0
}
     ef4:	08 95       	ret

00000ef6 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t* RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     ef6:	af 92       	push	r10
     ef8:	bf 92       	push	r11
     efa:	cf 92       	push	r12
     efc:	df 92       	push	r13
     efe:	ef 92       	push	r14
     f00:	ff 92       	push	r15
     f02:	0f 93       	push	r16
     f04:	1f 93       	push	r17
     f06:	cf 93       	push	r28
     f08:	df 93       	push	r29
     f0a:	5c 01       	movw	r10, r24
     f0c:	7b 01       	movw	r14, r22
     f0e:	6a 01       	movw	r12, r20
     f10:	d2 2f       	mov	r29, r18
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     f12:	c0 e0       	ldi	r28, 0x00	; 0
     f14:	43 c0       	rjmp	.+134    	; 0xf9c <TCP_SetConnectionState+0xa6>
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     f16:	0c 2f       	mov	r16, r28
     f18:	10 e0       	ldi	r17, 0x00	; 0
     f1a:	86 e1       	ldi	r24, 0x16	; 22
     f1c:	92 e0       	ldi	r25, 0x02	; 2
     f1e:	08 9f       	mul	r16, r24
     f20:	f0 01       	movw	r30, r0
     f22:	09 9f       	mul	r16, r25
     f24:	f0 0d       	add	r31, r0
     f26:	18 9f       	mul	r17, r24
     f28:	f0 0d       	add	r31, r0
     f2a:	11 24       	eor	r1, r1
     f2c:	e5 50       	subi	r30, 0x05	; 5
     f2e:	f2 4f       	sbci	r31, 0xF2	; 242
     f30:	80 81       	ld	r24, Z
     f32:	91 81       	ldd	r25, Z+1	; 0x01
     f34:	8a 15       	cp	r24, r10
     f36:	9b 05       	cpc	r25, r11
     f38:	81 f5       	brne	.+96     	; 0xf9a <TCP_SetConnectionState+0xa4>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     f3a:	26 e1       	ldi	r18, 0x16	; 22
     f3c:	32 e0       	ldi	r19, 0x02	; 2
     f3e:	02 9f       	mul	r16, r18
     f40:	c0 01       	movw	r24, r0
     f42:	03 9f       	mul	r16, r19
     f44:	90 0d       	add	r25, r0
     f46:	12 9f       	mul	r17, r18
     f48:	90 0d       	add	r25, r0
     f4a:	11 24       	eor	r1, r1
     f4c:	44 e0       	ldi	r20, 0x04	; 4
     f4e:	50 e0       	ldi	r21, 0x00	; 0
     f50:	b7 01       	movw	r22, r14
     f52:	81 50       	subi	r24, 0x01	; 1
     f54:	92 4f       	sbci	r25, 0xF2	; 242
     f56:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     f5a:	89 2b       	or	r24, r25
     f5c:	f1 f4       	brne	.+60     	; 0xf9a <TCP_SetConnectionState+0xa4>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
     f5e:	86 e1       	ldi	r24, 0x16	; 22
     f60:	92 e0       	ldi	r25, 0x02	; 2
     f62:	08 9f       	mul	r16, r24
     f64:	f0 01       	movw	r30, r0
     f66:	09 9f       	mul	r16, r25
     f68:	f0 0d       	add	r31, r0
     f6a:	18 9f       	mul	r17, r24
     f6c:	f0 0d       	add	r31, r0
     f6e:	11 24       	eor	r1, r1
     f70:	e5 50       	subi	r30, 0x05	; 5
     f72:	f2 4f       	sbci	r31, 0xF2	; 242
     f74:	82 81       	ldd	r24, Z+2	; 0x02
     f76:	93 81       	ldd	r25, Z+3	; 0x03

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
     f78:	8c 15       	cp	r24, r12
     f7a:	9d 05       	cpc	r25, r13
     f7c:	71 f4       	brne	.+28     	; 0xf9a <TCP_SetConnectionState+0xa4>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     f7e:	86 e1       	ldi	r24, 0x16	; 22
     f80:	92 e0       	ldi	r25, 0x02	; 2
     f82:	08 9f       	mul	r16, r24
     f84:	f0 01       	movw	r30, r0
     f86:	09 9f       	mul	r16, r25
     f88:	f0 0d       	add	r31, r0
     f8a:	18 9f       	mul	r17, r24
     f8c:	f0 0d       	add	r31, r0
     f8e:	11 24       	eor	r1, r1
     f90:	e0 5f       	subi	r30, 0xF0	; 240
     f92:	ff 4e       	sbci	r31, 0xEF	; 239
     f94:	d0 83       	st	Z, r29
			return true;
     f96:	81 e0       	ldi	r24, 0x01	; 1
     f98:	37 c0       	rjmp	.+110    	; 0x1008 <__EEPROM_REGION_LENGTH__+0x8>
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     f9a:	cf 5f       	subi	r28, 0xFF	; 255
     f9c:	c3 30       	cpi	r28, 0x03	; 3
     f9e:	08 f4       	brcc	.+2      	; 0xfa2 <TCP_SetConnectionState+0xac>
     fa0:	ba cf       	rjmp	.-140    	; 0xf16 <TCP_SetConnectionState+0x20>
     fa2:	80 e0       	ldi	r24, 0x00	; 0
     fa4:	2e c0       	rjmp	.+92     	; 0x1002 <__EEPROM_REGION_LENGTH__+0x2>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     fa6:	28 2f       	mov	r18, r24
     fa8:	30 e0       	ldi	r19, 0x00	; 0
     faa:	46 e1       	ldi	r20, 0x16	; 22
     fac:	52 e0       	ldi	r21, 0x02	; 2
     fae:	24 9f       	mul	r18, r20
     fb0:	f0 01       	movw	r30, r0
     fb2:	25 9f       	mul	r18, r21
     fb4:	f0 0d       	add	r31, r0
     fb6:	34 9f       	mul	r19, r20
     fb8:	f0 0d       	add	r31, r0
     fba:	11 24       	eor	r1, r1
     fbc:	e0 5f       	subi	r30, 0xF0	; 240
     fbe:	ff 4e       	sbci	r31, 0xEF	; 239
     fc0:	90 81       	ld	r25, Z
     fc2:	9a 30       	cpi	r25, 0x0A	; 10
     fc4:	e9 f4       	brne	.+58     	; 0x1000 <__EEPROM_REGION_LENGTH__>
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     fc6:	86 e1       	ldi	r24, 0x16	; 22
     fc8:	92 e0       	ldi	r25, 0x02	; 2
     fca:	28 9f       	mul	r18, r24
     fcc:	f0 01       	movw	r30, r0
     fce:	29 9f       	mul	r18, r25
     fd0:	f0 0d       	add	r31, r0
     fd2:	38 9f       	mul	r19, r24
     fd4:	f0 0d       	add	r31, r0
     fd6:	11 24       	eor	r1, r1
     fd8:	e5 50       	subi	r30, 0x05	; 5
     fda:	f2 4f       	sbci	r31, 0xF2	; 242
     fdc:	b1 82       	std	Z+1, r11	; 0x01
     fde:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = *RemoteAddress;
     fe0:	d7 01       	movw	r26, r14
     fe2:	4d 91       	ld	r20, X+
     fe4:	5d 91       	ld	r21, X+
     fe6:	6d 91       	ld	r22, X+
     fe8:	7c 91       	ld	r23, X
     fea:	44 83       	std	Z+4, r20	; 0x04
     fec:	55 83       	std	Z+5, r21	; 0x05
     fee:	66 83       	std	Z+6, r22	; 0x06
     ff0:	77 83       	std	Z+7, r23	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     ff2:	d3 82       	std	Z+3, r13	; 0x03
     ff4:	c2 82       	std	Z+2, r12	; 0x02
			ConnectionStateTable[CSTableEntry].State         = State;
     ff6:	eb 5e       	subi	r30, 0xEB	; 235
     ff8:	fd 4f       	sbci	r31, 0xFD	; 253
     ffa:	d0 83       	st	Z, r29
			return true;
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	04 c0       	rjmp	.+8      	; 0x1008 <__EEPROM_REGION_LENGTH__+0x8>
			ConnectionStateTable[CSTableEntry].State = State;
			return true;
		}
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1000:	8f 5f       	subi	r24, 0xFF	; 255
    1002:	83 30       	cpi	r24, 0x03	; 3
    1004:	80 f2       	brcs	.-96     	; 0xfa6 <TCP_SetConnectionState+0xb0>
			ConnectionStateTable[CSTableEntry].State         = State;
			return true;
		}
	}

	return false;
    1006:	80 e0       	ldi	r24, 0x00	; 0
}
    1008:	df 91       	pop	r29
    100a:	cf 91       	pop	r28
    100c:	1f 91       	pop	r17
    100e:	0f 91       	pop	r16
    1010:	ff 90       	pop	r15
    1012:	ef 90       	pop	r14
    1014:	df 90       	pop	r13
    1016:	cf 90       	pop	r12
    1018:	bf 90       	pop	r11
    101a:	af 90       	pop	r10
    101c:	08 95       	ret

0000101e <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
    101e:	af 92       	push	r10
    1020:	bf 92       	push	r11
    1022:	cf 92       	push	r12
    1024:	df 92       	push	r13
    1026:	ef 92       	push	r14
    1028:	ff 92       	push	r15
    102a:	0f 93       	push	r16
    102c:	1f 93       	push	r17
    102e:	cf 93       	push	r28
    1030:	7c 01       	movw	r14, r24
    1032:	6b 01       	movw	r12, r22
    1034:	5a 01       	movw	r10, r20
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1036:	c0 e0       	ldi	r28, 0x00	; 0
    1038:	42 c0       	rjmp	.+132    	; 0x10be <TCP_GetConnectionState+0xa0>
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    103a:	0c 2f       	mov	r16, r28
    103c:	10 e0       	ldi	r17, 0x00	; 0
    103e:	86 e1       	ldi	r24, 0x16	; 22
    1040:	92 e0       	ldi	r25, 0x02	; 2
    1042:	08 9f       	mul	r16, r24
    1044:	f0 01       	movw	r30, r0
    1046:	09 9f       	mul	r16, r25
    1048:	f0 0d       	add	r31, r0
    104a:	18 9f       	mul	r17, r24
    104c:	f0 0d       	add	r31, r0
    104e:	11 24       	eor	r1, r1
    1050:	e5 50       	subi	r30, 0x05	; 5
    1052:	f2 4f       	sbci	r31, 0xF2	; 242
    1054:	80 81       	ld	r24, Z
    1056:	91 81       	ldd	r25, Z+1	; 0x01
    1058:	8e 15       	cp	r24, r14
    105a:	9f 05       	cpc	r25, r15
    105c:	79 f5       	brne	.+94     	; 0x10bc <TCP_GetConnectionState+0x9e>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    105e:	26 e1       	ldi	r18, 0x16	; 22
    1060:	32 e0       	ldi	r19, 0x02	; 2
    1062:	02 9f       	mul	r16, r18
    1064:	c0 01       	movw	r24, r0
    1066:	03 9f       	mul	r16, r19
    1068:	90 0d       	add	r25, r0
    106a:	12 9f       	mul	r17, r18
    106c:	90 0d       	add	r25, r0
    106e:	11 24       	eor	r1, r1
    1070:	44 e0       	ldi	r20, 0x04	; 4
    1072:	50 e0       	ldi	r21, 0x00	; 0
    1074:	b6 01       	movw	r22, r12
    1076:	81 50       	subi	r24, 0x01	; 1
    1078:	92 4f       	sbci	r25, 0xF2	; 242
    107a:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    107e:	89 2b       	or	r24, r25
    1080:	e9 f4       	brne	.+58     	; 0x10bc <TCP_GetConnectionState+0x9e>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
    1082:	86 e1       	ldi	r24, 0x16	; 22
    1084:	92 e0       	ldi	r25, 0x02	; 2
    1086:	08 9f       	mul	r16, r24
    1088:	f0 01       	movw	r30, r0
    108a:	09 9f       	mul	r16, r25
    108c:	f0 0d       	add	r31, r0
    108e:	18 9f       	mul	r17, r24
    1090:	f0 0d       	add	r31, r0
    1092:	11 24       	eor	r1, r1
    1094:	e5 50       	subi	r30, 0x05	; 5
    1096:	f2 4f       	sbci	r31, 0xF2	; 242
    1098:	82 81       	ldd	r24, Z+2	; 0x02
    109a:	93 81       	ldd	r25, Z+3	; 0x03

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    109c:	8a 15       	cp	r24, r10
    109e:	9b 05       	cpc	r25, r11
    10a0:	69 f4       	brne	.+26     	; 0x10bc <TCP_GetConnectionState+0x9e>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
    10a2:	86 e1       	ldi	r24, 0x16	; 22
    10a4:	92 e0       	ldi	r25, 0x02	; 2
    10a6:	08 9f       	mul	r16, r24
    10a8:	f0 01       	movw	r30, r0
    10aa:	09 9f       	mul	r16, r25
    10ac:	f0 0d       	add	r31, r0
    10ae:	18 9f       	mul	r17, r24
    10b0:	f0 0d       	add	r31, r0
    10b2:	11 24       	eor	r1, r1
    10b4:	e0 5f       	subi	r30, 0xF0	; 240
    10b6:	ff 4e       	sbci	r31, 0xEF	; 239
    10b8:	80 81       	ld	r24, Z
    10ba:	05 c0       	rjmp	.+10     	; 0x10c6 <TCP_GetConnectionState+0xa8>
                               const IP_Address_t* RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    10bc:	cf 5f       	subi	r28, 0xFF	; 255
    10be:	c3 30       	cpi	r28, 0x03	; 3
    10c0:	08 f4       	brcc	.+2      	; 0x10c4 <TCP_GetConnectionState+0xa6>
    10c2:	bb cf       	rjmp	.-138    	; 0x103a <TCP_GetConnectionState+0x1c>
		{
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
    10c4:	8a e0       	ldi	r24, 0x0A	; 10
}
    10c6:	cf 91       	pop	r28
    10c8:	1f 91       	pop	r17
    10ca:	0f 91       	pop	r16
    10cc:	ff 90       	pop	r15
    10ce:	ef 90       	pop	r14
    10d0:	df 90       	pop	r13
    10d2:	cf 90       	pop	r12
    10d4:	bf 90       	pop	r11
    10d6:	af 90       	pop	r10
    10d8:	08 95       	ret

000010da <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
    10da:	af 92       	push	r10
    10dc:	bf 92       	push	r11
    10de:	cf 92       	push	r12
    10e0:	df 92       	push	r13
    10e2:	ef 92       	push	r14
    10e4:	ff 92       	push	r15
    10e6:	0f 93       	push	r16
    10e8:	1f 93       	push	r17
    10ea:	cf 93       	push	r28
    10ec:	7c 01       	movw	r14, r24
    10ee:	6b 01       	movw	r12, r22
    10f0:	5a 01       	movw	r10, r20
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    10f2:	c0 e0       	ldi	r28, 0x00	; 0
    10f4:	41 c0       	rjmp	.+130    	; 0x1178 <TCP_GetConnectionInfo+0x9e>
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    10f6:	0c 2f       	mov	r16, r28
    10f8:	10 e0       	ldi	r17, 0x00	; 0
    10fa:	86 e1       	ldi	r24, 0x16	; 22
    10fc:	92 e0       	ldi	r25, 0x02	; 2
    10fe:	08 9f       	mul	r16, r24
    1100:	f0 01       	movw	r30, r0
    1102:	09 9f       	mul	r16, r25
    1104:	f0 0d       	add	r31, r0
    1106:	18 9f       	mul	r17, r24
    1108:	f0 0d       	add	r31, r0
    110a:	11 24       	eor	r1, r1
    110c:	e5 50       	subi	r30, 0x05	; 5
    110e:	f2 4f       	sbci	r31, 0xF2	; 242
    1110:	80 81       	ld	r24, Z
    1112:	91 81       	ldd	r25, Z+1	; 0x01
    1114:	8e 15       	cp	r24, r14
    1116:	9f 05       	cpc	r25, r15
    1118:	71 f5       	brne	.+92     	; 0x1176 <TCP_GetConnectionInfo+0x9c>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    111a:	26 e1       	ldi	r18, 0x16	; 22
    111c:	32 e0       	ldi	r19, 0x02	; 2
    111e:	02 9f       	mul	r16, r18
    1120:	c0 01       	movw	r24, r0
    1122:	03 9f       	mul	r16, r19
    1124:	90 0d       	add	r25, r0
    1126:	12 9f       	mul	r17, r18
    1128:	90 0d       	add	r25, r0
    112a:	11 24       	eor	r1, r1
    112c:	44 e0       	ldi	r20, 0x04	; 4
    112e:	50 e0       	ldi	r21, 0x00	; 0
    1130:	b6 01       	movw	r22, r12
    1132:	81 50       	subi	r24, 0x01	; 1
    1134:	92 4f       	sbci	r25, 0xF2	; 242
    1136:	0e 94 82 17 	call	0x2f04	; 0x2f04 <memcmp>
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
    113a:	89 2b       	or	r24, r25
    113c:	e1 f4       	brne	.+56     	; 0x1176 <TCP_GetConnectionInfo+0x9c>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
    113e:	86 e1       	ldi	r24, 0x16	; 22
    1140:	92 e0       	ldi	r25, 0x02	; 2
    1142:	08 9f       	mul	r16, r24
    1144:	f0 01       	movw	r30, r0
    1146:	09 9f       	mul	r16, r25
    1148:	f0 0d       	add	r31, r0
    114a:	18 9f       	mul	r17, r24
    114c:	f0 0d       	add	r31, r0
    114e:	11 24       	eor	r1, r1
    1150:	e5 50       	subi	r30, 0x05	; 5
    1152:	f2 4f       	sbci	r31, 0xF2	; 242
    1154:	82 81       	ldd	r24, Z+2	; 0x02
    1156:	93 81       	ldd	r25, Z+3	; 0x03

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, RemoteAddress) &&
    1158:	8a 15       	cp	r24, r10
    115a:	9b 05       	cpc	r25, r11
    115c:	61 f4       	brne	.+24     	; 0x1176 <TCP_GetConnectionInfo+0x9c>
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
    115e:	26 e1       	ldi	r18, 0x16	; 22
    1160:	32 e0       	ldi	r19, 0x02	; 2
    1162:	02 9f       	mul	r16, r18
    1164:	c0 01       	movw	r24, r0
    1166:	03 9f       	mul	r16, r19
    1168:	90 0d       	add	r25, r0
    116a:	12 9f       	mul	r17, r18
    116c:	90 0d       	add	r25, r0
    116e:	11 24       	eor	r1, r1
    1170:	8d 5f       	subi	r24, 0xFD	; 253
    1172:	91 4f       	sbci	r25, 0xF1	; 241
    1174:	06 c0       	rjmp	.+12     	; 0x1182 <TCP_GetConnectionInfo+0xa8>
                                            const IP_Address_t* RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1176:	cf 5f       	subi	r28, 0xFF	; 255
    1178:	c3 30       	cpi	r28, 0x03	; 3
    117a:	08 f4       	brcc	.+2      	; 0x117e <TCP_GetConnectionInfo+0xa4>
    117c:	bc cf       	rjmp	.-136    	; 0x10f6 <TCP_GetConnectionInfo+0x1c>
		{
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
    117e:	80 e0       	ldi	r24, 0x00	; 0
    1180:	90 e0       	ldi	r25, 0x00	; 0
}
    1182:	cf 91       	pop	r28
    1184:	1f 91       	pop	r17
    1186:	0f 91       	pop	r16
    1188:	ff 90       	pop	r15
    118a:	ef 90       	pop	r14
    118c:	df 90       	pop	r13
    118e:	cf 90       	pop	r12
    1190:	bf 90       	pop	r11
    1192:	af 90       	pop	r10
    1194:	08 95       	ret

00001196 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
    1196:	7f 92       	push	r7
    1198:	8f 92       	push	r8
    119a:	9f 92       	push	r9
    119c:	af 92       	push	r10
    119e:	bf 92       	push	r11
    11a0:	cf 92       	push	r12
    11a2:	df 92       	push	r13
    11a4:	ef 92       	push	r14
    11a6:	ff 92       	push	r15
    11a8:	0f 93       	push	r16
    11aa:	1f 93       	push	r17
    11ac:	cf 93       	push	r28
    11ae:	df 93       	push	r29
    11b0:	7c 01       	movw	r14, r24
    11b2:	8b 01       	movw	r16, r22
    11b4:	ea 01       	movw	r28, r20
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
    11b6:	cb 01       	movw	r24, r22
    11b8:	5a dc       	rcall	.-1868   	; 0xa6e <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
    11ba:	d8 01       	movw	r26, r16
    11bc:	12 96       	adiw	r26, 0x02	; 2
    11be:	cd 90       	ld	r12, X+
    11c0:	dc 90       	ld	r13, X
    11c2:	13 97       	sbiw	r26, 0x03	; 3
    11c4:	c6 01       	movw	r24, r12
    11c6:	73 de       	rcall	.-794    	; 0xeae <TCP_GetPortState>
    11c8:	81 30       	cpi	r24, 0x01	; 1
    11ca:	09 f0       	breq	.+2      	; 0x11ce <TCP_ProcessTCPPacket+0x38>
    11cc:	ce c1       	rjmp	.+924    	; 0x156a <TCP_ProcessTCPPacket+0x3d4>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
    11ce:	f8 01       	movw	r30, r16
    11d0:	85 85       	ldd	r24, Z+13	; 0x0d
    11d2:	81 ff       	sbrs	r24, 1
    11d4:	08 c0       	rjmp	.+16     	; 0x11e6 <TCP_ProcessTCPPacket+0x50>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
    11d6:	40 81       	ld	r20, Z
    11d8:	51 81       	ldd	r21, Z+1	; 0x01
    11da:	20 e0       	ldi	r18, 0x00	; 0
    11dc:	b7 01       	movw	r22, r14
    11de:	64 5f       	subi	r22, 0xF4	; 244
    11e0:	7f 4f       	sbci	r23, 0xFF	; 255
    11e2:	c6 01       	movw	r24, r12
    11e4:	88 de       	rcall	.-752    	; 0xef6 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
    11e6:	d8 01       	movw	r26, r16
    11e8:	1d 96       	adiw	r26, 0x0d	; 13
    11ea:	7c 90       	ld	r7, X
    11ec:	1d 97       	sbiw	r26, 0x0d	; 13
    11ee:	72 fe       	sbrs	r7, 2
    11f0:	13 c0       	rjmp	.+38     	; 0x1218 <TCP_ProcessTCPPacket+0x82>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    11f2:	4d 91       	ld	r20, X+
    11f4:	5c 91       	ld	r21, X
    11f6:	11 97       	sbiw	r26, 0x01	; 1
    11f8:	2a e0       	ldi	r18, 0x0A	; 10
    11fa:	b7 01       	movw	r22, r14
    11fc:	64 5f       	subi	r22, 0xF4	; 244
    11fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1200:	12 96       	adiw	r26, 0x02	; 2
    1202:	8d 91       	ld	r24, X+
    1204:	9c 91       	ld	r25, X
    1206:	13 97       	sbiw	r26, 0x03	; 3
    1208:	76 de       	rcall	.-788    	; 0xef6 <TCP_SetConnectionState>
    120a:	88 23       	and	r24, r24
    120c:	09 f4       	brne	.+2      	; 0x1210 <TCP_ProcessTCPPacket+0x7a>
    120e:	b1 c1       	rjmp	.+866    	; 0x1572 <TCP_ProcessTCPPacket+0x3dc>
			                           TCPHeaderIN->SourcePort, TCP_Connection_Closed))
			{
				TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1210:	84 e1       	ldi	r24, 0x14	; 20
    1212:	8d 87       	std	Y+13, r24	; 0x0d
				PacketResponse = true;
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	be c1       	rjmp	.+892    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
    1218:	f8 01       	movw	r30, r16
    121a:	80 80       	ld	r8, Z
    121c:	91 80       	ldd	r9, Z+1	; 0x01
    121e:	67 01       	movw	r12, r14
    1220:	fc e0       	ldi	r31, 0x0C	; 12
    1222:	cf 0e       	add	r12, r31
    1224:	d1 1c       	adc	r13, r1
    1226:	d8 01       	movw	r26, r16
    1228:	12 96       	adiw	r26, 0x02	; 2
    122a:	ad 90       	ld	r10, X+
    122c:	bc 90       	ld	r11, X
    122e:	13 97       	sbiw	r26, 0x03	; 3
    1230:	a4 01       	movw	r20, r8
    1232:	b6 01       	movw	r22, r12
    1234:	c5 01       	movw	r24, r10
    1236:	f3 de       	rcall	.-538    	; 0x101e <TCP_GetConnectionState>
    1238:	84 30       	cpi	r24, 0x04	; 4
    123a:	09 f4       	brne	.+2      	; 0x123e <TCP_ProcessTCPPacket+0xa8>
    123c:	2b c1       	rjmp	.+598    	; 0x1494 <TCP_ProcessTCPPacket+0x2fe>
    123e:	40 f4       	brcc	.+16     	; 0x1250 <TCP_ProcessTCPPacket+0xba>
    1240:	82 30       	cpi	r24, 0x02	; 2
    1242:	09 f4       	brne	.+2      	; 0x1246 <TCP_ProcessTCPPacket+0xb0>
    1244:	47 c0       	rjmp	.+142    	; 0x12d4 <TCP_ProcessTCPPacket+0x13e>
    1246:	08 f0       	brcs	.+2      	; 0x124a <TCP_ProcessTCPPacket+0xb4>
    1248:	66 c0       	rjmp	.+204    	; 0x1316 <TCP_ProcessTCPPacket+0x180>
    124a:	88 23       	and	r24, r24
    124c:	51 f0       	breq	.+20     	; 0x1262 <TCP_ProcessTCPPacket+0xcc>
    124e:	93 c1       	rjmp	.+806    	; 0x1576 <TCP_ProcessTCPPacket+0x3e0>
    1250:	86 30       	cpi	r24, 0x06	; 6
    1252:	09 f4       	brne	.+2      	; 0x1256 <TCP_ProcessTCPPacket+0xc0>
    1254:	80 c1       	rjmp	.+768    	; 0x1556 <TCP_ProcessTCPPacket+0x3c0>
    1256:	08 f4       	brcc	.+2      	; 0x125a <TCP_ProcessTCPPacket+0xc4>
    1258:	51 c1       	rjmp	.+674    	; 0x14fc <TCP_ProcessTCPPacket+0x366>
    125a:	87 30       	cpi	r24, 0x07	; 7
    125c:	09 f4       	brne	.+2      	; 0x1260 <TCP_ProcessTCPPacket+0xca>
    125e:	03 c1       	rjmp	.+518    	; 0x1466 <TCP_ProcessTCPPacket+0x2d0>
    1260:	8a c1       	rjmp	.+788    	; 0x1576 <TCP_ProcessTCPPacket+0x3e0>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
    1262:	b2 e0       	ldi	r27, 0x02	; 2
    1264:	7b 12       	cpse	r7, r27
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1266:	89 c1       	rjmp	.+786    	; 0x157a <TCP_ProcessTCPPacket+0x3e4>
    1268:	22 e0       	ldi	r18, 0x02	; 2
    126a:	a4 01       	movw	r20, r8
    126c:	b6 01       	movw	r22, r12
    126e:	c5 01       	movw	r24, r10
    1270:	42 de       	rcall	.-892    	; 0xef6 <TCP_SetConnectionState>
    1272:	88 23       	and	r24, r24
    1274:	59 f1       	breq	.+86     	; 0x12cc <TCP_ProcessTCPPacket+0x136>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
    1276:	82 e1       	ldi	r24, 0x12	; 18
    1278:	8d 87       	std	Y+13, r24	; 0x0d

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
    127a:	f8 01       	movw	r30, r16
    127c:	40 81       	ld	r20, Z
    127e:	51 81       	ldd	r21, Z+1	; 0x01
    1280:	b6 01       	movw	r22, r12
    1282:	82 81       	ldd	r24, Z+2	; 0x02
    1284:	93 81       	ldd	r25, Z+3	; 0x03
    1286:	29 df       	rcall	.-430    	; 0x10da <TCP_GetConnectionInfo>

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
    1288:	d8 01       	movw	r26, r16
    128a:	14 96       	adiw	r26, 0x04	; 4
    128c:	2c 91       	ld	r18, X
    128e:	14 97       	sbiw	r26, 0x04	; 4
    1290:	15 96       	adiw	r26, 0x05	; 5
    1292:	3c 91       	ld	r19, X
    1294:	15 97       	sbiw	r26, 0x05	; 5
    1296:	16 96       	adiw	r26, 0x06	; 6
    1298:	ec 91       	ld	r30, X
    129a:	16 97       	sbiw	r26, 0x06	; 6
    129c:	17 96       	adiw	r26, 0x07	; 7
    129e:	fc 91       	ld	r31, X

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
    12a0:	4f 2f       	mov	r20, r31
    12a2:	5e 2f       	mov	r21, r30
    12a4:	63 2f       	mov	r22, r19
    12a6:	72 2f       	mov	r23, r18
    12a8:	4f 5f       	subi	r20, 0xFF	; 255
    12aa:	5f 4f       	sbci	r21, 0xFF	; 255
    12ac:	6f 4f       	sbci	r22, 0xFF	; 255
    12ae:	7f 4f       	sbci	r23, 0xFF	; 255
    12b0:	fc 01       	movw	r30, r24
    12b2:	40 83       	st	Z, r20
    12b4:	51 83       	std	Z+1, r21	; 0x01
    12b6:	62 83       	std	Z+2, r22	; 0x02
    12b8:	73 83       	std	Z+3, r23	; 0x03
							ConnectionInfo->SequenceNumberOut = 0;
    12ba:	14 82       	std	Z+4, r1	; 0x04
    12bc:	15 82       	std	Z+5, r1	; 0x05
    12be:	16 82       	std	Z+6, r1	; 0x06
    12c0:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
    12c2:	e4 5f       	subi	r30, 0xF4	; 244
    12c4:	fd 4f       	sbci	r31, 0xFD	; 253
    12c6:	10 82       	st	Z, r1
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
						}

						PacketResponse      = true;
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	64 c1       	rjmp	.+712    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
							ConnectionInfo->SequenceNumberOut = 0;
							ConnectionInfo->Buffer.InUse      = false;
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
    12cc:	84 e0       	ldi	r24, 0x04	; 4
    12ce:	8d 87       	std	Y+13, r24	; 0x0d
						}

						PacketResponse      = true;
    12d0:	81 e0       	ldi	r24, 0x01	; 1
    12d2:	60 c1       	rjmp	.+704    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    12d4:	b0 e1       	ldi	r27, 0x10	; 16
    12d6:	7b 12       	cpse	r7, r27
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    12d8:	52 c1       	rjmp	.+676    	; 0x157e <TCP_ProcessTCPPacket+0x3e8>
    12da:	23 e0       	ldi	r18, 0x03	; 3
    12dc:	a4 01       	movw	r20, r8
    12de:	b6 01       	movw	r22, r12
    12e0:	c5 01       	movw	r24, r10
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    12e2:	09 de       	rcall	.-1006   	; 0xef6 <TCP_SetConnectionState>
    12e4:	f8 01       	movw	r30, r16
    12e6:	40 81       	ld	r20, Z
    12e8:	51 81       	ldd	r21, Z+1	; 0x01
    12ea:	b6 01       	movw	r22, r12
    12ec:	82 81       	ldd	r24, Z+2	; 0x02
    12ee:	93 81       	ldd	r25, Z+3	; 0x03
    12f0:	f4 de       	rcall	.-536    	; 0x10da <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
    12f2:	dc 01       	movw	r26, r24
    12f4:	14 96       	adiw	r26, 0x04	; 4
    12f6:	4d 91       	ld	r20, X+
    12f8:	5d 91       	ld	r21, X+
    12fa:	6d 91       	ld	r22, X+
    12fc:	7c 91       	ld	r23, X
    12fe:	17 97       	sbiw	r26, 0x07	; 7
    1300:	4f 5f       	subi	r20, 0xFF	; 255
    1302:	5f 4f       	sbci	r21, 0xFF	; 255
    1304:	6f 4f       	sbci	r22, 0xFF	; 255
    1306:	7f 4f       	sbci	r23, 0xFF	; 255
    1308:	fc 01       	movw	r30, r24
    130a:	44 83       	std	Z+4, r20	; 0x04
    130c:	55 83       	std	Z+5, r21	; 0x05
    130e:	66 83       	std	Z+6, r22	; 0x06
    1310:	77 83       	std	Z+7, r23	; 0x07

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);

	bool PacketResponse = false;
    1312:	80 e0       	ldi	r24, 0x00	; 0
    1314:	3f c1       	rjmp	.+638    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
						ConnectionInfo->SequenceNumberOut++;
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1316:	f1 e1       	ldi	r31, 0x11	; 17
    1318:	7f 12       	cpse	r7, r31
    131a:	2d c0       	rjmp	.+90     	; 0x1376 <TCP_ProcessTCPPacket+0x1e0>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
    131c:	81 e1       	ldi	r24, 0x11	; 17
    131e:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1320:	d8 01       	movw	r26, r16
    1322:	4d 91       	ld	r20, X+
    1324:	5c 91       	ld	r21, X
    1326:	11 97       	sbiw	r26, 0x01	; 1
    1328:	26 e0       	ldi	r18, 0x06	; 6
    132a:	b6 01       	movw	r22, r12
    132c:	12 96       	adiw	r26, 0x02	; 2
    132e:	8d 91       	ld	r24, X+
    1330:	9c 91       	ld	r25, X
    1332:	13 97       	sbiw	r26, 0x03	; 3
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1334:	e0 dd       	rcall	.-1088   	; 0xef6 <TCP_SetConnectionState>
    1336:	f8 01       	movw	r30, r16
    1338:	40 81       	ld	r20, Z
    133a:	51 81       	ldd	r21, Z+1	; 0x01
    133c:	b6 01       	movw	r22, r12
    133e:	82 81       	ldd	r24, Z+2	; 0x02
    1340:	93 81       	ldd	r25, Z+3	; 0x03
    1342:	cb de       	rcall	.-618    	; 0x10da <TCP_GetConnectionInfo>
    1344:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
    1346:	80 81       	ld	r24, Z
    1348:	91 81       	ldd	r25, Z+1	; 0x01
    134a:	a2 81       	ldd	r26, Z+2	; 0x02
    134c:	b3 81       	ldd	r27, Z+3	; 0x03
    134e:	01 96       	adiw	r24, 0x01	; 1
    1350:	a1 1d       	adc	r26, r1
    1352:	b1 1d       	adc	r27, r1
    1354:	80 83       	st	Z, r24
    1356:	91 83       	std	Z+1, r25	; 0x01
    1358:	a2 83       	std	Z+2, r26	; 0x02
    135a:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    135c:	84 81       	ldd	r24, Z+4	; 0x04
    135e:	95 81       	ldd	r25, Z+5	; 0x05
    1360:	a6 81       	ldd	r26, Z+6	; 0x06
    1362:	b7 81       	ldd	r27, Z+7	; 0x07
    1364:	01 96       	adiw	r24, 0x01	; 1
    1366:	a1 1d       	adc	r26, r1
    1368:	b1 1d       	adc	r27, r1
    136a:	84 83       	std	Z+4, r24	; 0x04
    136c:	95 83       	std	Z+5, r25	; 0x05
    136e:	a6 83       	std	Z+6, r26	; 0x06
    1370:	b7 83       	std	Z+7, r27	; 0x07
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
						PacketResponse      = true;
    1372:	81 e0       	ldi	r24, 0x01	; 1
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
						ConnectionInfo->SequenceNumberOut++;
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
    1374:	0f c1       	rjmp	.+542    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    1376:	f0 e1       	ldi	r31, 0x10	; 16
    1378:	7f 16       	cp	r7, r31
    137a:	19 f0       	breq	.+6      	; 0x1382 <TCP_ProcessTCPPacket+0x1ec>
    137c:	28 e1       	ldi	r18, 0x18	; 24
    137e:	72 12       	cpse	r7, r18
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1380:	00 c1       	rjmp	.+512    	; 0x1582 <TCP_ProcessTCPPacket+0x3ec>
    1382:	a4 01       	movw	r20, r8
    1384:	b6 01       	movw	r22, r12
    1386:	c5 01       	movw	r24, r10
    1388:	a8 de       	rcall	.-688    	; 0x10da <TCP_GetConnectionInfo>
    138a:	6c 01       	movw	r12, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
    138c:	fc 01       	movw	r30, r24
    138e:	e4 5f       	subi	r30, 0xF4	; 244
    1390:	fd 4f       	sbci	r31, 0xFD	; 253
    1392:	80 81       	ld	r24, Z
    1394:	81 11       	cpse	r24, r1
    1396:	0e c0       	rjmp	.+28     	; 0x13b4 <TCP_ProcessTCPPacket+0x21e>
    1398:	31 97       	sbiw	r30, 0x01	; 1
    139a:	80 81       	ld	r24, Z
    139c:	81 11       	cpse	r24, r1
    139e:	0a c0       	rjmp	.+20     	; 0x13b4 <TCP_ProcessTCPPacket+0x21e>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	10 82       	st	Z, r1
							ConnectionInfo->Buffer.InUse     = true;
    13a4:	81 e0       	ldi	r24, 0x01	; 1
    13a6:	32 96       	adiw	r30, 0x02	; 2
    13a8:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
    13aa:	d6 01       	movw	r26, r12
    13ac:	19 96       	adiw	r26, 0x09	; 9
    13ae:	1c 92       	st	X, r1
    13b0:	1e 92       	st	-X, r1
    13b2:	18 97       	sbiw	r26, 0x08	; 8
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    13b4:	f6 01       	movw	r30, r12
    13b6:	e6 5f       	subi	r30, 0xF6	; 246
    13b8:	fd 4f       	sbci	r31, 0xFD	; 253
    13ba:	80 81       	ld	r24, Z
    13bc:	81 11       	cpse	r24, r1
    13be:	3f c1       	rjmp	.+638    	; 0x163e <TCP_ProcessTCPPacket+0x4a8>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
    13c0:	f6 01       	movw	r30, r12
    13c2:	80 85       	ldd	r24, Z+8	; 0x08
    13c4:	91 85       	ldd	r25, Z+9	; 0x09
							ConnectionInfo->Buffer.InUse     = true;
							ConnectionInfo->Buffer.Length    = 0;
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    13c6:	81 15       	cp	r24, r1
    13c8:	f2 e0       	ldi	r31, 0x02	; 2
    13ca:	9f 07       	cpc	r25, r31
    13cc:	09 f4       	brne	.+2      	; 0x13d0 <TCP_ProcessTCPPacket+0x23a>
    13ce:	3a c1       	rjmp	.+628    	; 0x1644 <TCP_ProcessTCPPacket+0x4ae>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    13d0:	d7 01       	movw	r26, r14
    13d2:	2c 91       	ld	r18, X
    13d4:	2f 70       	andi	r18, 0x0F	; 15
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	22 0f       	add	r18, r18
    13da:	33 1f       	adc	r19, r19
    13dc:	22 0f       	add	r18, r18
    13de:	33 1f       	adc	r19, r19
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    13e0:	f8 01       	movw	r30, r16
    13e2:	64 85       	ldd	r22, Z+12	; 0x0c
    13e4:	62 95       	swap	r22
    13e6:	6f 70       	andi	r22, 0x0F	; 15
    13e8:	70 e0       	ldi	r23, 0x00	; 0
    13ea:	66 0f       	add	r22, r22
    13ec:	77 1f       	adc	r23, r23
    13ee:	66 0f       	add	r22, r22
    13f0:	77 1f       	adc	r23, r23
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    13f2:	12 96       	adiw	r26, 0x02	; 2
    13f4:	4c 91       	ld	r20, X
    13f6:	12 97       	sbiw	r26, 0x02	; 2
    13f8:	13 96       	adiw	r26, 0x03	; 3
    13fa:	5c 91       	ld	r21, X

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    13fc:	a5 2e       	mov	r10, r21
    13fe:	b4 2e       	mov	r11, r20
    1400:	a2 1a       	sub	r10, r18
    1402:	b3 0a       	sbc	r11, r19
    1404:	a6 1a       	sub	r10, r22
    1406:	b7 0a       	sbc	r11, r23

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    1408:	0a 96       	adiw	r24, 0x0a	; 10
    140a:	60 0f       	add	r22, r16
    140c:	71 1f       	adc	r23, r17
    140e:	a5 01       	movw	r20, r10
    1410:	8c 0d       	add	r24, r12
    1412:	9d 1d       	adc	r25, r13
    1414:	0e 94 8f 17 	call	0x2f1e	; 0x2f1e <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    1418:	f6 01       	movw	r30, r12
    141a:	80 81       	ld	r24, Z
    141c:	91 81       	ldd	r25, Z+1	; 0x01
    141e:	a2 81       	ldd	r26, Z+2	; 0x02
    1420:	b3 81       	ldd	r27, Z+3	; 0x03
    1422:	8a 0d       	add	r24, r10
    1424:	9b 1d       	adc	r25, r11
    1426:	a1 1d       	adc	r26, r1
    1428:	b1 1d       	adc	r27, r1
    142a:	80 83       	st	Z, r24
    142c:	91 83       	std	Z+1, r25	; 0x01
    142e:	a2 83       	std	Z+2, r26	; 0x02
    1430:	b3 83       	std	Z+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    1432:	80 85       	ldd	r24, Z+8	; 0x08
    1434:	91 85       	ldd	r25, Z+9	; 0x09
    1436:	a8 0e       	add	r10, r24
    1438:	b9 1e       	adc	r11, r25
    143a:	b1 86       	std	Z+9, r11	; 0x09
    143c:	a0 86       	std	Z+8, r10	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    143e:	a1 14       	cp	r10, r1
    1440:	f2 e0       	ldi	r31, 0x02	; 2
    1442:	bf 06       	cpc	r11, r31
    1444:	29 f0       	breq	.+10     	; 0x1450 <TCP_ProcessTCPPacket+0x2ba>
    1446:	d8 01       	movw	r26, r16
    1448:	1d 96       	adiw	r26, 0x0d	; 13
    144a:	8c 91       	ld	r24, X
    144c:	83 ff       	sbrs	r24, 3
    144e:	9b c0       	rjmp	.+310    	; 0x1586 <TCP_ProcessTCPPacket+0x3f0>
							{
								ConnectionInfo->Buffer.InUse = false;
    1450:	f6 01       	movw	r30, r12
    1452:	e4 5f       	subi	r30, 0xF4	; 244
    1454:	fd 4f       	sbci	r31, 0xFD	; 253
								ConnectionInfo->Buffer.Ready = true;
    1456:	10 82       	st	Z, r1
    1458:	31 97       	sbiw	r30, 0x01	; 1
    145a:	81 e0       	ldi	r24, 0x01	; 1

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    145c:	80 83       	st	Z, r24
    145e:	80 e1       	ldi	r24, 0x10	; 16
								PacketResponse      = true;
    1460:	8d 87       	std	Y+13, r24	; 0x0d
    1462:	81 e0       	ldi	r24, 0x01	; 1
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1464:	97 c0       	rjmp	.+302    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    1466:	a4 01       	movw	r20, r8
    1468:	b6 01       	movw	r22, r12
    146a:	c5 01       	movw	r24, r10
    146c:	36 de       	rcall	.-916    	; 0x10da <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    146e:	21 e1       	ldi	r18, 0x11	; 17
    1470:	2d 87       	std	Y+13, r18	; 0x0d
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    1472:	84 5f       	subi	r24, 0xF4	; 244
    1474:	9d 4f       	sbci	r25, 0xFD	; 253
    1476:	fc 01       	movw	r30, r24

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1478:	10 82       	st	Z, r1
    147a:	d8 01       	movw	r26, r16
    147c:	4d 91       	ld	r20, X+
    147e:	5c 91       	ld	r21, X
    1480:	11 97       	sbiw	r26, 0x01	; 1
    1482:	24 e0       	ldi	r18, 0x04	; 4
    1484:	b6 01       	movw	r22, r12
    1486:	12 96       	adiw	r26, 0x02	; 2
    1488:	8d 91       	ld	r24, X+
    148a:	9c 91       	ld	r25, X
    148c:	13 97       	sbiw	r26, 0x03	; 3
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
						PacketResponse      = true;
    148e:	33 dd       	rcall	.-1434   	; 0xef6 <TCP_SetConnectionState>
						ConnectionInfo->Buffer.InUse = false;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
    1490:	81 e0       	ldi	r24, 0x01	; 1
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1492:	80 c0       	rjmp	.+256    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    1494:	b1 e1       	ldi	r27, 0x11	; 17
    1496:	7b 12       	cpse	r7, r27
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1498:	27 c0       	rjmp	.+78     	; 0x14e8 <TCP_ProcessTCPPacket+0x352>
    149a:	a4 01       	movw	r20, r8
    149c:	b6 01       	movw	r22, r12
    149e:	c5 01       	movw	r24, r10
    14a0:	1c de       	rcall	.-968    	; 0x10da <TCP_GetConnectionInfo>
    14a2:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    14a4:	80 e1       	ldi	r24, 0x10	; 16
    14a6:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    14a8:	80 81       	ld	r24, Z
    14aa:	91 81       	ldd	r25, Z+1	; 0x01
    14ac:	a2 81       	ldd	r26, Z+2	; 0x02
    14ae:	b3 81       	ldd	r27, Z+3	; 0x03
    14b0:	01 96       	adiw	r24, 0x01	; 1
    14b2:	a1 1d       	adc	r26, r1
    14b4:	b1 1d       	adc	r27, r1
    14b6:	80 83       	st	Z, r24
    14b8:	91 83       	std	Z+1, r25	; 0x01
    14ba:	a2 83       	std	Z+2, r26	; 0x02
    14bc:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    14be:	84 81       	ldd	r24, Z+4	; 0x04
    14c0:	95 81       	ldd	r25, Z+5	; 0x05
    14c2:	a6 81       	ldd	r26, Z+6	; 0x06
    14c4:	b7 81       	ldd	r27, Z+7	; 0x07
    14c6:	01 96       	adiw	r24, 0x01	; 1
    14c8:	a1 1d       	adc	r26, r1
    14ca:	b1 1d       	adc	r27, r1
    14cc:	84 83       	std	Z+4, r24	; 0x04
    14ce:	95 83       	std	Z+5, r25	; 0x05
    14d0:	a6 83       	std	Z+6, r26	; 0x06

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    14d2:	b7 83       	std	Z+7, r27	; 0x07
    14d4:	f8 01       	movw	r30, r16
    14d6:	40 81       	ld	r20, Z
    14d8:	51 81       	ldd	r21, Z+1	; 0x01
    14da:	2a e0       	ldi	r18, 0x0A	; 10
    14dc:	b6 01       	movw	r22, r12
    14de:	82 81       	ldd	r24, Z+2	; 0x02
    14e0:	93 81       	ldd	r25, Z+3	; 0x03
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
						PacketResponse      = true;
    14e2:	09 dd       	rcall	.-1518   	; 0xef6 <TCP_SetConnectionState>
    14e4:	81 e0       	ldi	r24, 0x01	; 1
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    14e6:	56 c0       	rjmp	.+172    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    14e8:	f0 e1       	ldi	r31, 0x10	; 16
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    14ea:	7f 12       	cpse	r7, r31
    14ec:	4e c0       	rjmp	.+156    	; 0x158a <TCP_ProcessTCPPacket+0x3f4>
    14ee:	25 e0       	ldi	r18, 0x05	; 5
    14f0:	a4 01       	movw	r20, r8
    14f2:	b6 01       	movw	r22, r12
    14f4:	c5 01       	movw	r24, r10

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);

	bool PacketResponse = false;
    14f6:	ff dc       	rcall	.-1538   	; 0xef6 <TCP_SetConnectionState>
    14f8:	80 e0       	ldi	r24, 0x00	; 0
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    14fa:	4c c0       	rjmp	.+152    	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    14fc:	21 e1       	ldi	r18, 0x11	; 17
    14fe:	72 12       	cpse	r7, r18
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1500:	46 c0       	rjmp	.+140    	; 0x158e <TCP_ProcessTCPPacket+0x3f8>
    1502:	a4 01       	movw	r20, r8
    1504:	b6 01       	movw	r22, r12
    1506:	c5 01       	movw	r24, r10
    1508:	e8 dd       	rcall	.-1072   	; 0x10da <TCP_GetConnectionInfo>
    150a:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    150c:	80 e1       	ldi	r24, 0x10	; 16
    150e:	8d 87       	std	Y+13, r24	; 0x0d
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1510:	80 81       	ld	r24, Z
    1512:	91 81       	ldd	r25, Z+1	; 0x01
    1514:	a2 81       	ldd	r26, Z+2	; 0x02
    1516:	b3 81       	ldd	r27, Z+3	; 0x03
    1518:	01 96       	adiw	r24, 0x01	; 1
    151a:	a1 1d       	adc	r26, r1
    151c:	b1 1d       	adc	r27, r1
    151e:	80 83       	st	Z, r24
    1520:	91 83       	std	Z+1, r25	; 0x01
    1522:	a2 83       	std	Z+2, r26	; 0x02
    1524:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    1526:	84 81       	ldd	r24, Z+4	; 0x04
    1528:	95 81       	ldd	r25, Z+5	; 0x05
    152a:	a6 81       	ldd	r26, Z+6	; 0x06
    152c:	b7 81       	ldd	r27, Z+7	; 0x07
    152e:	01 96       	adiw	r24, 0x01	; 1
    1530:	a1 1d       	adc	r26, r1
    1532:	b1 1d       	adc	r27, r1
    1534:	84 83       	std	Z+4, r24	; 0x04
    1536:	95 83       	std	Z+5, r25	; 0x05
    1538:	a6 83       	std	Z+6, r26	; 0x06

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    153a:	b7 83       	std	Z+7, r27	; 0x07
    153c:	d8 01       	movw	r26, r16
    153e:	4d 91       	ld	r20, X+
    1540:	5c 91       	ld	r21, X
    1542:	11 97       	sbiw	r26, 0x01	; 1
    1544:	2a e0       	ldi	r18, 0x0A	; 10
    1546:	b6 01       	movw	r22, r12
    1548:	12 96       	adiw	r26, 0x02	; 2
    154a:	8d 91       	ld	r24, X+
    154c:	9c 91       	ld	r25, X
    154e:	13 97       	sbiw	r26, 0x03	; 3
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
						PacketResponse      = true;
    1550:	d2 dc       	rcall	.-1628   	; 0xef6 <TCP_SetConnectionState>
    1552:	81 e0       	ldi	r24, 0x01	; 1
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1554:	1f c0       	rjmp	.+62     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    1556:	b0 e1       	ldi	r27, 0x10	; 16
    1558:	7b 12       	cpse	r7, r27
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    155a:	1b c0       	rjmp	.+54     	; 0x1592 <TCP_ProcessTCPPacket+0x3fc>
    155c:	2a e0       	ldi	r18, 0x0A	; 10
    155e:	a4 01       	movw	r20, r8
    1560:	b6 01       	movw	r22, r12
    1562:	c5 01       	movw	r24, r10
    1564:	c8 dc       	rcall	.-1648   	; 0xef6 <TCP_SetConnectionState>

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);

	bool PacketResponse = false;
    1566:	80 e0       	ldi	r24, 0x00	; 0
    1568:	15 c0       	rjmp	.+42     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    156a:	84 e1       	ldi	r24, 0x14	; 20
    156c:	8d 87       	std	Y+13, r24	; 0x0d
		PacketResponse      = true;
    156e:	81 e0       	ldi	r24, 0x01	; 1
    1570:	11 c0       	rjmp	.+34     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);

	bool PacketResponse = false;
    1572:	80 e0       	ldi	r24, 0x00	; 0
    1574:	0f c0       	rjmp	.+30     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    1576:	80 e0       	ldi	r24, 0x00	; 0
    1578:	0d c0       	rjmp	.+26     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    157a:	80 e0       	ldi	r24, 0x00	; 0
    157c:	0b c0       	rjmp	.+22     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    157e:	80 e0       	ldi	r24, 0x00	; 0
    1580:	09 c0       	rjmp	.+18     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    1582:	80 e0       	ldi	r24, 0x00	; 0
    1584:	07 c0       	rjmp	.+14     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    1586:	80 e0       	ldi	r24, 0x00	; 0
    1588:	05 c0       	rjmp	.+10     	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    158a:	80 e0       	ldi	r24, 0x00	; 0
    158c:	03 c0       	rjmp	.+6      	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
    158e:	80 e0       	ldi	r24, 0x00	; 0
    1590:	01 c0       	rjmp	.+2      	; 0x1594 <TCP_ProcessTCPPacket+0x3fe>
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
		PacketResponse      = true;
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	88 23       	and	r24, r24
    1596:	09 f4       	brne	.+2      	; 0x159a <TCP_ProcessTCPPacket+0x404>
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, &IPHeaderIN->SourceAddress,
    1598:	58 c0       	rjmp	.+176    	; 0x164a <TCP_ProcessTCPPacket+0x4b4>
    159a:	f8 01       	movw	r30, r16
    159c:	40 81       	ld	r20, Z
    159e:	51 81       	ldd	r21, Z+1	; 0x01
    15a0:	57 01       	movw	r10, r14
    15a2:	fc e0       	ldi	r31, 0x0C	; 12
    15a4:	af 0e       	add	r10, r31
    15a6:	b1 1c       	adc	r11, r1
    15a8:	d8 01       	movw	r26, r16
    15aa:	12 96       	adiw	r26, 0x02	; 2
    15ac:	cd 90       	ld	r12, X+
    15ae:	dc 90       	ld	r13, X
    15b0:	13 97       	sbiw	r26, 0x03	; 3
    15b2:	b5 01       	movw	r22, r10
    15b4:	c6 01       	movw	r24, r12
    15b6:	91 dd       	rcall	.-1246   	; 0x10da <TCP_GetConnectionInfo>
    15b8:	fc 01       	movw	r30, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    15ba:	d9 82       	std	Y+1, r13	; 0x01
    15bc:	c8 82       	st	Y, r12
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    15be:	d8 01       	movw	r26, r16
    15c0:	8d 91       	ld	r24, X+
    15c2:	9c 91       	ld	r25, X
    15c4:	9b 83       	std	Y+3, r25	; 0x03
    15c6:	8a 83       	std	Y+2, r24	; 0x02
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    15c8:	84 81       	ldd	r24, Z+4	; 0x04
    15ca:	95 81       	ldd	r25, Z+5	; 0x05
    15cc:	26 81       	ldd	r18, Z+6	; 0x06
    15ce:	37 81       	ldd	r19, Z+7	; 0x07
    15d0:	3c 83       	std	Y+4, r19	; 0x04
    15d2:	2d 83       	std	Y+5, r18	; 0x05
    15d4:	9e 83       	std	Y+6, r25	; 0x06
    15d6:	8f 83       	std	Y+7, r24	; 0x07
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    15d8:	80 81       	ld	r24, Z
    15da:	91 81       	ldd	r25, Z+1	; 0x01
    15dc:	22 81       	ldd	r18, Z+2	; 0x02
    15de:	33 81       	ldd	r19, Z+3	; 0x03
    15e0:	38 87       	std	Y+8, r19	; 0x08
    15e2:	29 87       	std	Y+9, r18	; 0x09
    15e4:	9a 87       	std	Y+10, r25	; 0x0a
    15e6:	8b 87       	std	Y+11, r24	; 0x0b
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    15e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    15ea:	8f 70       	andi	r24, 0x0F	; 15
    15ec:	80 65       	ori	r24, 0x50	; 80
    15ee:	8c 87       	std	Y+12, r24	; 0x0c

		if (!(ConnectionInfo->Buffer.InUse))
    15f0:	df 01       	movw	r26, r30
    15f2:	a4 5f       	subi	r26, 0xF4	; 244
    15f4:	bd 4f       	sbci	r27, 0xFD	; 253
    15f6:	8c 91       	ld	r24, X
    15f8:	81 11       	cpse	r24, r1
    15fa:	05 c0       	rjmp	.+10     	; 0x1606 <TCP_ProcessTCPPacket+0x470>
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    15fc:	82 e0       	ldi	r24, 0x02	; 2
    15fe:	90 e0       	ldi	r25, 0x00	; 0
    1600:	9f 87       	std	Y+15, r25	; 0x0f
    1602:	8e 87       	std	Y+14, r24	; 0x0e
    1604:	08 c0       	rjmp	.+16     	; 0x1616 <TCP_ProcessTCPPacket+0x480>
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    1606:	20 85       	ldd	r18, Z+8	; 0x08
    1608:	31 85       	ldd	r19, Z+9	; 0x09
    160a:	80 e0       	ldi	r24, 0x00	; 0
    160c:	92 e0       	ldi	r25, 0x02	; 2
    160e:	82 1b       	sub	r24, r18
    1610:	93 0b       	sbc	r25, r19
    1612:	9e 87       	std	Y+14, r25	; 0x0e

		TCPHeaderOUT->UrgentPointer        = 0;
    1614:	8f 87       	std	Y+15, r24	; 0x0f
    1616:	1b 8a       	std	Y+19, r1	; 0x13
		TCPHeaderOUT->Checksum             = 0;
    1618:	1a 8a       	std	Y+18, r1	; 0x12
    161a:	19 8a       	std	Y+17, r1	; 0x11
		TCPHeaderOUT->Reserved             = 0;
    161c:	18 8a       	std	Y+16, r1	; 0x10
    161e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1620:	80 7f       	andi	r24, 0xF0	; 240

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, &IPHeaderIN->DestinationAddress,
    1622:	8c 87       	std	Y+12, r24	; 0x0c
    1624:	b7 01       	movw	r22, r14
    1626:	60 5f       	subi	r22, 0xF0	; 240
    1628:	7f 4f       	sbci	r23, 0xFF	; 255
    162a:	24 e1       	ldi	r18, 0x14	; 20
    162c:	30 e0       	ldi	r19, 0x00	; 0
    162e:	a5 01       	movw	r20, r10
    1630:	ce 01       	movw	r24, r28
    1632:	20 da       	rcall	.-3008   	; 0xa74 <TCP_Checksum16>
    1634:	99 8b       	std	Y+17, r25	; 0x11
    1636:	88 8b       	std	Y+16, r24	; 0x10
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    1638:	84 e1       	ldi	r24, 0x14	; 20
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	08 c0       	rjmp	.+16     	; 0x164e <TCP_ProcessTCPPacket+0x4b8>
							}
						}
						else
						{
							/* Buffer is currently in use by the application, defer processing of the incoming packet */
							return NO_PROCESS;
    163e:	8f ef       	ldi	r24, 0xFF	; 255
    1640:	9f ef       	ldi	r25, 0xFF	; 255
    1642:	05 c0       	rjmp	.+10     	; 0x164e <TCP_ProcessTCPPacket+0x4b8>
    1644:	8f ef       	ldi	r24, 0xFF	; 255
    1646:	9f ef       	ldi	r25, 0xFF	; 255
    1648:	02 c0       	rjmp	.+4      	; 0x164e <TCP_ProcessTCPPacket+0x4b8>
		                                                    &IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
	}

	return NO_RESPONSE;
    164a:	80 e0       	ldi	r24, 0x00	; 0
    164c:	90 e0       	ldi	r25, 0x00	; 0
}
    164e:	df 91       	pop	r29
    1650:	cf 91       	pop	r28
    1652:	1f 91       	pop	r17
    1654:	0f 91       	pop	r16
    1656:	ff 90       	pop	r15
    1658:	ef 90       	pop	r14
    165a:	df 90       	pop	r13
    165c:	cf 90       	pop	r12
    165e:	bf 90       	pop	r11
    1660:	af 90       	pop	r10
    1662:	9f 90       	pop	r9
    1664:	8f 90       	pop	r8
    1666:	7f 90       	pop	r7
    1668:	08 95       	ret

0000166a <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    166a:	ef 92       	push	r14
    166c:	ff 92       	push	r15
    166e:	0f 93       	push	r16
    1670:	1f 93       	push	r17
    1672:	cf 93       	push	r28
    1674:	df 93       	push	r29
    1676:	7c 01       	movw	r14, r24
    1678:	eb 01       	movw	r28, r22
    167a:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    167c:	cb 01       	movw	r24, r22
    167e:	f8 d9       	rcall	.-3088   	; 0xa70 <DecodeUDPHeader>

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    1680:	2a 81       	ldd	r18, Y+2	; 0x02
    1682:	3b 81       	ldd	r19, Y+3	; 0x03
    1684:	83 2f       	mov	r24, r19
    1686:	92 2f       	mov	r25, r18
    1688:	83 34       	cpi	r24, 0x43	; 67
    168a:	91 05       	cpc	r25, r1
    168c:	59 f4       	brne	.+22     	; 0x16a4 <UDP_ProcessUDPPacket+0x3a>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    168e:	a8 01       	movw	r20, r16
    1690:	48 5f       	subi	r20, 0xF8	; 248
    1692:	5f 4f       	sbci	r21, 0xFF	; 255
    1694:	be 01       	movw	r22, r28
    1696:	68 5f       	subi	r22, 0xF8	; 248
    1698:	7f 4f       	sbci	r23, 0xFF	; 255
    169a:	c7 01       	movw	r24, r14
    169c:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <DHCP_ProcessDHCPPacket>
    16a0:	9c 01       	movw	r18, r24
			                                 &((uint8_t*)UDPHeaderInStart)[sizeof(UDP_Header_t)],
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
    16a2:	02 c0       	rjmp	.+4      	; 0x16a8 <UDP_ProcessUDPPacket+0x3e>
                             void* UDPHeaderOutStart)
{
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;
    16a4:	20 e0       	ldi	r18, 0x00	; 0
    16a6:	30 e0       	ldi	r19, 0x00	; 0
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    16a8:	12 16       	cp	r1, r18
    16aa:	13 06       	cpc	r1, r19
    16ac:	94 f4       	brge	.+36     	; 0x16d2 <UDP_ProcessUDPPacket+0x68>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    16ae:	8a 81       	ldd	r24, Y+2	; 0x02
    16b0:	9b 81       	ldd	r25, Y+3	; 0x03
    16b2:	f8 01       	movw	r30, r16
    16b4:	91 83       	std	Z+1, r25	; 0x01
    16b6:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    16b8:	88 81       	ld	r24, Y
    16ba:	99 81       	ldd	r25, Y+1	; 0x01
    16bc:	93 83       	std	Z+3, r25	; 0x03
    16be:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    16c0:	17 82       	std	Z+7, r1	; 0x07
    16c2:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    16c4:	28 5f       	subi	r18, 0xF8	; 248
    16c6:	3f 4f       	sbci	r19, 0xFF	; 255
    16c8:	34 83       	std	Z+4, r19	; 0x04
    16ca:	25 83       	std	Z+5, r18	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    16cc:	82 2f       	mov	r24, r18
    16ce:	93 2f       	mov	r25, r19
    16d0:	02 c0       	rjmp	.+4      	; 0x16d6 <UDP_ProcessUDPPacket+0x6c>
	}

	return NO_RESPONSE;
    16d2:	80 e0       	ldi	r24, 0x00	; 0
    16d4:	90 e0       	ldi	r25, 0x00	; 0
}
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	1f 91       	pop	r17
    16dc:	0f 91       	pop	r16
    16de:	ff 90       	pop	r15
    16e0:	ef 90       	pop	r14
    16e2:	08 95       	ret

000016e4 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    16e4:	fb 01       	movw	r30, r22
    16e6:	01 90       	ld	r0, Z+
    16e8:	00 20       	and	r0, r0
    16ea:	e9 f7       	brne	.-6      	; 0x16e6 <IsHTTPCommand+0x2>
    16ec:	31 97       	sbiw	r30, 0x01	; 1
    16ee:	af 01       	movw	r20, r30
    16f0:	46 1b       	sub	r20, r22
    16f2:	57 0b       	sbc	r21, r23
    16f4:	0e 94 a9 17 	call	0x2f52	; 0x2f52 <strncmp>
    16f8:	21 e0       	ldi	r18, 0x01	; 1
    16fa:	89 2b       	or	r24, r25
    16fc:	09 f0       	breq	.+2      	; 0x1700 <IsHTTPCommand+0x1c>
    16fe:	20 e0       	ldi	r18, 0x00	; 0
}
    1700:	82 2f       	mov	r24, r18
    1702:	08 95       	ret

00001704 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1704:	af 92       	push	r10
    1706:	bf 92       	push	r11
    1708:	cf 92       	push	r12
    170a:	df 92       	push	r13
    170c:	ef 92       	push	r14
    170e:	ff 92       	push	r15
    1710:	0f 93       	push	r16
    1712:	1f 93       	push	r17
    1714:	cf 93       	push	r28
    1716:	df 93       	push	r29
    1718:	7c 01       	movw	r14, r24
    171a:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    171c:	8b 01       	movw	r16, r22
    171e:	0e 5f       	subi	r16, 0xFE	; 254
    1720:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1722:	fb 01       	movw	r30, r22
    1724:	ed 5f       	subi	r30, 0xFD	; 253
    1726:	fd 4f       	sbci	r31, 0xFD	; 253
    1728:	80 81       	ld	r24, Z
    172a:	88 23       	and	r24, r24
    172c:	09 f4       	brne	.+2      	; 0x1730 <Webserver_ApplicationCallback+0x2c>
    172e:	a4 c0       	rjmp	.+328    	; 0x1878 <Webserver_ApplicationCallback+0x174>
    1730:	31 97       	sbiw	r30, 0x01	; 1
    1732:	90 81       	ld	r25, Z
    1734:	91 11       	cpse	r25, r1
    1736:	a0 c0       	rjmp	.+320    	; 0x1878 <Webserver_ApplicationCallback+0x174>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1738:	68 e4       	ldi	r22, 0x48	; 72
    173a:	71 e0       	ldi	r23, 0x01	; 1
    173c:	c8 01       	movw	r24, r16
    173e:	d2 df       	rcall	.-92     	; 0x16e4 <IsHTTPCommand>
    1740:	88 23       	and	r24, r24
    1742:	09 f4       	brne	.+2      	; 0x1746 <Webserver_ApplicationCallback+0x42>
    1744:	3f c0       	rjmp	.+126    	; 0x17c4 <Webserver_ApplicationCallback+0xc0>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1746:	6c e4       	ldi	r22, 0x4C	; 76
    1748:	71 e0       	ldi	r23, 0x01	; 1
    174a:	c8 01       	movw	r24, r16
    174c:	cb df       	rcall	.-106    	; 0x16e4 <IsHTTPCommand>
    174e:	88 23       	and	r24, r24
    1750:	e9 f0       	breq	.+58     	; 0x178c <Webserver_ApplicationCallback+0x88>
			{
				PageBlock = 0;
    1752:	10 92 7e 01 	sts	0x017E, r1	; 0x80017e <__data_end>

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1756:	62 e6       	ldi	r22, 0x62	; 98
    1758:	73 e0       	ldi	r23, 0x03	; 3
    175a:	c8 01       	movw	r24, r16
    175c:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1760:	fe 01       	movw	r30, r28
    1762:	ee 5f       	subi	r30, 0xFE	; 254
    1764:	fd 4f       	sbci	r31, 0xFD	; 253
    1766:	81 e0       	ldi	r24, 0x01	; 1
    1768:	80 83       	st	Z, r24
    176a:	f8 01       	movw	r30, r16
    176c:	01 90       	ld	r0, Z+
    176e:	00 20       	and	r0, r0
    1770:	e9 f7       	brne	.-6      	; 0x176c <Webserver_ApplicationCallback+0x68>
    1772:	31 97       	sbiw	r30, 0x01	; 1
    1774:	e0 1b       	sub	r30, r16
    1776:	f1 0b       	sbc	r31, r17
    1778:	f9 83       	std	Y+1, r31	; 0x01
    177a:	e8 83       	st	Y, r30
    177c:	fe 01       	movw	r30, r28
    177e:	ed 5f       	subi	r30, 0xFD	; 253
    1780:	fd 4f       	sbci	r31, 0xFD	; 253
    1782:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1784:	cc 5f       	subi	r28, 0xFC	; 252
    1786:	dd 4f       	sbci	r29, 0xFD	; 253
    1788:	88 83       	st	Y, r24
    178a:	b5 c0       	rjmp	.+362    	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
			}
			else
			{
				/* Copy the HTTP 404 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    178c:	60 e2       	ldi	r22, 0x20	; 32
    178e:	73 e0       	ldi	r23, 0x03	; 3
    1790:	c8 01       	movw	r24, r16
    1792:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1796:	fe 01       	movw	r30, r28
    1798:	ee 5f       	subi	r30, 0xFE	; 254
    179a:	fd 4f       	sbci	r31, 0xFD	; 253
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	80 83       	st	Z, r24
    17a0:	f8 01       	movw	r30, r16
    17a2:	01 90       	ld	r0, Z+
    17a4:	00 20       	and	r0, r0
    17a6:	e9 f7       	brne	.-6      	; 0x17a2 <Webserver_ApplicationCallback+0x9e>
    17a8:	31 97       	sbiw	r30, 0x01	; 1
    17aa:	e0 1b       	sub	r30, r16
    17ac:	f1 0b       	sbc	r31, r17
    17ae:	f9 83       	std	Y+1, r31	; 0x01
    17b0:	e8 83       	st	Y, r30
    17b2:	cd 5f       	subi	r28, 0xFD	; 253
    17b4:	dd 4f       	sbci	r29, 0xFD	; 253
    17b6:	88 83       	st	Y, r24

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
    17b8:	f7 01       	movw	r30, r14
    17ba:	eb 5e       	subi	r30, 0xEB	; 235
    17bc:	fd 4f       	sbci	r31, 0xFD	; 253
    17be:	87 e0       	ldi	r24, 0x07	; 7
    17c0:	80 83       	st	Z, r24
    17c2:	99 c0       	rjmp	.+306    	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    17c4:	63 e5       	ldi	r22, 0x53	; 83
    17c6:	71 e0       	ldi	r23, 0x01	; 1
    17c8:	c8 01       	movw	r24, r16
    17ca:	8c df       	rcall	.-232    	; 0x16e4 <IsHTTPCommand>
    17cc:	88 23       	and	r24, r24
    17ce:	c9 f1       	breq	.+114    	; 0x1842 <Webserver_ApplicationCallback+0x13e>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    17d0:	68 e5       	ldi	r22, 0x58	; 88
    17d2:	71 e0       	ldi	r23, 0x01	; 1
    17d4:	c8 01       	movw	r24, r16
    17d6:	86 df       	rcall	.-244    	; 0x16e4 <IsHTTPCommand>
    17d8:	88 23       	and	r24, r24
    17da:	b9 f0       	breq	.+46     	; 0x180a <Webserver_ApplicationCallback+0x106>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    17dc:	62 e6       	ldi	r22, 0x62	; 98
    17de:	73 e0       	ldi	r23, 0x03	; 3
    17e0:	c8 01       	movw	r24, r16
    17e2:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    17e6:	fe 01       	movw	r30, r28
    17e8:	ee 5f       	subi	r30, 0xFE	; 254
    17ea:	fd 4f       	sbci	r31, 0xFD	; 253
    17ec:	81 e0       	ldi	r24, 0x01	; 1
    17ee:	80 83       	st	Z, r24
    17f0:	f8 01       	movw	r30, r16
    17f2:	01 90       	ld	r0, Z+
    17f4:	00 20       	and	r0, r0
    17f6:	e9 f7       	brne	.-6      	; 0x17f2 <Webserver_ApplicationCallback+0xee>
    17f8:	31 97       	sbiw	r30, 0x01	; 1
    17fa:	e0 1b       	sub	r30, r16
    17fc:	f1 0b       	sbc	r31, r17
    17fe:	f9 83       	std	Y+1, r31	; 0x01
    1800:	e8 83       	st	Y, r30
    1802:	cd 5f       	subi	r28, 0xFD	; 253
    1804:	dd 4f       	sbci	r29, 0xFD	; 253
    1806:	88 83       	st	Y, r24
    1808:	16 c0       	rjmp	.+44     	; 0x1836 <Webserver_ApplicationCallback+0x132>
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    180a:	60 e2       	ldi	r22, 0x20	; 32
    180c:	73 e0       	ldi	r23, 0x03	; 3
    180e:	c8 01       	movw	r24, r16
    1810:	0e 94 63 17 	call	0x2ec6	; 0x2ec6 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1814:	fe 01       	movw	r30, r28
    1816:	ee 5f       	subi	r30, 0xFE	; 254
    1818:	fd 4f       	sbci	r31, 0xFD	; 253
    181a:	81 e0       	ldi	r24, 0x01	; 1
    181c:	80 83       	st	Z, r24
    181e:	f8 01       	movw	r30, r16
    1820:	01 90       	ld	r0, Z+
    1822:	00 20       	and	r0, r0
    1824:	e9 f7       	brne	.-6      	; 0x1820 <Webserver_ApplicationCallback+0x11c>
    1826:	31 97       	sbiw	r30, 0x01	; 1
    1828:	e0 1b       	sub	r30, r16
    182a:	f1 0b       	sbc	r31, r17
    182c:	f9 83       	std	Y+1, r31	; 0x01
    182e:	e8 83       	st	Y, r30
    1830:	cd 5f       	subi	r28, 0xFD	; 253
    1832:	dd 4f       	sbci	r29, 0xFD	; 253
    1834:	88 83       	st	Y, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1836:	f7 01       	movw	r30, r14
    1838:	eb 5e       	subi	r30, 0xEB	; 235
    183a:	fd 4f       	sbci	r31, 0xFD	; 253
    183c:	87 e0       	ldi	r24, 0x07	; 7
    183e:	80 83       	st	Z, r24
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1840:	5a c0       	rjmp	.+180    	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
    1842:	60 e6       	ldi	r22, 0x60	; 96
    1844:	71 e0       	ldi	r23, 0x01	; 1
    1846:	c8 01       	movw	r24, r16
    1848:	4d df       	rcall	.-358    	; 0x16e4 <IsHTTPCommand>
    184a:	88 23       	and	r24, r24
    184c:	71 f0       	breq	.+28     	; 0x186a <Webserver_ApplicationCallback+0x166>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    184e:	fe 01       	movw	r30, r28
    1850:	ee 5f       	subi	r30, 0xFE	; 254
    1852:	fd 4f       	sbci	r31, 0xFD	; 253
    1854:	81 e0       	ldi	r24, 0x01	; 1
    1856:	80 83       	st	Z, r24
    1858:	cd 5f       	subi	r28, 0xFD	; 253
    185a:	dd 4f       	sbci	r29, 0xFD	; 253
    185c:	88 83       	st	Y, r24

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    185e:	f7 01       	movw	r30, r14
    1860:	eb 5e       	subi	r30, 0xEB	; 235
    1862:	fd 4f       	sbci	r31, 0xFD	; 253
    1864:	87 e0       	ldi	r24, 0x07	; 7
    1866:	80 83       	st	Z, r24
    1868:	46 c0       	rjmp	.+140    	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    186a:	fe 01       	movw	r30, r28
    186c:	ed 5f       	subi	r30, 0xFD	; 253
    186e:	fd 4f       	sbci	r31, 0xFD	; 253
    1870:	10 82       	st	Z, r1
    1872:	19 82       	std	Y+1, r1	; 0x01
    1874:	18 82       	st	Y, r1
    1876:	3f c0       	rjmp	.+126    	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1878:	81 11       	cpse	r24, r1
    187a:	3d c0       	rjmp	.+122    	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
    187c:	fe 01       	movw	r30, r28
    187e:	ec 5f       	subi	r30, 0xFC	; 252
    1880:	fd 4f       	sbci	r31, 0xFD	; 253
    1882:	80 81       	ld	r24, Z
    1884:	88 23       	and	r24, r24
    1886:	b9 f1       	breq	.+110    	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
    1888:	32 97       	sbiw	r30, 0x02	; 2
    188a:	80 81       	ld	r24, Z
    188c:	88 23       	and	r24, r24
    188e:	99 f1       	breq	.+102    	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1890:	c0 90 7e 01 	lds	r12, 0x017E	; 0x80017e <__data_end>
    1894:	20 e8       	ldi	r18, 0x80	; 128
    1896:	c2 9e       	mul	r12, r18
    1898:	c0 01       	movw	r24, r0
    189a:	11 24       	eor	r1, r1
    189c:	9c 01       	movw	r18, r24
    189e:	20 5d       	subi	r18, 0xD0	; 208
    18a0:	3e 4f       	sbci	r19, 0xFE	; 254
    18a2:	69 01       	movw	r12, r18
#else
extern size_t __strlen_P(const char *) __ATTR_CONST__;  /* internal helper function */
__attribute__((__always_inline__)) static __inline__ size_t strlen_P(const char * s);
static __inline__ size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    18a4:	c9 01       	movw	r24, r18
    18a6:	0e 94 6a 17 	call	0x2ed4	; 0x2ed4 <__strlen_P>
    18aa:	5c 01       	movw	r10, r24
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    18ac:	81 38       	cpi	r24, 0x81	; 129
    18ae:	91 05       	cpc	r25, r1
    18b0:	20 f0       	brcs	.+8      	; 0x18ba <Webserver_ApplicationCallback+0x1b6>
    18b2:	68 94       	set
    18b4:	aa 24       	eor	r10, r10
    18b6:	a7 f8       	bld	r10, 7
    18b8:	b1 2c       	mov	r11, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    18ba:	a5 01       	movw	r20, r10
    18bc:	b6 01       	movw	r22, r12
    18be:	c8 01       	movw	r24, r16
    18c0:	0e 94 73 17 	call	0x2ee6	; 0x2ee6 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    18c4:	81 e0       	ldi	r24, 0x01	; 1
    18c6:	fe 01       	movw	r30, r28
    18c8:	ee 5f       	subi	r30, 0xFE	; 254
    18ca:	fd 4f       	sbci	r31, 0xFD	; 253
    18cc:	80 83       	st	Z, r24
    18ce:	b9 82       	std	Y+1, r11	; 0x01
    18d0:	a8 82       	st	Y, r10
    18d2:	31 96       	adiw	r30, 0x01	; 1
    18d4:	80 83       	st	Z, r24

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    18d6:	80 91 7e 01 	lds	r24, 0x017E	; 0x80017e <__data_end>
    18da:	91 e0       	ldi	r25, 0x01	; 1
    18dc:	98 0f       	add	r25, r24
    18de:	90 93 7e 01 	sts	0x017E, r25	; 0x80017e <__data_end>
    18e2:	83 30       	cpi	r24, 0x03	; 3
    18e4:	41 f4       	brne	.+16     	; 0x18f6 <Webserver_ApplicationCallback+0x1f2>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    18e6:	cc 5f       	subi	r28, 0xFC	; 252
    18e8:	dd 4f       	sbci	r29, 0xFD	; 253
    18ea:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    18ec:	f7 01       	movw	r30, r14
    18ee:	eb 5e       	subi	r30, 0xEB	; 235
    18f0:	fd 4f       	sbci	r31, 0xFD	; 253
    18f2:	87 e0       	ldi	r24, 0x07	; 7
    18f4:	80 83       	st	Z, r24
		}
	}
}
    18f6:	df 91       	pop	r29
    18f8:	cf 91       	pop	r28
    18fa:	1f 91       	pop	r17
    18fc:	0f 91       	pop	r16
    18fe:	ff 90       	pop	r15
    1900:	ef 90       	pop	r14
    1902:	df 90       	pop	r13
    1904:	cf 90       	pop	r12
    1906:	bf 90       	pop	r11
    1908:	af 90       	pop	r10
    190a:	08 95       	ret

0000190c <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    190c:	42 e8       	ldi	r20, 0x82	; 130
    190e:	5b e0       	ldi	r21, 0x0B	; 11
    1910:	61 e0       	ldi	r22, 0x01	; 1
    1912:	80 e0       	ldi	r24, 0x00	; 0
    1914:	90 e5       	ldi	r25, 0x50	; 80
    1916:	77 ca       	rjmp	.-2834   	; 0xe06 <TCP_SetPortState>
    1918:	08 95       	ret

0000191a <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
    /* Disable watchdog if enabled by bootloader/fuses */
    MCUSR &= ~(1 << WDRF);
    191a:	84 b7       	in	r24, 0x34	; 52
    191c:	87 7f       	andi	r24, 0xF7	; 247
    191e:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    1920:	0f b6       	in	r0, 0x3f	; 63
    1922:	f8 94       	cli
    1924:	a8 95       	wdr
    1926:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    192a:	88 61       	ori	r24, 0x18	; 24
    192c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1930:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    1934:	0f be       	out	0x3f, r0	; 63
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	80 e8       	ldi	r24, 0x80	; 128
    193a:	0f b6       	in	r0, 0x3f	; 63
    193c:	f8 94       	cli
    193e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    1942:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
    1946:	0f be       	out	0x3f, r0	; 63
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed);
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
    1948:	87 e6       	ldi	r24, 0x67	; 103
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
    1950:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
    1954:	86 e0       	ldi	r24, 0x06	; 6
    1956:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
    195a:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
    195e:	88 e1       	ldi	r24, 0x18	; 24
    1960:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>

				DDRD  |= (1 << 3);
    1964:	8a b1       	in	r24, 0x0a	; 10
    1966:	88 60       	ori	r24, 0x08	; 8
    1968:	8a b9       	out	0x0a, r24	; 10
				PORTD |= (1 << 2);
    196a:	8b b1       	in	r24, 0x0b	; 11
    196c:	84 60       	ori	r24, 0x04	; 4
    196e:	8b b9       	out	0x0b, r24	; 11
    clock_prescale_set(clock_div_1);

    /* Hardware Initialization */
    //LEDs_Init();
    Serial_Init(9600, false);
    USB_Init();
    1970:	fe d7       	rcall	.+4092   	; 0x296e <USB_Init>

    /* Create a stdio stream for the serial port for stdin and stdout */
    Serial_CreateStream(NULL);
    1972:	80 e0       	ldi	r24, 0x00	; 0
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	57 c0       	rjmp	.+174    	; 0x1a26 <Serial_CreateStream>
    1978:	08 95       	ret

0000197a <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
    SetupHardware();
    197a:	cf df       	rcall	.-98     	; 0x191a <SetupHardware>

    TCP_Init();
    197c:	21 da       	rcall	.-3006   	; 0xdc0 <TCP_Init>
    Webserver_Init();
    197e:	c6 df       	rcall	.-116    	; 0x190c <Webserver_Init>
    1980:	78 94       	sei
    //LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
    GlobalInterruptEnable();

    for (;;)
    {
        if (RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface))
    1982:	80 e0       	ldi	r24, 0x00	; 0
    1984:	91 e0       	ldi	r25, 0x01	; 1
    1986:	51 d4       	rcall	.+2210   	; 0x222a <RNDIS_Device_IsPacketReceived>
    1988:	88 23       	and	r24, r24
    198a:	e9 f0       	breq	.+58     	; 0x19c6 <main+0x4c>
    198c:	49 e3       	ldi	r20, 0x39	; 57
        {
            //LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

            RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface, &FrameIN.FrameData,
    198e:	5d e0       	ldi	r21, 0x0D	; 13
    1990:	6d e5       	ldi	r22, 0x5D	; 93
    1992:	77 e0       	ldi	r23, 0x07	; 7
    1994:	80 e0       	ldi	r24, 0x00	; 0
    1996:	91 e0       	ldi	r25, 0x01	; 1
    1998:	5e d4       	rcall	.+2236   	; 0x2256 <RNDIS_Device_ReadPacket>
    199a:	6f e7       	ldi	r22, 0x7F	; 127
                                    &FrameIN.FrameLength);
            Ethernet_ProcessPacket(&FrameIN, &FrameOUT);
    199c:	71 e0       	ldi	r23, 0x01	; 1
    199e:	8d e5       	ldi	r24, 0x5D	; 93
    19a0:	97 e0       	ldi	r25, 0x07	; 7
    19a2:	0e 94 b6 03 	call	0x76c	; 0x76c <Ethernet_ProcessPacket>
    19a6:	40 91 5b 07 	lds	r20, 0x075B	; 0x80075b <FrameOUT+0x5dc>

            if (FrameOUT.FrameLength)
    19aa:	50 91 5c 07 	lds	r21, 0x075C	; 0x80075c <FrameOUT+0x5dd>
    19ae:	41 15       	cp	r20, r1
    19b0:	51 05       	cpc	r21, r1
    19b2:	49 f0       	breq	.+18     	; 0x19c6 <main+0x4c>
            {
                RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface, &FrameOUT.FrameData,
    19b4:	6f e7       	ldi	r22, 0x7F	; 127
    19b6:	71 e0       	ldi	r23, 0x01	; 1
    19b8:	80 e0       	ldi	r24, 0x00	; 0
    19ba:	91 e0       	ldi	r25, 0x01	; 1
    19bc:	a7 d4       	rcall	.+2382   	; 0x230c <RNDIS_Device_SendPacket>
    19be:	10 92 5c 07 	sts	0x075C, r1	; 0x80075c <FrameOUT+0x5dd>
                                        FrameOUT.FrameLength);
                FrameOUT.FrameLength = 0;
    19c2:	10 92 5b 07 	sts	0x075B, r1	; 0x80075b <FrameOUT+0x5dc>
            }

            //LEDs_SetAllLEDs(LEDMASK_USB_READY);
        }

        TCP_TCPTask(&Ethernet_RNDIS_Interface, &FrameOUT);
    19c6:	6f e7       	ldi	r22, 0x7F	; 127
    19c8:	71 e0       	ldi	r23, 0x01	; 1
    19ca:	80 e0       	ldi	r24, 0x00	; 0
    19cc:	91 e0       	ldi	r25, 0x01	; 1
    19ce:	b6 d8       	rcall	.-3732   	; 0xb3c <TCP_TCPTask>

        RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
    19d0:	80 e0       	ldi	r24, 0x00	; 0
    19d2:	91 e0       	ldi	r25, 0x01	; 1
    19d4:	eb d3       	rcall	.+2006   	; 0x21ac <RNDIS_Device_USBTask>
    19d6:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <USB_USBTask>
        USB_USBTask();
    19da:	d3 cf       	rjmp	.-90     	; 0x1982 <main+0x8>

000019dc <EVENT_USB_Device_Connect>:
    }
    19dc:	08 95       	ret

000019de <EVENT_USB_Device_Disconnect>:
    //LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
    19de:	08 95       	ret

000019e0 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
    bool ConfigSuccess = true;

    ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);
    19e0:	80 e0       	ldi	r24, 0x00	; 0
    19e2:	91 e0       	ldi	r25, 0x01	; 1
    19e4:	b3 c3       	rjmp	.+1894   	; 0x214c <RNDIS_Device_ConfigureEndpoints>
    19e6:	08 95       	ret

000019e8 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
    RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
    19e8:	80 e0       	ldi	r24, 0x00	; 0
    19ea:	91 e0       	ldi	r25, 0x01	; 1
    19ec:	43 c3       	rjmp	.+1670   	; 0x2074 <RNDIS_Device_ProcessControlRequest>
    19ee:	08 95       	ret

000019f0 <Serial_putchar>:
{
	uint8_t* CurrByte = (uint8_t*)Buffer;

	while (Length--)
	  Serial_SendByte(*(CurrByte++));
}
    19f0:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
    19f4:	95 ff       	sbrs	r25, 5
    19f6:	fc cf       	rjmp	.-8      	; 0x19f0 <Serial_putchar>
    19f8:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    19fc:	80 e0       	ldi	r24, 0x00	; 0
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	08 95       	ret

00001a02 <Serial_getchar>:
    1a02:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
    1a06:	88 23       	and	r24, r24
    1a08:	5c f4       	brge	.+22     	; 0x1a20 <Serial_getchar+0x1e>
    1a0a:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
    1a0e:	88 23       	and	r24, r24
    1a10:	24 f4       	brge	.+8      	; 0x1a1a <Serial_getchar+0x18>
    1a12:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    1a16:	90 e0       	ldi	r25, 0x00	; 0
    1a18:	08 95       	ret
    1a1a:	8f ef       	ldi	r24, 0xFF	; 255
    1a1c:	9f ef       	ldi	r25, 0xFF	; 255
    1a1e:	08 95       	ret
    1a20:	8e ef       	ldi	r24, 0xFE	; 254
    1a22:	9f ef       	ldi	r25, 0xFF	; 255
    1a24:	08 95       	ret

00001a26 <Serial_CreateStream>:

void Serial_CreateStream(FILE* Stream)
{
    1a26:	fc 01       	movw	r30, r24
	if (!(Stream))
    1a28:	89 2b       	or	r24, r25
    1a2a:	49 f4       	brne	.+18     	; 0x1a3e <Serial_CreateStream+0x18>
	{
		Stream = &USARTSerialStream;
		stdin  = Stream;
    1a2c:	ed e5       	ldi	r30, 0x5D	; 93
    1a2e:	f4 e1       	ldi	r31, 0x14	; 20
    1a30:	82 e4       	ldi	r24, 0x42	; 66
    1a32:	94 e1       	ldi	r25, 0x14	; 20
    1a34:	91 83       	std	Z+1, r25	; 0x01
    1a36:	80 83       	st	Z, r24
		stdout = Stream;
    1a38:	93 83       	std	Z+3, r25	; 0x03
    1a3a:	82 83       	std	Z+2, r24	; 0x02

void Serial_CreateStream(FILE* Stream)
{
	if (!(Stream))
	{
		Stream = &USARTSerialStream;
    1a3c:	fc 01       	movw	r30, r24
		stdin  = Stream;
		stdout = Stream;
	}

	*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
    1a3e:	8e e0       	ldi	r24, 0x0E	; 14
    1a40:	df 01       	movw	r26, r30
    1a42:	1d 92       	st	X+, r1
    1a44:	8a 95       	dec	r24
    1a46:	e9 f7       	brne	.-6      	; 0x1a42 <Serial_CreateStream+0x1c>
    1a48:	83 e0       	ldi	r24, 0x03	; 3
    1a4a:	83 83       	std	Z+3, r24	; 0x03
    1a4c:	88 ef       	ldi	r24, 0xF8	; 248
    1a4e:	9c e0       	ldi	r25, 0x0C	; 12
    1a50:	91 87       	std	Z+9, r25	; 0x09
    1a52:	80 87       	std	Z+8, r24	; 0x08
    1a54:	81 e0       	ldi	r24, 0x01	; 1
    1a56:	9d e0       	ldi	r25, 0x0D	; 13
    1a58:	93 87       	std	Z+11, r25	; 0x0b
    1a5a:	82 87       	std	Z+10, r24	; 0x0a
    1a5c:	08 95       	ret

00001a5e <RNDIS_Device_ProcessNDISSet>:
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    1a5e:	4e 30       	cpi	r20, 0x0E	; 14
    1a60:	e1 e0       	ldi	r30, 0x01	; 1
    1a62:	5e 07       	cpc	r21, r30
    1a64:	6e 07       	cpc	r22, r30
    1a66:	71 05       	cpc	r23, r1
    1a68:	39 f0       	breq	.+14     	; 0x1a78 <RNDIS_Device_ProcessNDISSet+0x1a>
    1a6a:	43 30       	cpi	r20, 0x03	; 3
    1a6c:	51 40       	sbci	r21, 0x01	; 1
    1a6e:	61 40       	sbci	r22, 0x01	; 1
    1a70:	71 40       	sbci	r23, 0x01	; 1
    1a72:	b9 f4       	brne	.+46     	; 0x1aa2 <RNDIS_Device_ProcessNDISSet+0x44>

			return true;
		case OID_802_3_MULTICAST_LIST:
			/* Do nothing - throw away the value from the host as it is unused */

			return true;
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	08 95       	ret
	(void)SetSize;

	switch (OId)
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    1a78:	f9 01       	movw	r30, r18
    1a7a:	40 81       	ld	r20, Z
    1a7c:	51 81       	ldd	r21, Z+1	; 0x01
    1a7e:	62 81       	ldd	r22, Z+2	; 0x02
    1a80:	73 81       	ldd	r23, Z+3	; 0x03
    1a82:	fc 01       	movw	r30, r24
    1a84:	46 8f       	std	Z+30, r20	; 0x1e
    1a86:	57 8f       	std	Z+31, r21	; 0x1f
    1a88:	60 a3       	std	Z+32, r22	; 0x20
    1a8a:	71 a3       	std	Z+33, r23	; 0x21
			RNDISInterfaceInfo->State.CurrRNDISState   = (RNDISInterfaceInfo->State.CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Initialized;
    1a8c:	45 2b       	or	r20, r21
    1a8e:	46 2b       	or	r20, r22
    1a90:	47 2b       	or	r20, r23
    1a92:	11 f0       	breq	.+4      	; 0x1a98 <RNDIS_Device_ProcessNDISSet+0x3a>
    1a94:	22 e0       	ldi	r18, 0x02	; 2
    1a96:	01 c0       	rjmp	.+2      	; 0x1a9a <RNDIS_Device_ProcessNDISSet+0x3c>
    1a98:	21 e0       	ldi	r18, 0x01	; 1
    1a9a:	fc 01       	movw	r30, r24
    1a9c:	25 8f       	std	Z+29, r18	; 0x1d

			return true;
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	08 95       	ret
		case OID_802_3_MULTICAST_LIST:
			/* Do nothing - throw away the value from the host as it is unused */

			return true;
		default:
			return false;
    1aa2:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    1aa4:	08 95       	ret

00001aa6 <RNDIS_Device_ProcessNDISQuery>:
                                          const uint32_t OId,
                                          void* const QueryData,
                                          const uint16_t QuerySize,
                                          void* ResponseData,
                                          uint16_t* const ResponseSize)
{
    1aa6:	cf 92       	push	r12
    1aa8:	df 92       	push	r13
    1aaa:	ef 92       	push	r14
    1aac:	ff 92       	push	r15
    1aae:	cf 93       	push	r28
    1ab0:	df 93       	push	r29
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    1ab2:	4e 30       	cpi	r20, 0x0E	; 14
    1ab4:	21 e0       	ldi	r18, 0x01	; 1
    1ab6:	52 07       	cpc	r21, r18
    1ab8:	62 07       	cpc	r22, r18
    1aba:	71 05       	cpc	r23, r1
    1abc:	09 f4       	brne	.+2      	; 0x1ac0 <RNDIS_Device_ProcessNDISQuery+0x1a>
    1abe:	29 c1       	rjmp	.+594    	; 0x1d12 <RNDIS_Device_ProcessNDISQuery+0x26c>
    1ac0:	08 f0       	brcs	.+2      	; 0x1ac4 <RNDIS_Device_ProcessNDISQuery+0x1e>
    1ac2:	47 c0       	rjmp	.+142    	; 0x1b52 <RNDIS_Device_ProcessNDISQuery+0xac>
    1ac4:	46 30       	cpi	r20, 0x06	; 6
    1ac6:	f1 e0       	ldi	r31, 0x01	; 1
    1ac8:	5f 07       	cpc	r21, r31
    1aca:	6f 07       	cpc	r22, r31
    1acc:	71 05       	cpc	r23, r1
    1ace:	09 f4       	brne	.+2      	; 0x1ad2 <RNDIS_Device_ProcessNDISQuery+0x2c>
    1ad0:	c0 c0       	rjmp	.+384    	; 0x1c52 <RNDIS_Device_ProcessNDISQuery+0x1ac>
    1ad2:	e6 01       	movw	r28, r12
    1ad4:	d7 01       	movw	r26, r14
    1ad6:	47 30       	cpi	r20, 0x07	; 7
    1ad8:	21 e0       	ldi	r18, 0x01	; 1
    1ada:	52 07       	cpc	r21, r18
    1adc:	62 07       	cpc	r22, r18
    1ade:	71 05       	cpc	r23, r1
    1ae0:	b0 f4       	brcc	.+44     	; 0x1b0e <RNDIS_Device_ProcessNDISQuery+0x68>
    1ae2:	42 30       	cpi	r20, 0x02	; 2
    1ae4:	81 e0       	ldi	r24, 0x01	; 1
    1ae6:	58 07       	cpc	r21, r24
    1ae8:	68 07       	cpc	r22, r24
    1aea:	71 05       	cpc	r23, r1
    1aec:	09 f4       	brne	.+2      	; 0x1af0 <RNDIS_Device_ProcessNDISQuery+0x4a>
    1aee:	8c c0       	rjmp	.+280    	; 0x1c08 <RNDIS_Device_ProcessNDISQuery+0x162>
    1af0:	38 f4       	brcc	.+14     	; 0x1b00 <RNDIS_Device_ProcessNDISQuery+0x5a>
    1af2:	41 30       	cpi	r20, 0x01	; 1
    1af4:	51 40       	sbci	r21, 0x01	; 1
    1af6:	61 40       	sbci	r22, 0x01	; 1
    1af8:	71 05       	cpc	r23, r1
    1afa:	09 f4       	brne	.+2      	; 0x1afe <RNDIS_Device_ProcessNDISQuery+0x58>
    1afc:	6c c0       	rjmp	.+216    	; 0x1bd6 <RNDIS_Device_ProcessNDISQuery+0x130>
    1afe:	39 c1       	rjmp	.+626    	; 0x1d72 <RNDIS_Device_ProcessNDISQuery+0x2cc>
    1b00:	45 30       	cpi	r20, 0x05	; 5
    1b02:	51 40       	sbci	r21, 0x01	; 1
    1b04:	61 40       	sbci	r22, 0x01	; 1
    1b06:	71 05       	cpc	r23, r1
    1b08:	08 f4       	brcc	.+2      	; 0x1b0c <RNDIS_Device_ProcessNDISQuery+0x66>
    1b0a:	89 c0       	rjmp	.+274    	; 0x1c1e <RNDIS_Device_ProcessNDISQuery+0x178>
    1b0c:	32 c1       	rjmp	.+612    	; 0x1d72 <RNDIS_Device_ProcessNDISQuery+0x2cc>
    1b0e:	4c 30       	cpi	r20, 0x0C	; 12
    1b10:	e1 e0       	ldi	r30, 0x01	; 1
    1b12:	5e 07       	cpc	r21, r30
    1b14:	6e 07       	cpc	r22, r30
    1b16:	71 05       	cpc	r23, r1
    1b18:	70 f4       	brcc	.+28     	; 0x1b36 <RNDIS_Device_ProcessNDISQuery+0x90>
    1b1a:	4a 30       	cpi	r20, 0x0A	; 10
    1b1c:	f1 e0       	ldi	r31, 0x01	; 1
    1b1e:	5f 07       	cpc	r21, r31
    1b20:	6f 07       	cpc	r22, r31
    1b22:	71 05       	cpc	r23, r1
    1b24:	08 f0       	brcs	.+2      	; 0x1b28 <RNDIS_Device_ProcessNDISQuery+0x82>
    1b26:	95 c0       	rjmp	.+298    	; 0x1c52 <RNDIS_Device_ProcessNDISQuery+0x1ac>
    1b28:	47 30       	cpi	r20, 0x07	; 7
    1b2a:	51 40       	sbci	r21, 0x01	; 1
    1b2c:	61 40       	sbci	r22, 0x01	; 1
    1b2e:	71 05       	cpc	r23, r1
    1b30:	09 f4       	brne	.+2      	; 0x1b34 <RNDIS_Device_ProcessNDISQuery+0x8e>
    1b32:	c2 c0       	rjmp	.+388    	; 0x1cb8 <RNDIS_Device_ProcessNDISQuery+0x212>
    1b34:	1e c1       	rjmp	.+572    	; 0x1d72 <RNDIS_Device_ProcessNDISQuery+0x2cc>
    1b36:	4c 30       	cpi	r20, 0x0C	; 12
    1b38:	e1 e0       	ldi	r30, 0x01	; 1
    1b3a:	5e 07       	cpc	r21, r30
    1b3c:	6e 07       	cpc	r22, r30
    1b3e:	71 05       	cpc	r23, r1
    1b40:	09 f4       	brne	.+2      	; 0x1b44 <RNDIS_Device_ProcessNDISQuery+0x9e>
    1b42:	78 c0       	rjmp	.+240    	; 0x1c34 <RNDIS_Device_ProcessNDISQuery+0x18e>
    1b44:	4d 30       	cpi	r20, 0x0D	; 13
    1b46:	51 40       	sbci	r21, 0x01	; 1
    1b48:	61 40       	sbci	r22, 0x01	; 1
    1b4a:	71 05       	cpc	r23, r1
    1b4c:	09 f4       	brne	.+2      	; 0x1b50 <RNDIS_Device_ProcessNDISQuery+0xaa>
    1b4e:	91 c0       	rjmp	.+290    	; 0x1c72 <RNDIS_Device_ProcessNDISQuery+0x1cc>
    1b50:	10 c1       	rjmp	.+544    	; 0x1d72 <RNDIS_Device_ProcessNDISQuery+0x2cc>
    1b52:	46 30       	cpi	r20, 0x06	; 6
    1b54:	21 e0       	ldi	r18, 0x01	; 1
    1b56:	52 07       	cpc	r21, r18
    1b58:	22 e0       	ldi	r18, 0x02	; 2
    1b5a:	62 07       	cpc	r22, r18
    1b5c:	71 05       	cpc	r23, r1
    1b5e:	e8 f4       	brcc	.+58     	; 0x1b9a <RNDIS_Device_ProcessNDISQuery+0xf4>
    1b60:	41 30       	cpi	r20, 0x01	; 1
    1b62:	e1 e0       	ldi	r30, 0x01	; 1
    1b64:	5e 07       	cpc	r21, r30
    1b66:	e2 e0       	ldi	r30, 0x02	; 2
    1b68:	6e 07       	cpc	r22, r30
    1b6a:	71 05       	cpc	r23, r1
    1b6c:	08 f0       	brcs	.+2      	; 0x1b70 <RNDIS_Device_ProcessNDISQuery+0xca>
    1b6e:	e2 c0       	rjmp	.+452    	; 0x1d34 <RNDIS_Device_ProcessNDISQuery+0x28e>
    1b70:	44 31       	cpi	r20, 0x14	; 20
    1b72:	f1 e0       	ldi	r31, 0x01	; 1
    1b74:	5f 07       	cpc	r21, r31
    1b76:	6f 07       	cpc	r22, r31
    1b78:	71 05       	cpc	r23, r1
    1b7a:	09 f4       	brne	.+2      	; 0x1b7e <RNDIS_Device_ProcessNDISQuery+0xd8>
    1b7c:	91 c0       	rjmp	.+290    	; 0x1ca0 <RNDIS_Device_ProcessNDISQuery+0x1fa>
    1b7e:	42 30       	cpi	r20, 0x02	; 2
    1b80:	22 e0       	ldi	r18, 0x02	; 2
    1b82:	52 07       	cpc	r21, r18
    1b84:	21 e0       	ldi	r18, 0x01	; 1
    1b86:	62 07       	cpc	r22, r18
    1b88:	71 05       	cpc	r23, r1
    1b8a:	91 f1       	breq	.+100    	; 0x1bf0 <RNDIS_Device_ProcessNDISQuery+0x14a>
    1b8c:	41 31       	cpi	r20, 0x11	; 17
    1b8e:	51 40       	sbci	r21, 0x01	; 1
    1b90:	61 40       	sbci	r22, 0x01	; 1
    1b92:	71 05       	cpc	r23, r1
    1b94:	09 f0       	breq	.+2      	; 0x1b98 <RNDIS_Device_ProcessNDISQuery+0xf2>
    1b96:	ed c0       	rjmp	.+474    	; 0x1d72 <RNDIS_Device_ProcessNDISQuery+0x2cc>
    1b98:	d9 c0       	rjmp	.+434    	; 0x1d4c <RNDIS_Device_ProcessNDISQuery+0x2a6>
    1b9a:	44 30       	cpi	r20, 0x04	; 4
    1b9c:	f1 e0       	ldi	r31, 0x01	; 1
    1b9e:	5f 07       	cpc	r21, r31
    1ba0:	6f 07       	cpc	r22, r31
    1ba2:	7f 07       	cpc	r23, r31
    1ba4:	09 f4       	brne	.+2      	; 0x1ba8 <RNDIS_Device_ProcessNDISQuery+0x102>
    1ba6:	a6 c0       	rjmp	.+332    	; 0x1cf4 <RNDIS_Device_ProcessNDISQuery+0x24e>
    1ba8:	58 f4       	brcc	.+22     	; 0x1bc0 <RNDIS_Device_ProcessNDISQuery+0x11a>
    1baa:	41 50       	subi	r20, 0x01	; 1
    1bac:	51 40       	sbci	r21, 0x01	; 1
    1bae:	61 40       	sbci	r22, 0x01	; 1
    1bb0:	71 40       	sbci	r23, 0x01	; 1
    1bb2:	42 30       	cpi	r20, 0x02	; 2
    1bb4:	51 05       	cpc	r21, r1
    1bb6:	61 05       	cpc	r22, r1
    1bb8:	71 05       	cpc	r23, r1
    1bba:	08 f4       	brcc	.+2      	; 0x1bbe <RNDIS_Device_ProcessNDISQuery+0x118>
    1bbc:	8c c0       	rjmp	.+280    	; 0x1cd6 <RNDIS_Device_ProcessNDISQuery+0x230>
    1bbe:	d9 c0       	rjmp	.+434    	; 0x1d72 <RNDIS_Device_ProcessNDISQuery+0x2cc>
    1bc0:	41 50       	subi	r20, 0x01	; 1
    1bc2:	51 40       	sbci	r21, 0x01	; 1
    1bc4:	62 40       	sbci	r22, 0x02	; 2
    1bc6:	71 40       	sbci	r23, 0x01	; 1
    1bc8:	43 30       	cpi	r20, 0x03	; 3
    1bca:	51 05       	cpc	r21, r1
    1bcc:	61 05       	cpc	r22, r1
    1bce:	71 05       	cpc	r23, r1
    1bd0:	08 f4       	brcc	.+2      	; 0x1bd4 <RNDIS_Device_ProcessNDISQuery+0x12e>
    1bd2:	b0 c0       	rjmp	.+352    	; 0x1d34 <RNDIS_Device_ProcessNDISQuery+0x28e>
    1bd4:	ce c0       	rjmp	.+412    	; 0x1d72 <RNDIS_Device_ProcessNDISQuery+0x2cc>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    1bd6:	8c e6       	ldi	r24, 0x6C	; 108
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	99 83       	std	Y+1, r25	; 0x01
    1bdc:	88 83       	st	Y, r24

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    1bde:	4c e6       	ldi	r20, 0x6C	; 108
    1be0:	50 e0       	ldi	r21, 0x00	; 0
    1be2:	66 eb       	ldi	r22, 0xB6	; 182
    1be4:	73 e0       	ldi	r23, 0x03	; 3
    1be6:	c7 01       	movw	r24, r14
    1be8:	0e 94 5a 17 	call	0x2eb4	; 0x2eb4 <memcpy_P>

			return true;
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	c2 c0       	rjmp	.+388    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_PHYSICAL_MEDIUM:
			*ResponseSize = sizeof(uint32_t);
    1bf0:	84 e0       	ldi	r24, 0x04	; 4
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	f6 01       	movw	r30, r12
    1bf6:	91 83       	std	Z+1, r25	; 0x01
    1bf8:	80 83       	st	Z, r24

			/* Indicate that the device is a true ethernet link */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    1bfa:	f7 01       	movw	r30, r14
    1bfc:	10 82       	st	Z, r1
    1bfe:	11 82       	std	Z+1, r1	; 0x01
    1c00:	12 82       	std	Z+2, r1	; 0x02
    1c02:	13 82       	std	Z+3, r1	; 0x03

			return true;
    1c04:	81 e0       	ldi	r24, 0x01	; 1
    1c06:	b6 c0       	rjmp	.+364    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_HARDWARE_STATUS:
			*ResponseSize = sizeof(uint32_t);
    1c08:	84 e0       	ldi	r24, 0x04	; 4
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	99 83       	std	Y+1, r25	; 0x01
    1c0e:	88 83       	st	Y, r24

			*((uint32_t*)ResponseData) = CPU_TO_LE32(NDIS_HardwareStatus_Ready);
    1c10:	1d 92       	st	X+, r1
    1c12:	1d 92       	st	X+, r1
    1c14:	1d 92       	st	X+, r1
    1c16:	1c 92       	st	X, r1
    1c18:	13 97       	sbiw	r26, 0x03	; 3

			return true;
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
    1c1c:	ab c0       	rjmp	.+342    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_MEDIA_SUPPORTED:
		case OID_GEN_MEDIA_IN_USE:
			*ResponseSize = sizeof(uint32_t);
    1c1e:	84 e0       	ldi	r24, 0x04	; 4
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	99 83       	std	Y+1, r25	; 0x01
    1c24:	88 83       	st	Y, r24

			*((uint32_t*)ResponseData) = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    1c26:	1d 92       	st	X+, r1
    1c28:	1d 92       	st	X+, r1
    1c2a:	1d 92       	st	X+, r1
    1c2c:	1c 92       	st	X, r1
    1c2e:	13 97       	sbiw	r26, 0x03	; 3

			return true;
    1c30:	81 e0       	ldi	r24, 0x01	; 1
    1c32:	a0 c0       	rjmp	.+320    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);
    1c34:	84 e0       	ldi	r24, 0x04	; 4
    1c36:	90 e0       	ldi	r25, 0x00	; 0
    1c38:	99 83       	std	Y+1, r25	; 0x01
    1c3a:	88 83       	st	Y, r24

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    1c3c:	4f ef       	ldi	r20, 0xFF	; 255
    1c3e:	5f ef       	ldi	r21, 0xFF	; 255
    1c40:	6f ef       	ldi	r22, 0xFF	; 255
    1c42:	70 e0       	ldi	r23, 0x00	; 0
    1c44:	4d 93       	st	X+, r20
    1c46:	5d 93       	st	X+, r21
    1c48:	6d 93       	st	X+, r22
    1c4a:	7c 93       	st	X, r23
    1c4c:	13 97       	sbiw	r26, 0x03	; 3

			return true;
    1c4e:	81 e0       	ldi	r24, 0x01	; 1
    1c50:	91 c0       	rjmp	.+290    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);
    1c52:	84 e0       	ldi	r24, 0x04	; 4
    1c54:	90 e0       	ldi	r25, 0x00	; 0
    1c56:	f6 01       	movw	r30, r12
    1c58:	91 83       	std	Z+1, r25	; 0x01
    1c5a:	80 83       	st	Z, r24

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    1c5c:	8c ed       	ldi	r24, 0xDC	; 220
    1c5e:	95 e0       	ldi	r25, 0x05	; 5
    1c60:	a0 e0       	ldi	r26, 0x00	; 0
    1c62:	b0 e0       	ldi	r27, 0x00	; 0
    1c64:	f7 01       	movw	r30, r14
    1c66:	80 83       	st	Z, r24
    1c68:	91 83       	std	Z+1, r25	; 0x01
    1c6a:	a2 83       	std	Z+2, r26	; 0x02
    1c6c:	b3 83       	std	Z+3, r27	; 0x03

			return true;
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	81 c0       	rjmp	.+258    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    1c72:	fc 01       	movw	r30, r24
    1c74:	20 89       	ldd	r18, Z+16	; 0x10
    1c76:	31 89       	ldd	r19, Z+17	; 0x11
    1c78:	f9 01       	movw	r30, r18
    1c7a:	01 90       	ld	r0, Z+
    1c7c:	00 20       	and	r0, r0
    1c7e:	e9 f7       	brne	.-6      	; 0x1c7a <RNDIS_Device_ProcessNDISQuery+0x1d4>
    1c80:	31 97       	sbiw	r30, 0x01	; 1
    1c82:	af 01       	movw	r20, r30
    1c84:	42 1b       	sub	r20, r18
    1c86:	53 0b       	sbc	r21, r19
    1c88:	4f 5f       	subi	r20, 0xFF	; 255
    1c8a:	5f 4f       	sbci	r21, 0xFF	; 255
    1c8c:	59 83       	std	Y+1, r21	; 0x01
    1c8e:	48 83       	st	Y, r20

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    1c90:	fc 01       	movw	r30, r24
    1c92:	60 89       	ldd	r22, Z+16	; 0x10
    1c94:	71 89       	ldd	r23, Z+17	; 0x11
    1c96:	c7 01       	movw	r24, r14
    1c98:	0e 94 8f 17 	call	0x2f1e	; 0x2f1e <memcpy>

			return true;
    1c9c:	81 e0       	ldi	r24, 0x01	; 1
    1c9e:	6a c0       	rjmp	.+212    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_MEDIA_CONNECT_STATUS:
			*ResponseSize = sizeof(uint32_t);
    1ca0:	84 e0       	ldi	r24, 0x04	; 4
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	f6 01       	movw	r30, r12
    1ca6:	91 83       	std	Z+1, r25	; 0x01
    1ca8:	80 83       	st	Z, r24

			*((uint32_t*)ResponseData) = CPU_TO_LE32(REMOTE_NDIS_MEDIA_STATE_CONNECTED);
    1caa:	f7 01       	movw	r30, r14
    1cac:	10 82       	st	Z, r1
    1cae:	11 82       	std	Z+1, r1	; 0x01
    1cb0:	12 82       	std	Z+2, r1	; 0x02
    1cb2:	13 82       	std	Z+3, r1	; 0x03

			return true;
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	5e c0       	rjmp	.+188    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);
    1cb8:	84 e0       	ldi	r24, 0x04	; 4
    1cba:	90 e0       	ldi	r25, 0x00	; 0
    1cbc:	99 83       	std	Y+1, r25	; 0x01
    1cbe:	88 83       	st	Y, r24

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    1cc0:	40 ea       	ldi	r20, 0xA0	; 160
    1cc2:	56 e8       	ldi	r21, 0x86	; 134
    1cc4:	61 e0       	ldi	r22, 0x01	; 1
    1cc6:	70 e0       	ldi	r23, 0x00	; 0
    1cc8:	4d 93       	st	X+, r20
    1cca:	5d 93       	st	X+, r21
    1ccc:	6d 93       	st	X+, r22
    1cce:	7c 93       	st	X, r23
    1cd0:	13 97       	sbiw	r26, 0x03	; 3

			return true;
    1cd2:	81 e0       	ldi	r24, 0x01	; 1
    1cd4:	4f c0       	rjmp	.+158    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    1cd6:	26 e0       	ldi	r18, 0x06	; 6
    1cd8:	30 e0       	ldi	r19, 0x00	; 0
    1cda:	f6 01       	movw	r30, r12
    1cdc:	31 83       	std	Z+1, r19	; 0x01
    1cde:	20 83       	st	Z, r18

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    1ce0:	fc 01       	movw	r30, r24
    1ce2:	72 96       	adiw	r30, 0x12	; 18
    1ce4:	96 e0       	ldi	r25, 0x06	; 6
    1ce6:	d7 01       	movw	r26, r14
    1ce8:	01 90       	ld	r0, Z+
    1cea:	0d 92       	st	X+, r0
    1cec:	9a 95       	dec	r25
    1cee:	e1 f7       	brne	.-8      	; 0x1ce8 <RNDIS_Device_ProcessNDISQuery+0x242>

			return true;
    1cf0:	81 e0       	ldi	r24, 0x01	; 1
    1cf2:	40 c0       	rjmp	.+128    	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);
    1cf4:	84 e0       	ldi	r24, 0x04	; 4
    1cf6:	90 e0       	ldi	r25, 0x00	; 0
    1cf8:	f6 01       	movw	r30, r12
    1cfa:	91 83       	std	Z+1, r25	; 0x01
    1cfc:	80 83       	st	Z, r24

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    1cfe:	81 e0       	ldi	r24, 0x01	; 1
    1d00:	90 e0       	ldi	r25, 0x00	; 0
    1d02:	a0 e0       	ldi	r26, 0x00	; 0
    1d04:	b0 e0       	ldi	r27, 0x00	; 0
    1d06:	f7 01       	movw	r30, r14
    1d08:	80 83       	st	Z, r24
    1d0a:	91 83       	std	Z+1, r25	; 0x01
    1d0c:	a2 83       	std	Z+2, r26	; 0x02
    1d0e:	b3 83       	std	Z+3, r27	; 0x03

			return true;
    1d10:	31 c0       	rjmp	.+98     	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);
    1d12:	24 e0       	ldi	r18, 0x04	; 4
    1d14:	30 e0       	ldi	r19, 0x00	; 0
    1d16:	f6 01       	movw	r30, r12
    1d18:	31 83       	std	Z+1, r19	; 0x01
    1d1a:	20 83       	st	Z, r18

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    1d1c:	fc 01       	movw	r30, r24
    1d1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d20:	97 8d       	ldd	r25, Z+31	; 0x1f
    1d22:	a0 a1       	ldd	r26, Z+32	; 0x20
    1d24:	b1 a1       	ldd	r27, Z+33	; 0x21
    1d26:	f7 01       	movw	r30, r14
    1d28:	80 83       	st	Z, r24
    1d2a:	91 83       	std	Z+1, r25	; 0x01
    1d2c:	a2 83       	std	Z+2, r26	; 0x02
    1d2e:	b3 83       	std	Z+3, r27	; 0x03

			return true;
    1d30:	81 e0       	ldi	r24, 0x01	; 1
    1d32:	20 c0       	rjmp	.+64     	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_RCV_ERROR:
		case OID_GEN_RCV_NO_BUFFER:
		case OID_802_3_RCV_ERROR_ALIGNMENT:
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);
    1d34:	84 e0       	ldi	r24, 0x04	; 4
    1d36:	90 e0       	ldi	r25, 0x00	; 0
    1d38:	f6 01       	movw	r30, r12
    1d3a:	91 83       	std	Z+1, r25	; 0x01
    1d3c:	80 83       	st	Z, r24

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    1d3e:	f7 01       	movw	r30, r14
    1d40:	10 82       	st	Z, r1
    1d42:	11 82       	std	Z+1, r1	; 0x01
    1d44:	12 82       	std	Z+2, r1	; 0x02
    1d46:	13 82       	std	Z+3, r1	; 0x03

			return true;
    1d48:	81 e0       	ldi	r24, 0x01	; 1
    1d4a:	14 c0       	rjmp	.+40     	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    1d4c:	24 e0       	ldi	r18, 0x04	; 4
    1d4e:	30 e0       	ldi	r19, 0x00	; 0
    1d50:	f6 01       	movw	r30, r12
    1d52:	31 83       	std	Z+1, r19	; 0x01
    1d54:	20 83       	st	Z, r18

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDISInterfaceInfo->Config.MessageBufferLength + ETHERNET_FRAME_SIZE_MAX);
    1d56:	fc 01       	movw	r30, r24
    1d58:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d5a:	93 8d       	ldd	r25, Z+27	; 0x1b
    1d5c:	84 52       	subi	r24, 0x24	; 36
    1d5e:	9a 4f       	sbci	r25, 0xFA	; 250
    1d60:	a0 e0       	ldi	r26, 0x00	; 0
    1d62:	b0 e0       	ldi	r27, 0x00	; 0
    1d64:	f7 01       	movw	r30, r14
    1d66:	80 83       	st	Z, r24
    1d68:	91 83       	std	Z+1, r25	; 0x01
    1d6a:	a2 83       	std	Z+2, r26	; 0x02
    1d6c:	b3 83       	std	Z+3, r27	; 0x03

			return true;
    1d6e:	81 e0       	ldi	r24, 0x01	; 1
    1d70:	01 c0       	rjmp	.+2      	; 0x1d74 <RNDIS_Device_ProcessNDISQuery+0x2ce>
		default:
			return false;
    1d72:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	ff 90       	pop	r15
    1d7a:	ef 90       	pop	r14
    1d7c:	df 90       	pop	r13
    1d7e:	cf 90       	pop	r12
    1d80:	08 95       	ret

00001d82 <RNDIS_Device_ProcessRNDISControlMessage>:
		RNDISInterfaceInfo->State.ResponseReady = false;
	}
}

void RNDIS_Device_ProcessRNDISControlMessage(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    1d82:	af 92       	push	r10
    1d84:	bf 92       	push	r11
    1d86:	cf 92       	push	r12
    1d88:	df 92       	push	r13
    1d8a:	ef 92       	push	r14
    1d8c:	ff 92       	push	r15
    1d8e:	0f 93       	push	r16
    1d90:	1f 93       	push	r17
    1d92:	cf 93       	push	r28
    1d94:	df 93       	push	r29
    1d96:	00 d0       	rcall	.+0      	; 0x1d98 <RNDIS_Device_ProcessRNDISControlMessage+0x16>
    1d98:	cd b7       	in	r28, 0x3d	; 61
    1d9a:	de b7       	in	r29, 0x3e	; 62
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;
    1d9c:	dc 01       	movw	r26, r24
    1d9e:	58 96       	adiw	r26, 0x18	; 24
    1da0:	ad 90       	ld	r10, X+
    1da2:	bc 90       	ld	r11, X
    1da4:	59 97       	sbiw	r26, 0x19	; 25

	switch (le32_to_cpu(MessageHeader->MessageType))
    1da6:	f5 01       	movw	r30, r10
    1da8:	40 81       	ld	r20, Z
    1daa:	51 81       	ldd	r21, Z+1	; 0x01
    1dac:	62 81       	ldd	r22, Z+2	; 0x02
    1dae:	73 81       	ldd	r23, Z+3	; 0x03
    1db0:	44 30       	cpi	r20, 0x04	; 4
    1db2:	51 05       	cpc	r21, r1
    1db4:	61 05       	cpc	r22, r1
    1db6:	71 05       	cpc	r23, r1
    1db8:	09 f4       	brne	.+2      	; 0x1dbc <RNDIS_Device_ProcessRNDISControlMessage+0x3a>
    1dba:	70 c0       	rjmp	.+224    	; 0x1e9c <RNDIS_Device_ProcessRNDISControlMessage+0x11a>
    1dbc:	60 f4       	brcc	.+24     	; 0x1dd6 <RNDIS_Device_ProcessRNDISControlMessage+0x54>
    1dbe:	42 30       	cpi	r20, 0x02	; 2
    1dc0:	51 05       	cpc	r21, r1
    1dc2:	61 05       	cpc	r22, r1
    1dc4:	71 05       	cpc	r23, r1
    1dc6:	b1 f0       	breq	.+44     	; 0x1df4 <RNDIS_Device_ProcessRNDISControlMessage+0x72>
    1dc8:	43 30       	cpi	r20, 0x03	; 3
    1dca:	51 05       	cpc	r21, r1
    1dcc:	61 05       	cpc	r22, r1
    1dce:	71 05       	cpc	r23, r1
    1dd0:	09 f4       	brne	.+2      	; 0x1dd4 <RNDIS_Device_ProcessRNDISControlMessage+0x52>
    1dd2:	58 c0       	rjmp	.+176    	; 0x1e84 <RNDIS_Device_ProcessRNDISControlMessage+0x102>
    1dd4:	42 c1       	rjmp	.+644    	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
    1dd6:	46 30       	cpi	r20, 0x06	; 6
    1dd8:	51 05       	cpc	r21, r1
    1dda:	61 05       	cpc	r22, r1
    1ddc:	71 05       	cpc	r23, r1
    1dde:	09 f4       	brne	.+2      	; 0x1de2 <RNDIS_Device_ProcessRNDISControlMessage+0x60>
    1de0:	05 c1       	rjmp	.+522    	; 0x1fec <RNDIS_Device_ProcessRNDISControlMessage+0x26a>
    1de2:	08 f4       	brcc	.+2      	; 0x1de6 <RNDIS_Device_ProcessRNDISControlMessage+0x64>
    1de4:	c2 c0       	rjmp	.+388    	; 0x1f6a <RNDIS_Device_ProcessRNDISControlMessage+0x1e8>
    1de6:	48 30       	cpi	r20, 0x08	; 8
    1de8:	51 05       	cpc	r21, r1
    1dea:	61 05       	cpc	r22, r1
    1dec:	71 05       	cpc	r23, r1
    1dee:	09 f4       	brne	.+2      	; 0x1df2 <RNDIS_Device_ProcessRNDISControlMessage+0x70>
    1df0:	1b c1       	rjmp	.+566    	; 0x2028 <__DATA_REGION_LENGTH__+0x28>
    1df2:	33 c1       	rjmp	.+614    	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    1df4:	21 e0       	ldi	r18, 0x01	; 1
    1df6:	dc 01       	movw	r26, r24
    1df8:	5c 96       	adiw	r26, 0x1c	; 28
    1dfa:	2c 93       	st	X, r18
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    1dfc:	42 e0       	ldi	r20, 0x02	; 2
    1dfe:	50 e0       	ldi	r21, 0x00	; 0
    1e00:	60 e0       	ldi	r22, 0x00	; 0
    1e02:	70 e8       	ldi	r23, 0x80	; 128
    1e04:	f5 01       	movw	r30, r10
    1e06:	40 83       	st	Z, r20
    1e08:	51 83       	std	Z+1, r21	; 0x01
    1e0a:	62 83       	std	Z+2, r22	; 0x02
    1e0c:	73 83       	std	Z+3, r23	; 0x03
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    1e0e:	44 e3       	ldi	r20, 0x34	; 52
    1e10:	50 e0       	ldi	r21, 0x00	; 0
    1e12:	60 e0       	ldi	r22, 0x00	; 0
    1e14:	70 e0       	ldi	r23, 0x00	; 0
    1e16:	44 83       	std	Z+4, r20	; 0x04
    1e18:	55 83       	std	Z+5, r21	; 0x05
    1e1a:	66 83       	std	Z+6, r22	; 0x06
    1e1c:	77 83       	std	Z+7, r23	; 0x07
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    1e1e:	14 86       	std	Z+12, r1	; 0x0c
    1e20:	15 86       	std	Z+13, r1	; 0x0d
    1e22:	16 86       	std	Z+14, r1	; 0x0e
    1e24:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    1e26:	41 e0       	ldi	r20, 0x01	; 1
    1e28:	50 e0       	ldi	r21, 0x00	; 0
    1e2a:	60 e0       	ldi	r22, 0x00	; 0
    1e2c:	70 e0       	ldi	r23, 0x00	; 0
    1e2e:	40 8b       	std	Z+16, r20	; 0x10
    1e30:	51 8b       	std	Z+17, r21	; 0x11
    1e32:	62 8b       	std	Z+18, r22	; 0x12
    1e34:	73 8b       	std	Z+19, r23	; 0x13
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    1e36:	14 8a       	std	Z+20, r1	; 0x14
    1e38:	15 8a       	std	Z+21, r1	; 0x15
    1e3a:	16 8a       	std	Z+22, r1	; 0x16
    1e3c:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    1e3e:	40 8f       	std	Z+24, r20	; 0x18
    1e40:	51 8f       	std	Z+25, r21	; 0x19
    1e42:	62 8f       	std	Z+26, r22	; 0x1a
    1e44:	73 8f       	std	Z+27, r23	; 0x1b
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    1e46:	14 8e       	std	Z+28, r1	; 0x1c
    1e48:	15 8e       	std	Z+29, r1	; 0x1d
    1e4a:	16 8e       	std	Z+30, r1	; 0x1e
    1e4c:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    1e4e:	40 a3       	std	Z+32, r20	; 0x20
    1e50:	51 a3       	std	Z+33, r21	; 0x21
    1e52:	62 a3       	std	Z+34, r22	; 0x22
    1e54:	73 a3       	std	Z+35, r23	; 0x23
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    1e56:	48 e0       	ldi	r20, 0x08	; 8
    1e58:	56 e0       	ldi	r21, 0x06	; 6
    1e5a:	60 e0       	ldi	r22, 0x00	; 0
    1e5c:	70 e0       	ldi	r23, 0x00	; 0
    1e5e:	44 a3       	std	Z+36, r20	; 0x24
    1e60:	55 a3       	std	Z+37, r21	; 0x25
    1e62:	66 a3       	std	Z+38, r22	; 0x26
    1e64:	77 a3       	std	Z+39, r23	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    1e66:	10 a6       	std	Z+40, r1	; 0x28
    1e68:	11 a6       	std	Z+41, r1	; 0x29
    1e6a:	12 a6       	std	Z+42, r1	; 0x2a
    1e6c:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    1e6e:	14 a6       	std	Z+44, r1	; 0x2c
    1e70:	15 a6       	std	Z+45, r1	; 0x2d
    1e72:	16 a6       	std	Z+46, r1	; 0x2e
    1e74:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    1e76:	10 aa       	std	Z+48, r1	; 0x30
    1e78:	11 aa       	std	Z+49, r1	; 0x31
    1e7a:	12 aa       	std	Z+50, r1	; 0x32
    1e7c:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    1e7e:	fc 01       	movw	r30, r24
    1e80:	25 8f       	std	Z+29, r18	; 0x1d
			break;
    1e82:	eb c0       	rjmp	.+470    	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    1e84:	dc 01       	movw	r26, r24
    1e86:	5c 96       	adiw	r26, 0x1c	; 28
    1e88:	1c 92       	st	X, r1
    1e8a:	5c 97       	sbiw	r26, 0x1c	; 28

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    1e8c:	f5 01       	movw	r30, r10
    1e8e:	14 82       	std	Z+4, r1	; 0x04
    1e90:	15 82       	std	Z+5, r1	; 0x05
    1e92:	16 82       	std	Z+6, r1	; 0x06
    1e94:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    1e96:	5d 96       	adiw	r26, 0x1d	; 29
    1e98:	1c 92       	st	X, r1
			break;
    1e9a:	df c0       	rjmp	.+446    	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    1e9c:	21 e0       	ldi	r18, 0x01	; 1
    1e9e:	dc 01       	movw	r26, r24
    1ea0:	5c 96       	adiw	r26, 0x1c	; 28
    1ea2:	2c 93       	st	X, r18

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    1ea4:	f5 01       	movw	r30, r10
    1ea6:	44 85       	ldd	r20, Z+12	; 0x0c
    1ea8:	55 85       	ldd	r21, Z+13	; 0x0d
    1eaa:	66 85       	ldd	r22, Z+14	; 0x0e
    1eac:	77 85       	ldd	r23, Z+15	; 0x0f

			void*    QueryData    = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                  le32_to_cpu(QUERY_Message->InformationBufferOffset)];
    1eae:	04 89       	ldd	r16, Z+20	; 0x14
    1eb0:	15 89       	ldd	r17, Z+21	; 0x15
    1eb2:	26 89       	ldd	r18, Z+22	; 0x16
    1eb4:	37 89       	ldd	r19, Z+23	; 0x17

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);

			void*    QueryData    = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
    1eb6:	08 5f       	subi	r16, 0xF8	; 248
    1eb8:	1f 4f       	sbci	r17, 0xFF	; 255
    1eba:	e0 0f       	add	r30, r16
    1ebc:	f1 1f       	adc	r31, r17
			                                                                  le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Query_Complete_t)];
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    1ebe:	c1 2c       	mov	r12, r1
    1ec0:	d1 2c       	mov	r13, r1
    1ec2:	76 01       	movw	r14, r12
    1ec4:	68 94       	set
    1ec6:	c2 f8       	bld	r12, 2
    1ec8:	f7 f8       	bld	r15, 7
    1eca:	d5 01       	movw	r26, r10
    1ecc:	cd 92       	st	X+, r12
    1ece:	dd 92       	st	X+, r13
    1ed0:	ed 92       	st	X+, r14
    1ed2:	fc 92       	st	X, r15
    1ed4:	13 97       	sbiw	r26, 0x03	; 3

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
    1ed6:	50 96       	adiw	r26, 0x10	; 16
    1ed8:	0d 91       	ld	r16, X+
    1eda:	1d 91       	ld	r17, X+
    1edc:	2d 91       	ld	r18, X+
    1ede:	3c 91       	ld	r19, X
    1ee0:	53 97       	sbiw	r26, 0x13	; 19
    1ee2:	de 01       	movw	r26, r28
    1ee4:	11 96       	adiw	r26, 0x01	; 1
    1ee6:	6d 01       	movw	r12, r26
    1ee8:	75 01       	movw	r14, r10
    1eea:	b8 e1       	ldi	r27, 0x18	; 24
    1eec:	eb 0e       	add	r14, r27
    1eee:	f1 1c       	adc	r15, r1
    1ef0:	9f 01       	movw	r18, r30
    1ef2:	d9 dd       	rcall	.-1102   	; 0x1aa6 <RNDIS_Device_ProcessNDISQuery>
    1ef4:	88 23       	and	r24, r24
    1ef6:	f9 f0       	breq	.+62     	; 0x1f36 <RNDIS_Device_ProcessRNDISControlMessage+0x1b4>
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    1ef8:	f5 01       	movw	r30, r10
    1efa:	14 86       	std	Z+12, r1	; 0x0c
    1efc:	15 86       	std	Z+13, r1	; 0x0d
    1efe:	16 86       	std	Z+14, r1	; 0x0e
    1f00:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    1f02:	89 81       	ldd	r24, Y+1	; 0x01
    1f04:	9a 81       	ldd	r25, Y+2	; 0x02
    1f06:	ac 01       	movw	r20, r24
    1f08:	48 5e       	subi	r20, 0xE8	; 232
    1f0a:	5f 4f       	sbci	r21, 0xFF	; 255
    1f0c:	60 e0       	ldi	r22, 0x00	; 0
    1f0e:	70 e0       	ldi	r23, 0x00	; 0
    1f10:	44 83       	std	Z+4, r20	; 0x04
    1f12:	55 83       	std	Z+5, r21	; 0x05
    1f14:	66 83       	std	Z+6, r22	; 0x06
    1f16:	77 83       	std	Z+7, r23	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    1f18:	a0 e0       	ldi	r26, 0x00	; 0
    1f1a:	b0 e0       	ldi	r27, 0x00	; 0
    1f1c:	80 8b       	std	Z+16, r24	; 0x10
    1f1e:	91 8b       	std	Z+17, r25	; 0x11
    1f20:	a2 8b       	std	Z+18, r26	; 0x12
    1f22:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    1f24:	80 e1       	ldi	r24, 0x10	; 16
    1f26:	90 e0       	ldi	r25, 0x00	; 0
    1f28:	a0 e0       	ldi	r26, 0x00	; 0
    1f2a:	b0 e0       	ldi	r27, 0x00	; 0
    1f2c:	84 8b       	std	Z+20, r24	; 0x14
    1f2e:	95 8b       	std	Z+21, r25	; 0x15
    1f30:	a6 8b       	std	Z+22, r26	; 0x16
    1f32:	b7 8b       	std	Z+23, r27	; 0x17
    1f34:	92 c0       	rjmp	.+292    	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    1f36:	8b eb       	ldi	r24, 0xBB	; 187
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	a0 e0       	ldi	r26, 0x00	; 0
    1f3c:	b0 ec       	ldi	r27, 0xC0	; 192
    1f3e:	f5 01       	movw	r30, r10
    1f40:	84 87       	std	Z+12, r24	; 0x0c
    1f42:	95 87       	std	Z+13, r25	; 0x0d
    1f44:	a6 87       	std	Z+14, r26	; 0x0e
    1f46:	b7 87       	std	Z+15, r27	; 0x0f
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    1f48:	88 e1       	ldi	r24, 0x18	; 24
    1f4a:	90 e0       	ldi	r25, 0x00	; 0
    1f4c:	a0 e0       	ldi	r26, 0x00	; 0
    1f4e:	b0 e0       	ldi	r27, 0x00	; 0
    1f50:	84 83       	std	Z+4, r24	; 0x04
    1f52:	95 83       	std	Z+5, r25	; 0x05
    1f54:	a6 83       	std	Z+6, r26	; 0x06
    1f56:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    1f58:	10 8a       	std	Z+16, r1	; 0x10
    1f5a:	11 8a       	std	Z+17, r1	; 0x11
    1f5c:	12 8a       	std	Z+18, r1	; 0x12
    1f5e:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    1f60:	14 8a       	std	Z+20, r1	; 0x14
    1f62:	15 8a       	std	Z+21, r1	; 0x15
    1f64:	16 8a       	std	Z+22, r1	; 0x16
    1f66:	17 8a       	std	Z+23, r1	; 0x17
    1f68:	78 c0       	rjmp	.+240    	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    1f6a:	21 e0       	ldi	r18, 0x01	; 1
    1f6c:	dc 01       	movw	r26, r24
    1f6e:	5c 96       	adiw	r26, 0x1c	; 28
    1f70:	2c 93       	st	X, r18

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    1f72:	f5 01       	movw	r30, r10
    1f74:	44 85       	ldd	r20, Z+12	; 0x0c
    1f76:	55 85       	ldd	r21, Z+13	; 0x0d
    1f78:	66 85       	ldd	r22, Z+14	; 0x0e
    1f7a:	77 85       	ldd	r23, Z+15	; 0x0f

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    1f7c:	05 e0       	ldi	r16, 0x05	; 5
    1f7e:	10 e0       	ldi	r17, 0x00	; 0
    1f80:	20 e0       	ldi	r18, 0x00	; 0
    1f82:	30 e8       	ldi	r19, 0x80	; 128
    1f84:	00 83       	st	Z, r16
    1f86:	11 83       	std	Z+1, r17	; 0x01
    1f88:	22 83       	std	Z+2, r18	; 0x02
    1f8a:	33 83       	std	Z+3, r19	; 0x03
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    1f8c:	00 e1       	ldi	r16, 0x10	; 16
    1f8e:	10 e0       	ldi	r17, 0x00	; 0
    1f90:	20 e0       	ldi	r18, 0x00	; 0
    1f92:	30 e0       	ldi	r19, 0x00	; 0
    1f94:	04 83       	std	Z+4, r16	; 0x04
    1f96:	15 83       	std	Z+5, r17	; 0x05
    1f98:	26 83       	std	Z+6, r18	; 0x06
    1f9a:	37 83       	std	Z+7, r19	; 0x07
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
    1f9c:	dc 01       	movw	r26, r24
    1f9e:	58 96       	adiw	r26, 0x18	; 24
    1fa0:	ed 91       	ld	r30, X+
    1fa2:	fc 91       	ld	r31, X
    1fa4:	59 97       	sbiw	r26, 0x19	; 25
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    1fa6:	d5 01       	movw	r26, r10
    1fa8:	54 96       	adiw	r26, 0x14	; 20
    1faa:	0d 91       	ld	r16, X+
    1fac:	1d 91       	ld	r17, X+
    1fae:	2d 91       	ld	r18, X+
    1fb0:	3c 91       	ld	r19, X
    1fb2:	57 97       	sbiw	r26, 0x17	; 23

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
    1fb4:	08 5f       	subi	r16, 0xF8	; 248
    1fb6:	1f 4f       	sbci	r17, 0xFF	; 255
    1fb8:	e0 0f       	add	r30, r16
    1fba:	f1 1f       	adc	r31, r17
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
    1fbc:	50 96       	adiw	r26, 0x10	; 16
    1fbe:	0d 91       	ld	r16, X+
    1fc0:	1d 91       	ld	r17, X+
    1fc2:	2d 91       	ld	r18, X+
    1fc4:	3c 91       	ld	r19, X
    1fc6:	53 97       	sbiw	r26, 0x13	; 19
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    1fc8:	9f 01       	movw	r18, r30
    1fca:	49 dd       	rcall	.-1390   	; 0x1a5e <RNDIS_Device_ProcessNDISSet>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    1fcc:	88 23       	and	r24, r24
    1fce:	21 f0       	breq	.+8      	; 0x1fd8 <RNDIS_Device_ProcessRNDISControlMessage+0x256>
    1fd0:	80 e0       	ldi	r24, 0x00	; 0
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	dc 01       	movw	r26, r24
    1fd6:	04 c0       	rjmp	.+8      	; 0x1fe0 <RNDIS_Device_ProcessRNDISControlMessage+0x25e>
    1fd8:	8b eb       	ldi	r24, 0xBB	; 187
    1fda:	90 e0       	ldi	r25, 0x00	; 0
    1fdc:	a0 e0       	ldi	r26, 0x00	; 0
    1fde:	b0 ec       	ldi	r27, 0xC0	; 192
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->Config.MessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    1fe0:	f5 01       	movw	r30, r10
    1fe2:	84 87       	std	Z+12, r24	; 0x0c
    1fe4:	95 87       	std	Z+13, r25	; 0x0d
    1fe6:	a6 87       	std	Z+14, r26	; 0x0e
    1fe8:	b7 87       	std	Z+15, r27	; 0x0f
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
    1fea:	37 c0       	rjmp	.+110    	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    1fec:	21 e0       	ldi	r18, 0x01	; 1
    1fee:	dc 01       	movw	r26, r24
    1ff0:	5c 96       	adiw	r26, 0x1c	; 28
    1ff2:	2c 93       	st	X, r18

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    1ff4:	86 e0       	ldi	r24, 0x06	; 6
    1ff6:	90 e0       	ldi	r25, 0x00	; 0
    1ff8:	a0 e0       	ldi	r26, 0x00	; 0
    1ffa:	b0 e8       	ldi	r27, 0x80	; 128
    1ffc:	f5 01       	movw	r30, r10
    1ffe:	80 83       	st	Z, r24
    2000:	91 83       	std	Z+1, r25	; 0x01
    2002:	a2 83       	std	Z+2, r26	; 0x02
    2004:	b3 83       	std	Z+3, r27	; 0x03
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    2006:	80 e1       	ldi	r24, 0x10	; 16
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	a0 e0       	ldi	r26, 0x00	; 0
    200c:	b0 e0       	ldi	r27, 0x00	; 0
    200e:	84 83       	std	Z+4, r24	; 0x04
    2010:	95 83       	std	Z+5, r25	; 0x05
    2012:	a6 83       	std	Z+6, r26	; 0x06
    2014:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2016:	10 86       	std	Z+8, r1	; 0x08
    2018:	11 86       	std	Z+9, r1	; 0x09
    201a:	12 86       	std	Z+10, r1	; 0x0a
    201c:	13 86       	std	Z+11, r1	; 0x0b
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);
    201e:	14 86       	std	Z+12, r1	; 0x0c
    2020:	15 86       	std	Z+13, r1	; 0x0d
    2022:	16 86       	std	Z+14, r1	; 0x0e
    2024:	17 86       	std	Z+15, r1	; 0x0f

			break;
    2026:	19 c0       	rjmp	.+50     	; 0x205a <__DATA_REGION_LENGTH__+0x5a>
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2028:	21 e0       	ldi	r18, 0x01	; 1
    202a:	dc 01       	movw	r26, r24
    202c:	5c 96       	adiw	r26, 0x1c	; 28
    202e:	2c 93       	st	X, r18
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)RNDISInterfaceInfo->Config.MessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)RNDISInterfaceInfo->Config.MessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    2030:	88 e0       	ldi	r24, 0x08	; 8
    2032:	90 e0       	ldi	r25, 0x00	; 0
    2034:	a0 e0       	ldi	r26, 0x00	; 0
    2036:	b0 e8       	ldi	r27, 0x80	; 128
    2038:	f5 01       	movw	r30, r10
    203a:	80 83       	st	Z, r24
    203c:	91 83       	std	Z+1, r25	; 0x01
    203e:	a2 83       	std	Z+2, r26	; 0x02
    2040:	b3 83       	std	Z+3, r27	; 0x03
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    2042:	80 e1       	ldi	r24, 0x10	; 16
    2044:	90 e0       	ldi	r25, 0x00	; 0
    2046:	a0 e0       	ldi	r26, 0x00	; 0
    2048:	b0 e0       	ldi	r27, 0x00	; 0
    204a:	84 83       	std	Z+4, r24	; 0x04
    204c:	95 83       	std	Z+5, r25	; 0x05
    204e:	a6 83       	std	Z+6, r26	; 0x06
    2050:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2052:	14 86       	std	Z+12, r1	; 0x0c
    2054:	15 86       	std	Z+13, r1	; 0x0d
    2056:	16 86       	std	Z+14, r1	; 0x0e
    2058:	17 86       	std	Z+15, r1	; 0x0f

			break;
	}
}
    205a:	0f 90       	pop	r0
    205c:	0f 90       	pop	r0
    205e:	df 91       	pop	r29
    2060:	cf 91       	pop	r28
    2062:	1f 91       	pop	r17
    2064:	0f 91       	pop	r16
    2066:	ff 90       	pop	r15
    2068:	ef 90       	pop	r14
    206a:	df 90       	pop	r13
    206c:	cf 90       	pop	r12
    206e:	bf 90       	pop	r11
    2070:	af 90       	pop	r10
    2072:	08 95       	ret

00002074 <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    2074:	ef 92       	push	r14
    2076:	ff 92       	push	r15
    2078:	0f 93       	push	r16
    207a:	1f 93       	push	r17
    207c:	cf 93       	push	r28
    207e:	df 93       	push	r29
    2080:	fc 01       	movw	r30, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2082:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
	if (!(Endpoint_IsSETUPReceived()))
    2086:	93 ff       	sbrs	r25, 3
    2088:	5a c0       	rjmp	.+180    	; 0x213e <__stack+0x3f>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    208a:	80 91 59 14 	lds	r24, 0x1459	; 0x801459 <USB_ControlRequest+0x4>
    208e:	90 91 5a 14 	lds	r25, 0x145A	; 0x80145a <USB_ControlRequest+0x5>
    2092:	20 81       	ld	r18, Z
    2094:	30 e0       	ldi	r19, 0x00	; 0
    2096:	82 17       	cp	r24, r18
    2098:	93 07       	cpc	r25, r19
    209a:	09 f0       	breq	.+2      	; 0x209e <RNDIS_Device_ProcessControlRequest+0x2a>
    209c:	50 c0       	rjmp	.+160    	; 0x213e <__stack+0x3f>
    209e:	ef 01       	movw	r28, r30
	  return;

	switch (USB_ControlRequest.bRequest)
    20a0:	80 91 56 14 	lds	r24, 0x1456	; 0x801456 <USB_ControlRequest+0x1>
    20a4:	88 23       	and	r24, r24
    20a6:	19 f0       	breq	.+6      	; 0x20ae <RNDIS_Device_ProcessControlRequest+0x3a>
    20a8:	81 30       	cpi	r24, 0x01	; 1
    20aa:	d1 f0       	breq	.+52     	; 0x20e0 <RNDIS_Device_ProcessControlRequest+0x6c>
    20ac:	48 c0       	rjmp	.+144    	; 0x213e <__stack+0x3f>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    20ae:	80 91 55 14 	lds	r24, 0x1455	; 0x801455 <USB_ControlRequest>
    20b2:	81 32       	cpi	r24, 0x21	; 33
    20b4:	09 f0       	breq	.+2      	; 0x20b8 <RNDIS_Device_ProcessControlRequest+0x44>
    20b6:	43 c0       	rjmp	.+134    	; 0x213e <__stack+0x3f>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    20b8:	08 ee       	ldi	r16, 0xE8	; 232
    20ba:	10 e0       	ldi	r17, 0x00	; 0
    20bc:	f8 01       	movw	r30, r16
    20be:	80 81       	ld	r24, Z
    20c0:	87 7f       	andi	r24, 0xF7	; 247
    20c2:	80 83       	st	Z, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->Config.MessageBuffer, USB_ControlRequest.wLength);
    20c4:	60 91 5b 14 	lds	r22, 0x145B	; 0x80145b <USB_ControlRequest+0x6>
    20c8:	70 91 5c 14 	lds	r23, 0x145C	; 0x80145c <USB_ControlRequest+0x7>
    20cc:	88 8d       	ldd	r24, Y+24	; 0x18
    20ce:	99 8d       	ldd	r25, Y+25	; 0x19
    20d0:	82 d2       	rcall	.+1284   	; 0x25d6 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    20d2:	f8 01       	movw	r30, r16
    20d4:	80 81       	ld	r24, Z
    20d6:	8e 77       	andi	r24, 0x7E	; 126
    20d8:	80 83       	st	Z, r24
				Endpoint_ClearIN();

				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
    20da:	ce 01       	movw	r24, r28
    20dc:	52 de       	rcall	.-860    	; 0x1d82 <RNDIS_Device_ProcessRNDISControlMessage>
    20de:	2f c0       	rjmp	.+94     	; 0x213e <__stack+0x3f>
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    20e0:	80 91 55 14 	lds	r24, 0x1455	; 0x801455 <USB_ControlRequest>
    20e4:	81 3a       	cpi	r24, 0xA1	; 161
    20e6:	59 f5       	brne	.+86     	; 0x213e <__stack+0x3f>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)RNDISInterfaceInfo->Config.MessageBuffer;
    20e8:	e0 8c       	ldd	r14, Z+24	; 0x18
    20ea:	f1 8c       	ldd	r15, Z+25	; 0x19

				if (!(MessageHeader->MessageLength))
    20ec:	f7 01       	movw	r30, r14
    20ee:	84 81       	ldd	r24, Z+4	; 0x04
    20f0:	95 81       	ldd	r25, Z+5	; 0x05
    20f2:	a6 81       	ldd	r26, Z+6	; 0x06
    20f4:	b7 81       	ldd	r27, Z+7	; 0x07
    20f6:	89 2b       	or	r24, r25
    20f8:	8a 2b       	or	r24, r26
    20fa:	8b 2b       	or	r24, r27
    20fc:	49 f4       	brne	.+18     	; 0x2110 <__stack+0x11>
				{
					RNDISInterfaceInfo->Config.MessageBuffer[0] = 0;
    20fe:	10 82       	st	Z, r1
					MessageHeader->MessageLength                = CPU_TO_LE32(1);
    2100:	81 e0       	ldi	r24, 0x01	; 1
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	a0 e0       	ldi	r26, 0x00	; 0
    2106:	b0 e0       	ldi	r27, 0x00	; 0
    2108:	84 83       	std	Z+4, r24	; 0x04
    210a:	95 83       	std	Z+5, r25	; 0x05
    210c:	a6 83       	std	Z+6, r26	; 0x06
    210e:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2110:	08 ee       	ldi	r16, 0xE8	; 232
    2112:	10 e0       	ldi	r17, 0x00	; 0
    2114:	f8 01       	movw	r30, r16
    2116:	80 81       	ld	r24, Z
    2118:	87 7f       	andi	r24, 0xF7	; 247
    211a:	80 83       	st	Z, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->Config.MessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    211c:	f7 01       	movw	r30, r14
    211e:	64 81       	ldd	r22, Z+4	; 0x04
    2120:	75 81       	ldd	r23, Z+5	; 0x05
    2122:	86 81       	ldd	r24, Z+6	; 0x06
    2124:	97 81       	ldd	r25, Z+7	; 0x07
    2126:	88 8d       	ldd	r24, Y+24	; 0x18
    2128:	99 8d       	ldd	r25, Y+25	; 0x19
    212a:	ed d1       	rcall	.+986    	; 0x2506 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    212c:	f8 01       	movw	r30, r16
    212e:	80 81       	ld	r24, Z
    2130:	8b 77       	andi	r24, 0x7B	; 123
    2132:	80 83       	st	Z, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    2134:	f7 01       	movw	r30, r14
    2136:	14 82       	std	Z+4, r1	; 0x04
    2138:	15 82       	std	Z+5, r1	; 0x05
    213a:	16 82       	std	Z+6, r1	; 0x06
    213c:	17 82       	std	Z+7, r1	; 0x07
			}

			break;
	}
}
    213e:	df 91       	pop	r29
    2140:	cf 91       	pop	r28
    2142:	1f 91       	pop	r17
    2144:	0f 91       	pop	r16
    2146:	ff 90       	pop	r15
    2148:	ef 90       	pop	r14
    214a:	08 95       	ret

0000214c <RNDIS_Device_ConfigureEndpoints>:

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    214c:	cf 93       	push	r28
    214e:	df 93       	push	r29
    2150:	fc 01       	movw	r30, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    2152:	dc 01       	movw	r26, r24
    2154:	5c 96       	adiw	r26, 0x1c	; 28
    2156:	86 e0       	ldi	r24, 0x06	; 6
    2158:	ed 01       	movw	r28, r26
    215a:	19 92       	st	Y+, r1
    215c:	8a 95       	dec	r24
    215e:	e9 f7       	brne	.-6      	; 0x215a <RNDIS_Device_ConfigureEndpoints+0xe>

	RNDISInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
    2160:	82 e0       	ldi	r24, 0x02	; 2
    2162:	84 83       	std	Z+4, r24	; 0x04
	RNDISInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
    2164:	81 87       	std	Z+9, r24	; 0x09
	RNDISInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
    2166:	83 e0       	ldi	r24, 0x03	; 3
    2168:	86 87       	std	Z+14, r24	; 0x0e

	if (RNDISInterfaceInfo->Config.MessageBuffer == NULL)
    216a:	80 8d       	ldd	r24, Z+24	; 0x18
    216c:	91 8d       	ldd	r25, Z+25	; 0x19
    216e:	89 2b       	or	r24, r25
    2170:	b9 f0       	breq	.+46     	; 0x21a0 <RNDIS_Device_ConfigureEndpoints+0x54>
	  return false;

	if (RNDISInterfaceInfo->Config.MessageBufferLength < RNDIS_DEVICE_MIN_MESSAGE_BUFFER_LENGTH)
    2172:	82 8d       	ldd	r24, Z+26	; 0x1a
    2174:	93 8d       	ldd	r25, Z+27	; 0x1b
    2176:	84 38       	cpi	r24, 0x84	; 132
    2178:	91 05       	cpc	r25, r1
    217a:	a0 f0       	brcs	.+40     	; 0x21a4 <RNDIS_Device_ConfigureEndpoints+0x58>
    217c:	ef 01       	movw	r28, r30
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
    217e:	61 e0       	ldi	r22, 0x01	; 1
    2180:	cf 01       	movw	r24, r30
    2182:	01 96       	adiw	r24, 0x01	; 1
    2184:	0c d3       	rcall	.+1560   	; 0x279e <Endpoint_ConfigureEndpointTable>
    2186:	88 23       	and	r24, r24
    2188:	71 f0       	breq	.+28     	; 0x21a6 <RNDIS_Device_ConfigureEndpoints+0x5a>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
    218a:	61 e0       	ldi	r22, 0x01	; 1
    218c:	ce 01       	movw	r24, r28
    218e:	06 96       	adiw	r24, 0x06	; 6
    2190:	06 d3       	rcall	.+1548   	; 0x279e <Endpoint_ConfigureEndpointTable>
    2192:	88 23       	and	r24, r24
    2194:	41 f0       	breq	.+16     	; 0x21a6 <RNDIS_Device_ConfigureEndpoints+0x5a>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    2196:	61 e0       	ldi	r22, 0x01	; 1
    2198:	ce 01       	movw	r24, r28
    219a:	0b 96       	adiw	r24, 0x0b	; 11
    219c:	00 d3       	rcall	.+1536   	; 0x279e <Endpoint_ConfigureEndpointTable>
    219e:	03 c0       	rjmp	.+6      	; 0x21a6 <RNDIS_Device_ConfigureEndpoints+0x5a>
	RNDISInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	RNDISInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	RNDISInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (RNDISInterfaceInfo->Config.MessageBuffer == NULL)
	  return false;
    21a0:	80 e0       	ldi	r24, 0x00	; 0
    21a2:	01 c0       	rjmp	.+2      	; 0x21a6 <RNDIS_Device_ConfigureEndpoints+0x5a>

	if (RNDISInterfaceInfo->Config.MessageBufferLength < RNDIS_DEVICE_MIN_MESSAGE_BUFFER_LENGTH)
	  return false;
    21a4:	80 e0       	ldi	r24, 0x00	; 0

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
	  return false;

	return true;
}
    21a6:	df 91       	pop	r29
    21a8:	cf 91       	pop	r28
    21aa:	08 95       	ret

000021ac <RNDIS_Device_USBTask>:

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    21ac:	0f 93       	push	r16
    21ae:	1f 93       	push	r17
    21b0:	cf 93       	push	r28
    21b2:	df 93       	push	r29
    21b4:	cd b7       	in	r28, 0x3d	; 61
    21b6:	de b7       	in	r29, 0x3e	; 62
    21b8:	28 97       	sbiw	r28, 0x08	; 8
    21ba:	0f b6       	in	r0, 0x3f	; 63
    21bc:	f8 94       	cli
    21be:	de bf       	out	0x3e, r29	; 62
    21c0:	0f be       	out	0x3f, r0	; 63
    21c2:	cd bf       	out	0x3d, r28	; 61
    21c4:	fc 01       	movw	r30, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    21c6:	90 91 54 14 	lds	r25, 0x1454	; 0x801454 <USB_DeviceState>
    21ca:	94 30       	cpi	r25, 0x04	; 4
    21cc:	19 f5       	brne	.+70     	; 0x2214 <RNDIS_Device_USBTask+0x68>
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpoint.Address);
    21ce:	83 85       	ldd	r24, Z+11	; 0x0b
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    21d0:	8f 70       	andi	r24, 0x0F	; 15
    21d2:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    21d6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    21da:	80 ff       	sbrs	r24, 0
    21dc:	1b c0       	rjmp	.+54     	; 0x2214 <RNDIS_Device_USBTask+0x68>
    21de:	84 8d       	ldd	r24, Z+28	; 0x1c
    21e0:	88 23       	and	r24, r24
    21e2:	c1 f0       	breq	.+48     	; 0x2214 <RNDIS_Device_USBTask+0x68>
    21e4:	8f 01       	movw	r16, r30
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    21e6:	88 e0       	ldi	r24, 0x08	; 8
    21e8:	e8 e2       	ldi	r30, 0x28	; 40
    21ea:	f1 e0       	ldi	r31, 0x01	; 1
    21ec:	de 01       	movw	r26, r28
    21ee:	11 96       	adiw	r26, 0x01	; 1
    21f0:	01 90       	ld	r0, Z+
    21f2:	0d 92       	st	X+, r0
    21f4:	8a 95       	dec	r24
    21f6:	e1 f7       	brne	.-8      	; 0x21f0 <RNDIS_Device_USBTask+0x44>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    21f8:	40 e0       	ldi	r20, 0x00	; 0
    21fa:	50 e0       	ldi	r21, 0x00	; 0
    21fc:	68 e0       	ldi	r22, 0x08	; 8
    21fe:	70 e0       	ldi	r23, 0x00	; 0
    2200:	ce 01       	movw	r24, r28
    2202:	01 96       	adiw	r24, 0x01	; 1
    2204:	ec d0       	rcall	.+472    	; 0x23de <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2206:	e8 ee       	ldi	r30, 0xE8	; 232
    2208:	f0 e0       	ldi	r31, 0x00	; 0
    220a:	80 81       	ld	r24, Z
    220c:	8e 77       	andi	r24, 0x7E	; 126
    220e:	80 83       	st	Z, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    2210:	f8 01       	movw	r30, r16
    2212:	14 8e       	std	Z+28, r1	; 0x1c
	}
}
    2214:	28 96       	adiw	r28, 0x08	; 8
    2216:	0f b6       	in	r0, 0x3f	; 63
    2218:	f8 94       	cli
    221a:	de bf       	out	0x3e, r29	; 62
    221c:	0f be       	out	0x3f, r0	; 63
    221e:	cd bf       	out	0x3d, r28	; 61
    2220:	df 91       	pop	r29
    2222:	cf 91       	pop	r28
    2224:	1f 91       	pop	r17
    2226:	0f 91       	pop	r16
    2228:	08 95       	ret

0000222a <RNDIS_Device_IsPacketReceived>:
			return false;
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    222a:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    222c:	90 91 54 14 	lds	r25, 0x1454	; 0x801454 <USB_DeviceState>
    2230:	94 30       	cpi	r25, 0x04	; 4
    2232:	69 f4       	brne	.+26     	; 0x224e <RNDIS_Device_IsPacketReceived+0x24>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    2234:	85 8d       	ldd	r24, Z+29	; 0x1d
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2236:	82 30       	cpi	r24, 0x02	; 2
    2238:	61 f4       	brne	.+24     	; 0x2252 <RNDIS_Device_IsPacketReceived+0x28>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
    223a:	86 81       	ldd	r24, Z+6	; 0x06
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    223c:	8f 70       	andi	r24, 0x0F	; 15
    223e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2242:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2246:	82 fb       	bst	r24, 2
    2248:	88 27       	eor	r24, r24
    224a:	80 f9       	bld	r24, 0
	return Endpoint_IsOUTReceived();
    224c:	08 95       	ret
bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    224e:	80 e0       	ldi	r24, 0x00	; 0
    2250:	08 95       	ret
    2252:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
}
    2254:	08 95       	ret

00002256 <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    2256:	ef 92       	push	r14
    2258:	ff 92       	push	r15
    225a:	0f 93       	push	r16
    225c:	1f 93       	push	r17
    225e:	cf 93       	push	r28
    2260:	df 93       	push	r29
    2262:	cd b7       	in	r28, 0x3d	; 61
    2264:	de b7       	in	r29, 0x3e	; 62
    2266:	ac 97       	sbiw	r28, 0x2c	; 44
    2268:	0f b6       	in	r0, 0x3f	; 63
    226a:	f8 94       	cli
    226c:	de bf       	out	0x3e, r29	; 62
    226e:	0f be       	out	0x3f, r0	; 63
    2270:	cd bf       	out	0x3d, r28	; 61
    2272:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2274:	90 91 54 14 	lds	r25, 0x1454	; 0x801454 <USB_DeviceState>
    2278:	94 30       	cpi	r25, 0x04	; 4
    227a:	c1 f5       	brne	.+112    	; 0x22ec <RNDIS_Device_ReadPacket+0x96>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    227c:	85 8d       	ldd	r24, Z+29	; 0x1d

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    227e:	82 30       	cpi	r24, 0x02	; 2
    2280:	b9 f5       	brne	.+110    	; 0x22f0 <RNDIS_Device_ReadPacket+0x9a>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
    2282:	86 81       	ldd	r24, Z+6	; 0x06
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2284:	8f 70       	andi	r24, 0x0F	; 15
    2286:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>

	*PacketLength = 0;
    228a:	fa 01       	movw	r30, r20
    228c:	11 82       	std	Z+1, r1	; 0x01
    228e:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2290:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (!(Endpoint_IsOUTReceived()))
    2294:	89 2f       	mov	r24, r25
    2296:	84 70       	andi	r24, 0x04	; 4
    2298:	92 ff       	sbrs	r25, 2
    229a:	2b c0       	rjmp	.+86     	; 0x22f2 <RNDIS_Device_ReadPacket+0x9c>
    229c:	8a 01       	movw	r16, r20
    229e:	7b 01       	movw	r14, r22
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    22a0:	40 e0       	ldi	r20, 0x00	; 0
    22a2:	50 e0       	ldi	r21, 0x00	; 0
    22a4:	6c e2       	ldi	r22, 0x2C	; 44
    22a6:	70 e0       	ldi	r23, 0x00	; 0
    22a8:	ce 01       	movw	r24, r28
    22aa:	01 96       	adiw	r24, 0x01	; 1
    22ac:	e2 d0       	rcall	.+452    	; 0x2472 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    22ae:	6d 85       	ldd	r22, Y+13	; 0x0d
    22b0:	7e 85       	ldd	r23, Y+14	; 0x0e
    22b2:	8f 85       	ldd	r24, Y+15	; 0x0f
    22b4:	98 89       	ldd	r25, Y+16	; 0x10
    22b6:	6d 3d       	cpi	r22, 0xDD	; 221
    22b8:	f5 e0       	ldi	r31, 0x05	; 5
    22ba:	7f 07       	cpc	r23, r31
    22bc:	81 05       	cpc	r24, r1
    22be:	91 05       	cpc	r25, r1
    22c0:	38 f0       	brcs	.+14     	; 0x22d0 <RNDIS_Device_ReadPacket+0x7a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    22c2:	eb ee       	ldi	r30, 0xEB	; 235
    22c4:	f0 e0       	ldi	r31, 0x00	; 0
    22c6:	80 81       	ld	r24, Z
    22c8:	80 62       	ori	r24, 0x20	; 32
    22ca:	80 83       	st	Z, r24
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    22cc:	80 e8       	ldi	r24, 0x80	; 128
    22ce:	11 c0       	rjmp	.+34     	; 0x22f2 <RNDIS_Device_ReadPacket+0x9c>
	}

	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    22d0:	f8 01       	movw	r30, r16
    22d2:	71 83       	std	Z+1, r23	; 0x01
    22d4:	60 83       	st	Z, r22

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    22d6:	40 e0       	ldi	r20, 0x00	; 0
    22d8:	50 e0       	ldi	r21, 0x00	; 0
    22da:	c7 01       	movw	r24, r14
    22dc:	ca d0       	rcall	.+404    	; 0x2472 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    22de:	e8 ee       	ldi	r30, 0xE8	; 232
    22e0:	f0 e0       	ldi	r31, 0x00	; 0
    22e2:	80 81       	ld	r24, Z
    22e4:	8b 77       	andi	r24, 0x7B	; 123
    22e6:	80 83       	st	Z, r24
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	03 c0       	rjmp	.+6      	; 0x22f2 <RNDIS_Device_ReadPacket+0x9c>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    22ec:	82 e0       	ldi	r24, 0x02	; 2
    22ee:	01 c0       	rjmp	.+2      	; 0x22f2 <RNDIS_Device_ReadPacket+0x9c>
    22f0:	82 e0       	ldi	r24, 0x02	; 2

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
}
    22f2:	ac 96       	adiw	r28, 0x2c	; 44
    22f4:	0f b6       	in	r0, 0x3f	; 63
    22f6:	f8 94       	cli
    22f8:	de bf       	out	0x3e, r29	; 62
    22fa:	0f be       	out	0x3f, r0	; 63
    22fc:	cd bf       	out	0x3d, r28	; 61
    22fe:	df 91       	pop	r29
    2300:	cf 91       	pop	r28
    2302:	1f 91       	pop	r17
    2304:	0f 91       	pop	r16
    2306:	ff 90       	pop	r15
    2308:	ef 90       	pop	r14
    230a:	08 95       	ret

0000230c <RNDIS_Device_SendPacket>:

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    230c:	ef 92       	push	r14
    230e:	ff 92       	push	r15
    2310:	0f 93       	push	r16
    2312:	1f 93       	push	r17
    2314:	cf 93       	push	r28
    2316:	df 93       	push	r29
    2318:	cd b7       	in	r28, 0x3d	; 61
    231a:	de b7       	in	r29, 0x3e	; 62
    231c:	ac 97       	sbiw	r28, 0x2c	; 44
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	f8 94       	cli
    2322:	de bf       	out	0x3e, r29	; 62
    2324:	0f be       	out	0x3f, r0	; 63
    2326:	cd bf       	out	0x3d, r28	; 61
    2328:	fc 01       	movw	r30, r24
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    232a:	90 91 54 14 	lds	r25, 0x1454	; 0x801454 <USB_DeviceState>
    232e:	94 30       	cpi	r25, 0x04	; 4
    2330:	09 f0       	breq	.+2      	; 0x2334 <RNDIS_Device_SendPacket+0x28>
    2332:	45 c0       	rjmp	.+138    	; 0x23be <RNDIS_Device_SendPacket+0xb2>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    2334:	85 8d       	ldd	r24, Z+29	; 0x1d
                                void* Buffer,
                                const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2336:	82 30       	cpi	r24, 0x02	; 2
    2338:	09 f0       	breq	.+2      	; 0x233c <RNDIS_Device_SendPacket+0x30>
    233a:	43 c0       	rjmp	.+134    	; 0x23c2 <RNDIS_Device_SendPacket+0xb6>
    233c:	8a 01       	movw	r16, r20
    233e:	7b 01       	movw	r14, r22
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpoint.Address);
    2340:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2342:	8f 70       	andi	r24, 0x0F	; 15
    2344:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    2348:	91 d2       	rcall	.+1314   	; 0x286c <Endpoint_WaitUntilReady>
    234a:	81 11       	cpse	r24, r1
    234c:	3b c0       	rjmp	.+118    	; 0x23c4 <RNDIS_Device_SendPacket+0xb8>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    234e:	ce 01       	movw	r24, r28
    2350:	01 96       	adiw	r24, 0x01	; 1
    2352:	2c e2       	ldi	r18, 0x2C	; 44
    2354:	fc 01       	movw	r30, r24
    2356:	11 92       	st	Z+, r1
    2358:	2a 95       	dec	r18
    235a:	e9 f7       	brne	.-6      	; 0x2356 <RNDIS_Device_SendPacket+0x4a>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    235c:	41 e0       	ldi	r20, 0x01	; 1
    235e:	50 e0       	ldi	r21, 0x00	; 0
    2360:	60 e0       	ldi	r22, 0x00	; 0
    2362:	70 e0       	ldi	r23, 0x00	; 0
    2364:	49 83       	std	Y+1, r20	; 0x01
    2366:	5a 83       	std	Y+2, r21	; 0x02
    2368:	6b 83       	std	Y+3, r22	; 0x03
    236a:	7c 83       	std	Y+4, r23	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    236c:	a8 01       	movw	r20, r16
    236e:	44 5d       	subi	r20, 0xD4	; 212
    2370:	5f 4f       	sbci	r21, 0xFF	; 255
    2372:	60 e0       	ldi	r22, 0x00	; 0
    2374:	70 e0       	ldi	r23, 0x00	; 0
    2376:	4d 83       	std	Y+5, r20	; 0x05
    2378:	5e 83       	std	Y+6, r21	; 0x06
    237a:	6f 83       	std	Y+7, r22	; 0x07
    237c:	78 87       	std	Y+8, r23	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    237e:	44 e2       	ldi	r20, 0x24	; 36
    2380:	50 e0       	ldi	r21, 0x00	; 0
    2382:	60 e0       	ldi	r22, 0x00	; 0
    2384:	70 e0       	ldi	r23, 0x00	; 0
    2386:	49 87       	std	Y+9, r20	; 0x09
    2388:	5a 87       	std	Y+10, r21	; 0x0a
    238a:	6b 87       	std	Y+11, r22	; 0x0b
    238c:	7c 87       	std	Y+12, r23	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    238e:	a8 01       	movw	r20, r16
    2390:	60 e0       	ldi	r22, 0x00	; 0
    2392:	70 e0       	ldi	r23, 0x00	; 0
    2394:	4d 87       	std	Y+13, r20	; 0x0d
    2396:	5e 87       	std	Y+14, r21	; 0x0e
    2398:	6f 87       	std	Y+15, r22	; 0x0f
    239a:	78 8b       	std	Y+16, r23	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    239c:	40 e0       	ldi	r20, 0x00	; 0
    239e:	50 e0       	ldi	r21, 0x00	; 0
    23a0:	6c e2       	ldi	r22, 0x2C	; 44
    23a2:	70 e0       	ldi	r23, 0x00	; 0
    23a4:	1c d0       	rcall	.+56     	; 0x23de <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    23a6:	40 e0       	ldi	r20, 0x00	; 0
    23a8:	50 e0       	ldi	r21, 0x00	; 0
    23aa:	b8 01       	movw	r22, r16
    23ac:	c7 01       	movw	r24, r14
    23ae:	17 d0       	rcall	.+46     	; 0x23de <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    23b0:	e8 ee       	ldi	r30, 0xE8	; 232
    23b2:	f0 e0       	ldi	r31, 0x00	; 0
    23b4:	80 81       	ld	r24, Z
    23b6:	8e 77       	andi	r24, 0x7E	; 126
    23b8:	80 83       	st	Z, r24
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    23ba:	80 e0       	ldi	r24, 0x00	; 0
    23bc:	03 c0       	rjmp	.+6      	; 0x23c4 <RNDIS_Device_SendPacket+0xb8>
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    23be:	82 e0       	ldi	r24, 0x02	; 2
    23c0:	01 c0       	rjmp	.+2      	; 0x23c4 <RNDIS_Device_SendPacket+0xb8>
    23c2:	82 e0       	ldi	r24, 0x02	; 2
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    23c4:	ac 96       	adiw	r28, 0x2c	; 44
    23c6:	0f b6       	in	r0, 0x3f	; 63
    23c8:	f8 94       	cli
    23ca:	de bf       	out	0x3e, r29	; 62
    23cc:	0f be       	out	0x3f, r0	; 63
    23ce:	cd bf       	out	0x3d, r28	; 61
    23d0:	df 91       	pop	r29
    23d2:	cf 91       	pop	r28
    23d4:	1f 91       	pop	r17
    23d6:	0f 91       	pop	r16
    23d8:	ff 90       	pop	r15
    23da:	ef 90       	pop	r14
    23dc:	08 95       	ret

000023de <Endpoint_Write_Stream_LE>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    23de:	cf 92       	push	r12
    23e0:	df 92       	push	r13
    23e2:	ef 92       	push	r14
    23e4:	ff 92       	push	r15
    23e6:	0f 93       	push	r16
    23e8:	1f 93       	push	r17
    23ea:	cf 93       	push	r28
    23ec:	df 93       	push	r29
    23ee:	8c 01       	movw	r16, r24
    23f0:	eb 01       	movw	r28, r22
    23f2:	6a 01       	movw	r12, r20
    23f4:	3b d2       	rcall	.+1142   	; 0x286c <Endpoint_WaitUntilReady>
    23f6:	81 11       	cpse	r24, r1
    23f8:	33 c0       	rjmp	.+102    	; 0x2460 <Endpoint_Write_Stream_LE+0x82>
    23fa:	c1 14       	cp	r12, r1
    23fc:	d1 04       	cpc	r13, r1
    23fe:	39 f0       	breq	.+14     	; 0x240e <Endpoint_Write_Stream_LE+0x30>
    2400:	f6 01       	movw	r30, r12
    2402:	80 81       	ld	r24, Z
    2404:	91 81       	ldd	r25, Z+1	; 0x01
    2406:	c8 1b       	sub	r28, r24
    2408:	d9 0b       	sbc	r29, r25
    240a:	08 0f       	add	r16, r24
    240c:	19 1f       	adc	r17, r25
    240e:	e1 2c       	mov	r14, r1
    2410:	f1 2c       	mov	r15, r1
    2412:	23 c0       	rjmp	.+70     	; 0x245a <Endpoint_Write_Stream_LE+0x7c>
    2414:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2418:	95 fd       	sbrc	r25, 5
    241a:	16 c0       	rjmp	.+44     	; 0x2448 <Endpoint_Write_Stream_LE+0x6a>
    241c:	e8 ee       	ldi	r30, 0xE8	; 232
    241e:	f0 e0       	ldi	r31, 0x00	; 0
    2420:	80 81       	ld	r24, Z
    2422:	8e 77       	andi	r24, 0x7E	; 126
    2424:	80 83       	st	Z, r24
    2426:	44 d5       	rcall	.+2696   	; 0x2eb0 <USB_USBTask>
    2428:	c1 14       	cp	r12, r1
    242a:	d1 04       	cpc	r13, r1
    242c:	49 f0       	breq	.+18     	; 0x2440 <Endpoint_Write_Stream_LE+0x62>
    242e:	f6 01       	movw	r30, r12
    2430:	80 81       	ld	r24, Z
    2432:	91 81       	ldd	r25, Z+1	; 0x01
    2434:	e8 0e       	add	r14, r24
    2436:	f9 1e       	adc	r15, r25
    2438:	f1 82       	std	Z+1, r15	; 0x01
    243a:	e0 82       	st	Z, r14
    243c:	85 e0       	ldi	r24, 0x05	; 5
    243e:	10 c0       	rjmp	.+32     	; 0x2460 <Endpoint_Write_Stream_LE+0x82>
    2440:	15 d2       	rcall	.+1066   	; 0x286c <Endpoint_WaitUntilReady>
    2442:	88 23       	and	r24, r24
    2444:	51 f0       	breq	.+20     	; 0x245a <Endpoint_Write_Stream_LE+0x7c>
    2446:	0c c0       	rjmp	.+24     	; 0x2460 <Endpoint_Write_Stream_LE+0x82>
    2448:	f8 01       	movw	r30, r16
    244a:	81 91       	ld	r24, Z+
    244c:	8f 01       	movw	r16, r30
    244e:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    2452:	21 97       	sbiw	r28, 0x01	; 1
    2454:	ff ef       	ldi	r31, 0xFF	; 255
    2456:	ef 1a       	sub	r14, r31
    2458:	ff 0a       	sbc	r15, r31
    245a:	20 97       	sbiw	r28, 0x00	; 0
    245c:	d9 f6       	brne	.-74     	; 0x2414 <Endpoint_Write_Stream_LE+0x36>
    245e:	80 e0       	ldi	r24, 0x00	; 0
    2460:	df 91       	pop	r29
    2462:	cf 91       	pop	r28
    2464:	1f 91       	pop	r17
    2466:	0f 91       	pop	r16
    2468:	ff 90       	pop	r15
    246a:	ef 90       	pop	r14
    246c:	df 90       	pop	r13
    246e:	cf 90       	pop	r12
    2470:	08 95       	ret

00002472 <Endpoint_Read_Stream_LE>:
    2472:	cf 92       	push	r12
    2474:	df 92       	push	r13
    2476:	ef 92       	push	r14
    2478:	ff 92       	push	r15
    247a:	0f 93       	push	r16
    247c:	1f 93       	push	r17
    247e:	cf 93       	push	r28
    2480:	df 93       	push	r29
    2482:	8c 01       	movw	r16, r24
    2484:	eb 01       	movw	r28, r22
    2486:	6a 01       	movw	r12, r20
    2488:	f1 d1       	rcall	.+994    	; 0x286c <Endpoint_WaitUntilReady>
    248a:	81 11       	cpse	r24, r1
    248c:	33 c0       	rjmp	.+102    	; 0x24f4 <Endpoint_Read_Stream_LE+0x82>
    248e:	c1 14       	cp	r12, r1
    2490:	d1 04       	cpc	r13, r1
    2492:	39 f0       	breq	.+14     	; 0x24a2 <Endpoint_Read_Stream_LE+0x30>
    2494:	f6 01       	movw	r30, r12
    2496:	80 81       	ld	r24, Z
    2498:	91 81       	ldd	r25, Z+1	; 0x01
    249a:	c8 1b       	sub	r28, r24
    249c:	d9 0b       	sbc	r29, r25
    249e:	08 0f       	add	r16, r24
    24a0:	19 1f       	adc	r17, r25
    24a2:	e1 2c       	mov	r14, r1
    24a4:	f1 2c       	mov	r15, r1
    24a6:	23 c0       	rjmp	.+70     	; 0x24ee <Endpoint_Read_Stream_LE+0x7c>
    24a8:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    24ac:	95 fd       	sbrc	r25, 5
    24ae:	16 c0       	rjmp	.+44     	; 0x24dc <Endpoint_Read_Stream_LE+0x6a>
    24b0:	e8 ee       	ldi	r30, 0xE8	; 232
    24b2:	f0 e0       	ldi	r31, 0x00	; 0
    24b4:	80 81       	ld	r24, Z
    24b6:	8b 77       	andi	r24, 0x7B	; 123
    24b8:	80 83       	st	Z, r24
    24ba:	fa d4       	rcall	.+2548   	; 0x2eb0 <USB_USBTask>
    24bc:	c1 14       	cp	r12, r1
    24be:	d1 04       	cpc	r13, r1
    24c0:	49 f0       	breq	.+18     	; 0x24d4 <Endpoint_Read_Stream_LE+0x62>
    24c2:	f6 01       	movw	r30, r12
    24c4:	80 81       	ld	r24, Z
    24c6:	91 81       	ldd	r25, Z+1	; 0x01
    24c8:	e8 0e       	add	r14, r24
    24ca:	f9 1e       	adc	r15, r25
    24cc:	f1 82       	std	Z+1, r15	; 0x01
    24ce:	e0 82       	st	Z, r14
    24d0:	85 e0       	ldi	r24, 0x05	; 5
    24d2:	10 c0       	rjmp	.+32     	; 0x24f4 <Endpoint_Read_Stream_LE+0x82>
    24d4:	cb d1       	rcall	.+918    	; 0x286c <Endpoint_WaitUntilReady>
    24d6:	88 23       	and	r24, r24
    24d8:	51 f0       	breq	.+20     	; 0x24ee <Endpoint_Read_Stream_LE+0x7c>
    24da:	0c c0       	rjmp	.+24     	; 0x24f4 <Endpoint_Read_Stream_LE+0x82>
    24dc:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    24e0:	f8 01       	movw	r30, r16
    24e2:	81 93       	st	Z+, r24
    24e4:	8f 01       	movw	r16, r30
    24e6:	21 97       	sbiw	r28, 0x01	; 1
    24e8:	ff ef       	ldi	r31, 0xFF	; 255
    24ea:	ef 1a       	sub	r14, r31
    24ec:	ff 0a       	sbc	r15, r31
    24ee:	20 97       	sbiw	r28, 0x00	; 0
    24f0:	d9 f6       	brne	.-74     	; 0x24a8 <Endpoint_Read_Stream_LE+0x36>
    24f2:	80 e0       	ldi	r24, 0x00	; 0
    24f4:	df 91       	pop	r29
    24f6:	cf 91       	pop	r28
    24f8:	1f 91       	pop	r17
    24fa:	0f 91       	pop	r16
    24fc:	ff 90       	pop	r15
    24fe:	ef 90       	pop	r14
    2500:	df 90       	pop	r13
    2502:	cf 90       	pop	r12
    2504:	08 95       	ret

00002506 <Endpoint_Write_Control_Stream_LE>:
    2506:	20 91 5b 14 	lds	r18, 0x145B	; 0x80145b <USB_ControlRequest+0x6>
    250a:	30 91 5c 14 	lds	r19, 0x145C	; 0x80145c <USB_ControlRequest+0x7>
    250e:	26 17       	cp	r18, r22
    2510:	37 07       	cpc	r19, r23
    2512:	58 f0       	brcs	.+22     	; 0x252a <Endpoint_Write_Control_Stream_LE+0x24>
    2514:	61 15       	cp	r22, r1
    2516:	71 05       	cpc	r23, r1
    2518:	39 f4       	brne	.+14     	; 0x2528 <Endpoint_Write_Control_Stream_LE+0x22>
    251a:	e8 ee       	ldi	r30, 0xE8	; 232
    251c:	f0 e0       	ldi	r31, 0x00	; 0
    251e:	20 81       	ld	r18, Z
    2520:	2e 77       	andi	r18, 0x7E	; 126
    2522:	20 83       	st	Z, r18
    2524:	9b 01       	movw	r18, r22
    2526:	01 c0       	rjmp	.+2      	; 0x252a <Endpoint_Write_Control_Stream_LE+0x24>
    2528:	9b 01       	movw	r18, r22
    252a:	e8 2f       	mov	r30, r24
    252c:	f9 2f       	mov	r31, r25
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	30 c0       	rjmp	.+96     	; 0x2592 <Endpoint_Write_Control_Stream_LE+0x8c>
    2532:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>
    2536:	88 23       	and	r24, r24
    2538:	09 f4       	brne	.+2      	; 0x253c <Endpoint_Write_Control_Stream_LE+0x36>
    253a:	41 c0       	rjmp	.+130    	; 0x25be <Endpoint_Write_Control_Stream_LE+0xb8>
    253c:	85 30       	cpi	r24, 0x05	; 5
    253e:	09 f4       	brne	.+2      	; 0x2542 <Endpoint_Write_Control_Stream_LE+0x3c>
    2540:	40 c0       	rjmp	.+128    	; 0x25c2 <Endpoint_Write_Control_Stream_LE+0xbc>
    2542:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2546:	83 fd       	sbrc	r24, 3
    2548:	3e c0       	rjmp	.+124    	; 0x25c6 <Endpoint_Write_Control_Stream_LE+0xc0>
    254a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    254e:	82 fd       	sbrc	r24, 2
    2550:	30 c0       	rjmp	.+96     	; 0x25b2 <Endpoint_Write_Control_Stream_LE+0xac>
    2552:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2556:	80 ff       	sbrs	r24, 0
    2558:	1c c0       	rjmp	.+56     	; 0x2592 <Endpoint_Write_Control_Stream_LE+0x8c>
    255a:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    255e:	50 91 f3 00 	lds	r21, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    2562:	07 c0       	rjmp	.+14     	; 0x2572 <Endpoint_Write_Control_Stream_LE+0x6c>
    2564:	81 91       	ld	r24, Z+
    2566:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    256a:	21 50       	subi	r18, 0x01	; 1
    256c:	31 09       	sbc	r19, r1
    256e:	4f 5f       	subi	r20, 0xFF	; 255
    2570:	5f 4f       	sbci	r21, 0xFF	; 255
    2572:	21 15       	cp	r18, r1
    2574:	31 05       	cpc	r19, r1
    2576:	19 f0       	breq	.+6      	; 0x257e <Endpoint_Write_Control_Stream_LE+0x78>
    2578:	48 30       	cpi	r20, 0x08	; 8
    257a:	51 05       	cpc	r21, r1
    257c:	98 f3       	brcs	.-26     	; 0x2564 <Endpoint_Write_Control_Stream_LE+0x5e>
    257e:	91 e0       	ldi	r25, 0x01	; 1
    2580:	48 30       	cpi	r20, 0x08	; 8
    2582:	51 05       	cpc	r21, r1
    2584:	09 f0       	breq	.+2      	; 0x2588 <Endpoint_Write_Control_Stream_LE+0x82>
    2586:	90 e0       	ldi	r25, 0x00	; 0
    2588:	a8 ee       	ldi	r26, 0xE8	; 232
    258a:	b0 e0       	ldi	r27, 0x00	; 0
    258c:	8c 91       	ld	r24, X
    258e:	8e 77       	andi	r24, 0x7E	; 126
    2590:	8c 93       	st	X, r24
    2592:	21 15       	cp	r18, r1
    2594:	31 05       	cpc	r19, r1
    2596:	69 f6       	brne	.-102    	; 0x2532 <Endpoint_Write_Control_Stream_LE+0x2c>
    2598:	91 11       	cpse	r25, r1
    259a:	cb cf       	rjmp	.-106    	; 0x2532 <Endpoint_Write_Control_Stream_LE+0x2c>
    259c:	0a c0       	rjmp	.+20     	; 0x25b2 <Endpoint_Write_Control_Stream_LE+0xac>
    259e:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>
    25a2:	88 23       	and	r24, r24
    25a4:	91 f0       	breq	.+36     	; 0x25ca <Endpoint_Write_Control_Stream_LE+0xc4>
    25a6:	85 30       	cpi	r24, 0x05	; 5
    25a8:	91 f0       	breq	.+36     	; 0x25ce <Endpoint_Write_Control_Stream_LE+0xc8>
    25aa:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    25ae:	83 fd       	sbrc	r24, 3
    25b0:	10 c0       	rjmp	.+32     	; 0x25d2 <Endpoint_Write_Control_Stream_LE+0xcc>
    25b2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    25b6:	82 ff       	sbrs	r24, 2
    25b8:	f2 cf       	rjmp	.-28     	; 0x259e <Endpoint_Write_Control_Stream_LE+0x98>
    25ba:	80 e0       	ldi	r24, 0x00	; 0
    25bc:	08 95       	ret
    25be:	82 e0       	ldi	r24, 0x02	; 2
    25c0:	08 95       	ret
    25c2:	83 e0       	ldi	r24, 0x03	; 3
    25c4:	08 95       	ret
    25c6:	81 e0       	ldi	r24, 0x01	; 1
    25c8:	08 95       	ret
    25ca:	82 e0       	ldi	r24, 0x02	; 2
    25cc:	08 95       	ret
    25ce:	83 e0       	ldi	r24, 0x03	; 3
    25d0:	08 95       	ret
    25d2:	81 e0       	ldi	r24, 0x01	; 1
    25d4:	08 95       	ret

000025d6 <Endpoint_Read_Control_Stream_LE>:
    25d6:	61 15       	cp	r22, r1
    25d8:	71 05       	cpc	r23, r1
    25da:	29 f4       	brne	.+10     	; 0x25e6 <Endpoint_Read_Control_Stream_LE+0x10>
    25dc:	e8 ee       	ldi	r30, 0xE8	; 232
    25de:	f0 e0       	ldi	r31, 0x00	; 0
    25e0:	20 81       	ld	r18, Z
    25e2:	2b 77       	andi	r18, 0x7B	; 123
    25e4:	20 83       	st	Z, r18
    25e6:	e8 2f       	mov	r30, r24
    25e8:	f9 2f       	mov	r31, r25
    25ea:	22 c0       	rjmp	.+68     	; 0x2630 <Endpoint_Read_Control_Stream_LE+0x5a>
    25ec:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>
    25f0:	88 23       	and	r24, r24
    25f2:	71 f1       	breq	.+92     	; 0x2650 <Endpoint_Read_Control_Stream_LE+0x7a>
    25f4:	85 30       	cpi	r24, 0x05	; 5
    25f6:	71 f1       	breq	.+92     	; 0x2654 <Endpoint_Read_Control_Stream_LE+0x7e>
    25f8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    25fc:	83 fd       	sbrc	r24, 3
    25fe:	2c c0       	rjmp	.+88     	; 0x2658 <Endpoint_Read_Control_Stream_LE+0x82>
    2600:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2604:	82 ff       	sbrs	r24, 2
    2606:	14 c0       	rjmp	.+40     	; 0x2630 <Endpoint_Read_Control_Stream_LE+0x5a>
    2608:	05 c0       	rjmp	.+10     	; 0x2614 <Endpoint_Read_Control_Stream_LE+0x3e>
    260a:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
    260e:	81 93       	st	Z+, r24
    2610:	61 50       	subi	r22, 0x01	; 1
    2612:	71 09       	sbc	r23, r1
    2614:	61 15       	cp	r22, r1
    2616:	71 05       	cpc	r23, r1
    2618:	31 f0       	breq	.+12     	; 0x2626 <Endpoint_Read_Control_Stream_LE+0x50>
    261a:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    261e:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
    2622:	89 2b       	or	r24, r25
    2624:	91 f7       	brne	.-28     	; 0x260a <Endpoint_Read_Control_Stream_LE+0x34>
    2626:	a8 ee       	ldi	r26, 0xE8	; 232
    2628:	b0 e0       	ldi	r27, 0x00	; 0
    262a:	8c 91       	ld	r24, X
    262c:	8b 77       	andi	r24, 0x7B	; 123
    262e:	8c 93       	st	X, r24
    2630:	61 15       	cp	r22, r1
    2632:	71 05       	cpc	r23, r1
    2634:	d9 f6       	brne	.-74     	; 0x25ec <Endpoint_Read_Control_Stream_LE+0x16>
    2636:	06 c0       	rjmp	.+12     	; 0x2644 <Endpoint_Read_Control_Stream_LE+0x6e>
    2638:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>
    263c:	88 23       	and	r24, r24
    263e:	71 f0       	breq	.+28     	; 0x265c <Endpoint_Read_Control_Stream_LE+0x86>
    2640:	85 30       	cpi	r24, 0x05	; 5
    2642:	71 f0       	breq	.+28     	; 0x2660 <Endpoint_Read_Control_Stream_LE+0x8a>
    2644:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
    2648:	80 ff       	sbrs	r24, 0
    264a:	f6 cf       	rjmp	.-20     	; 0x2638 <Endpoint_Read_Control_Stream_LE+0x62>
    264c:	80 e0       	ldi	r24, 0x00	; 0
    264e:	08 95       	ret
    2650:	82 e0       	ldi	r24, 0x02	; 2
    2652:	08 95       	ret
    2654:	83 e0       	ldi	r24, 0x03	; 3
    2656:	08 95       	ret
    2658:	81 e0       	ldi	r24, 0x01	; 1
    265a:	08 95       	ret
    265c:	82 e0       	ldi	r24, 0x02	; 2
    265e:	08 95       	ret
    2660:	83 e0       	ldi	r24, 0x03	; 3
    2662:	08 95       	ret

00002664 <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    2664:	20 91 5b 14 	lds	r18, 0x145B	; 0x80145b <USB_ControlRequest+0x6>
    2668:	30 91 5c 14 	lds	r19, 0x145C	; 0x80145c <USB_ControlRequest+0x7>
    266c:	26 17       	cp	r18, r22
    266e:	37 07       	cpc	r19, r23
    2670:	58 f0       	brcs	.+22     	; 0x2688 <Endpoint_Write_Control_PStream_LE+0x24>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    2672:	61 15       	cp	r22, r1
    2674:	71 05       	cpc	r23, r1
    2676:	39 f4       	brne	.+14     	; 0x2686 <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2678:	e8 ee       	ldi	r30, 0xE8	; 232
    267a:	f0 e0       	ldi	r31, 0x00	; 0
    267c:	20 81       	ld	r18, Z
    267e:	2e 77       	andi	r18, 0x7E	; 126
    2680:	20 83       	st	Z, r18
    2682:	9b 01       	movw	r18, r22
    2684:	01 c0       	rjmp	.+2      	; 0x2688 <Endpoint_Write_Control_PStream_LE+0x24>
    2686:	9b 01       	movw	r18, r22
    2688:	e8 2f       	mov	r30, r24
    268a:	f9 2f       	mov	r31, r25
    268c:	90 e0       	ldi	r25, 0x00	; 0
    268e:	31 c0       	rjmp	.+98     	; 0x26f2 <Endpoint_Write_Control_PStream_LE+0x8e>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2690:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2694:	88 23       	and	r24, r24
    2696:	09 f4       	brne	.+2      	; 0x269a <Endpoint_Write_Control_PStream_LE+0x36>
    2698:	42 c0       	rjmp	.+132    	; 0x271e <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    269a:	85 30       	cpi	r24, 0x05	; 5
    269c:	09 f4       	brne	.+2      	; 0x26a0 <Endpoint_Write_Control_PStream_LE+0x3c>
    269e:	41 c0       	rjmp	.+130    	; 0x2722 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    26a0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    26a4:	83 fd       	sbrc	r24, 3
    26a6:	3f c0       	rjmp	.+126    	; 0x2726 <Endpoint_Write_Control_PStream_LE+0xc2>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    26a8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    26ac:	82 fd       	sbrc	r24, 2
    26ae:	31 c0       	rjmp	.+98     	; 0x2712 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    26b0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  break;

		if (Endpoint_IsINReady())
    26b4:	80 ff       	sbrs	r24, 0
    26b6:	1d c0       	rjmp	.+58     	; 0x26f2 <Endpoint_Write_Control_PStream_LE+0x8e>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    26b8:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__TEXT_REGION_LENGTH__+0x7e00f2>
    26bc:	50 91 f3 00 	lds	r21, 0x00F3	; 0x8000f3 <__TEXT_REGION_LENGTH__+0x7e00f3>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    26c0:	08 c0       	rjmp	.+16     	; 0x26d2 <Endpoint_Write_Control_PStream_LE+0x6e>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    26c2:	84 91       	lpm	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    26c4:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    26c8:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    26ca:	21 50       	subi	r18, 0x01	; 1
    26cc:	31 09       	sbc	r19, r1
				BytesInEndpoint++;
    26ce:	4f 5f       	subi	r20, 0xFF	; 255
    26d0:	5f 4f       	sbci	r21, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    26d2:	21 15       	cp	r18, r1
    26d4:	31 05       	cpc	r19, r1
    26d6:	19 f0       	breq	.+6      	; 0x26de <Endpoint_Write_Control_PStream_LE+0x7a>
    26d8:	48 30       	cpi	r20, 0x08	; 8
    26da:	51 05       	cpc	r21, r1
    26dc:	90 f3       	brcs	.-28     	; 0x26c2 <Endpoint_Write_Control_PStream_LE+0x5e>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    26de:	91 e0       	ldi	r25, 0x01	; 1
    26e0:	48 30       	cpi	r20, 0x08	; 8
    26e2:	51 05       	cpc	r21, r1
    26e4:	09 f0       	breq	.+2      	; 0x26e8 <Endpoint_Write_Control_PStream_LE+0x84>
    26e6:	90 e0       	ldi	r25, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    26e8:	a8 ee       	ldi	r26, 0xE8	; 232
    26ea:	b0 e0       	ldi	r27, 0x00	; 0
    26ec:	8c 91       	ld	r24, X
    26ee:	8e 77       	andi	r24, 0x7E	; 126
    26f0:	8c 93       	st	X, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    26f2:	21 15       	cp	r18, r1
    26f4:	31 05       	cpc	r19, r1
    26f6:	61 f6       	brne	.-104    	; 0x2690 <Endpoint_Write_Control_PStream_LE+0x2c>
    26f8:	91 11       	cpse	r25, r1
    26fa:	ca cf       	rjmp	.-108    	; 0x2690 <Endpoint_Write_Control_PStream_LE+0x2c>
    26fc:	0a c0       	rjmp	.+20     	; 0x2712 <Endpoint_Write_Control_PStream_LE+0xae>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    26fe:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    2702:	88 23       	and	r24, r24
    2704:	91 f0       	breq	.+36     	; 0x272a <Endpoint_Write_Control_PStream_LE+0xc6>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2706:	85 30       	cpi	r24, 0x05	; 5
    2708:	91 f0       	breq	.+36     	; 0x272e <Endpoint_Write_Control_PStream_LE+0xca>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    270a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    270e:	83 fd       	sbrc	r24, 3
    2710:	10 c0       	rjmp	.+32     	; 0x2732 <Endpoint_Write_Control_PStream_LE+0xce>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2712:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2716:	82 ff       	sbrs	r24, 2
    2718:	f2 cf       	rjmp	.-28     	; 0x26fe <Endpoint_Write_Control_PStream_LE+0x9a>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    271a:	80 e0       	ldi	r24, 0x00	; 0
    271c:	08 95       	ret
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    271e:	82 e0       	ldi	r24, 0x02	; 2
    2720:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    2722:	83 e0       	ldi	r24, 0x03	; 3
    2724:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    2726:	81 e0       	ldi	r24, 0x01	; 1
    2728:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    272a:	82 e0       	ldi	r24, 0x02	; 2
    272c:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    272e:	83 e0       	ldi	r24, 0x03	; 3
    2730:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    2732:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2734:	08 95       	ret

00002736 <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    2736:	98 2f       	mov	r25, r24
    2738:	29 c0       	rjmp	.+82     	; 0x278c <Endpoint_ConfigureEndpoint_Prv+0x56>
    273a:	29 2f       	mov	r18, r25
    273c:	2f 70       	andi	r18, 0x0F	; 15
    273e:	20 93 e9 00 	sts	0x00E9, r18	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    2742:	98 17       	cp	r25, r24
    2744:	39 f0       	breq	.+14     	; 0x2754 <Endpoint_ConfigureEndpoint_Prv+0x1e>
    2746:	70 91 ec 00 	lds	r23, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    274a:	20 91 ed 00 	lds	r18, 0x00ED	; 0x8000ed <__TEXT_REGION_LENGTH__+0x7e00ed>
    274e:	50 91 f0 00 	lds	r21, 0x00F0	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    2752:	03 c0       	rjmp	.+6      	; 0x275a <Endpoint_ConfigureEndpoint_Prv+0x24>
    2754:	24 2f       	mov	r18, r20
    2756:	76 2f       	mov	r23, r22
    2758:	50 e0       	ldi	r21, 0x00	; 0
    275a:	21 ff       	sbrs	r18, 1
    275c:	16 c0       	rjmp	.+44     	; 0x278a <Endpoint_ConfigureEndpoint_Prv+0x54>
    275e:	eb ee       	ldi	r30, 0xEB	; 235
    2760:	f0 e0       	ldi	r31, 0x00	; 0
    2762:	30 81       	ld	r19, Z
    2764:	3e 7f       	andi	r19, 0xFE	; 254
    2766:	30 83       	st	Z, r19
    2768:	ad ee       	ldi	r26, 0xED	; 237
    276a:	b0 e0       	ldi	r27, 0x00	; 0
    276c:	3c 91       	ld	r19, X
    276e:	3d 7f       	andi	r19, 0xFD	; 253
    2770:	3c 93       	st	X, r19
    2772:	30 81       	ld	r19, Z
    2774:	31 60       	ori	r19, 0x01	; 1
    2776:	30 83       	st	Z, r19
    2778:	70 93 ec 00 	sts	0x00EC, r23	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    277c:	2c 93       	st	X, r18
    277e:	50 93 f0 00 	sts	0x00F0, r21	; 0x8000f0 <__TEXT_REGION_LENGTH__+0x7e00f0>
    2782:	20 91 ee 00 	lds	r18, 0x00EE	; 0x8000ee <__TEXT_REGION_LENGTH__+0x7e00ee>
    2786:	22 23       	and	r18, r18
    2788:	44 f4       	brge	.+16     	; 0x279a <Endpoint_ConfigureEndpoint_Prv+0x64>
    278a:	9f 5f       	subi	r25, 0xFF	; 255
    278c:	97 30       	cpi	r25, 0x07	; 7
    278e:	a8 f2       	brcs	.-86     	; 0x273a <Endpoint_ConfigureEndpoint_Prv+0x4>
    2790:	8f 70       	andi	r24, 0x0F	; 15
    2792:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	08 95       	ret
    279a:	80 e0       	ldi	r24, 0x00	; 0
    279c:	08 95       	ret

0000279e <Endpoint_ConfigureEndpointTable>:
    279e:	0f 93       	push	r16
    27a0:	1f 93       	push	r17
    27a2:	cf 93       	push	r28
    27a4:	df 93       	push	r29
    27a6:	ec 01       	movw	r28, r24
    27a8:	06 2f       	mov	r16, r22
    27aa:	10 e0       	ldi	r17, 0x00	; 0
    27ac:	36 c0       	rjmp	.+108    	; 0x281a <Endpoint_ConfigureEndpointTable+0x7c>
    27ae:	e1 2f       	mov	r30, r17
    27b0:	f0 e0       	ldi	r31, 0x00	; 0
    27b2:	cf 01       	movw	r24, r30
    27b4:	88 0f       	add	r24, r24
    27b6:	99 1f       	adc	r25, r25
    27b8:	88 0f       	add	r24, r24
    27ba:	99 1f       	adc	r25, r25
    27bc:	e8 0f       	add	r30, r24
    27be:	f9 1f       	adc	r31, r25
    27c0:	ec 0f       	add	r30, r28
    27c2:	fd 1f       	adc	r31, r29
    27c4:	50 81       	ld	r21, Z
    27c6:	55 23       	and	r21, r21
    27c8:	39 f1       	breq	.+78     	; 0x2818 <Endpoint_ConfigureEndpointTable+0x7a>
    27ca:	94 81       	ldd	r25, Z+4	; 0x04
    27cc:	a1 81       	ldd	r26, Z+1	; 0x01
    27ce:	b2 81       	ldd	r27, Z+2	; 0x02
    27d0:	63 81       	ldd	r22, Z+3	; 0x03
    27d2:	85 2f       	mov	r24, r21
    27d4:	8f 70       	andi	r24, 0x0F	; 15
    27d6:	87 30       	cpi	r24, 0x07	; 7
    27d8:	e0 f4       	brcc	.+56     	; 0x2812 <Endpoint_ConfigureEndpointTable+0x74>
    27da:	92 30       	cpi	r25, 0x02	; 2
    27dc:	10 f0       	brcs	.+4      	; 0x27e2 <Endpoint_ConfigureEndpointTable+0x44>
    27de:	46 e0       	ldi	r20, 0x06	; 6
    27e0:	01 c0       	rjmp	.+2      	; 0x27e4 <Endpoint_ConfigureEndpointTable+0x46>
    27e2:	42 e0       	ldi	r20, 0x02	; 2
    27e4:	28 e0       	ldi	r18, 0x08	; 8
    27e6:	30 e0       	ldi	r19, 0x00	; 0
    27e8:	90 e0       	ldi	r25, 0x00	; 0
    27ea:	03 c0       	rjmp	.+6      	; 0x27f2 <Endpoint_ConfigureEndpointTable+0x54>
    27ec:	9f 5f       	subi	r25, 0xFF	; 255
    27ee:	22 0f       	add	r18, r18
    27f0:	33 1f       	adc	r19, r19
    27f2:	2a 17       	cp	r18, r26
    27f4:	3b 07       	cpc	r19, r27
    27f6:	d0 f3       	brcs	.-12     	; 0x27ec <Endpoint_ConfigureEndpointTable+0x4e>
    27f8:	92 95       	swap	r25
    27fa:	90 7f       	andi	r25, 0xF0	; 240
    27fc:	20 e4       	ldi	r18, 0x40	; 64
    27fe:	62 9f       	mul	r22, r18
    2800:	b0 01       	movw	r22, r0
    2802:	11 24       	eor	r1, r1
    2804:	55 1f       	adc	r21, r21
    2806:	55 27       	eor	r21, r21
    2808:	55 1f       	adc	r21, r21
    280a:	49 2b       	or	r20, r25
    280c:	65 2b       	or	r22, r21
    280e:	93 df       	rcall	.-218    	; 0x2736 <Endpoint_ConfigureEndpoint_Prv>
    2810:	01 c0       	rjmp	.+2      	; 0x2814 <Endpoint_ConfigureEndpointTable+0x76>
    2812:	80 e0       	ldi	r24, 0x00	; 0
    2814:	88 23       	and	r24, r24
    2816:	21 f0       	breq	.+8      	; 0x2820 <Endpoint_ConfigureEndpointTable+0x82>
    2818:	1f 5f       	subi	r17, 0xFF	; 255
    281a:	10 17       	cp	r17, r16
    281c:	40 f2       	brcs	.-112    	; 0x27ae <Endpoint_ConfigureEndpointTable+0x10>
    281e:	81 e0       	ldi	r24, 0x01	; 1
    2820:	df 91       	pop	r29
    2822:	cf 91       	pop	r28
    2824:	1f 91       	pop	r17
    2826:	0f 91       	pop	r16
    2828:	08 95       	ret

0000282a <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    282a:	80 91 55 14 	lds	r24, 0x1455	; 0x801455 <USB_ControlRequest>
    282e:	88 23       	and	r24, r24
    2830:	9c f4       	brge	.+38     	; 0x2858 <Endpoint_ClearStatusStage+0x2e>
    2832:	04 c0       	rjmp	.+8      	; 0x283c <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2834:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>
    2838:	88 23       	and	r24, r24
    283a:	b9 f0       	breq	.+46     	; 0x286a <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    283c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    2840:	82 ff       	sbrs	r24, 2
    2842:	f8 cf       	rjmp	.-16     	; 0x2834 <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2844:	e8 ee       	ldi	r30, 0xE8	; 232
    2846:	f0 e0       	ldi	r31, 0x00	; 0
    2848:	80 81       	ld	r24, Z
    284a:	8b 77       	andi	r24, 0x7B	; 123
    284c:	80 83       	st	Z, r24
    284e:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2850:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>
    2854:	88 23       	and	r24, r24
    2856:	49 f0       	breq	.+18     	; 0x286a <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2858:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    285c:	80 ff       	sbrs	r24, 0
    285e:	f8 cf       	rjmp	.-16     	; 0x2850 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2860:	e8 ee       	ldi	r30, 0xE8	; 232
    2862:	f0 e0       	ldi	r31, 0x00	; 0
    2864:	80 81       	ld	r24, Z
    2866:	8e 77       	andi	r24, 0x7E	; 126
    2868:	80 83       	st	Z, r24
    286a:	08 95       	ret

0000286c <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    286c:	20 91 e4 00 	lds	r18, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    2870:	30 91 e5 00 	lds	r19, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    2874:	44 e6       	ldi	r20, 0x64	; 100
    2876:	02 c0       	rjmp	.+4      	; 0x287c <Endpoint_WaitUntilReady+0x10>

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;
    2878:	9c 01       	movw	r18, r24

			if (!(TimeoutMSRem--))
    287a:	45 2f       	mov	r20, r21
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    287c:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    2880:	98 2f       	mov	r25, r24
    2882:	91 70       	andi	r25, 0x01	; 1
    2884:	80 fd       	sbrc	r24, 0
    2886:	90 e8       	ldi	r25, 0x80	; 128

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
    2888:	90 38       	cpi	r25, 0x80	; 128
    288a:	29 f4       	brne	.+10     	; 0x2896 <Endpoint_WaitUntilReady+0x2a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    288c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
		{
			if (Endpoint_IsINReady())
    2890:	80 ff       	sbrs	r24, 0
    2892:	05 c0       	rjmp	.+10     	; 0x289e <Endpoint_WaitUntilReady+0x32>
    2894:	1b c0       	rjmp	.+54     	; 0x28cc <Endpoint_WaitUntilReady+0x60>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2896:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    289a:	82 fd       	sbrc	r24, 2
    289c:	19 c0       	rjmp	.+50     	; 0x28d0 <Endpoint_WaitUntilReady+0x64>
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    289e:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    28a2:	88 23       	and	r24, r24
    28a4:	b9 f0       	breq	.+46     	; 0x28d4 <Endpoint_WaitUntilReady+0x68>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    28a6:	85 30       	cpi	r24, 0x05	; 5
    28a8:	b9 f0       	breq	.+46     	; 0x28d8 <Endpoint_WaitUntilReady+0x6c>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    28aa:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    28ae:	85 fd       	sbrc	r24, 5
    28b0:	15 c0       	rjmp	.+42     	; 0x28dc <Endpoint_WaitUntilReady+0x70>
    28b2:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <__TEXT_REGION_LENGTH__+0x7e00e4>
    28b6:	90 91 e5 00 	lds	r25, 0x00E5	; 0x8000e5 <__TEXT_REGION_LENGTH__+0x7e00e5>
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    28ba:	28 17       	cp	r18, r24
    28bc:	39 07       	cpc	r19, r25
    28be:	f1 f2       	breq	.-68     	; 0x287c <Endpoint_WaitUntilReady+0x10>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    28c0:	5f ef       	ldi	r21, 0xFF	; 255
    28c2:	54 0f       	add	r21, r20
    28c4:	41 11       	cpse	r20, r1
    28c6:	d8 cf       	rjmp	.-80     	; 0x2878 <Endpoint_WaitUntilReady+0xc>
			  return ENDPOINT_READYWAIT_Timeout;
    28c8:	84 e0       	ldi	r24, 0x04	; 4
    28ca:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    28cc:	80 e0       	ldi	r24, 0x00	; 0
    28ce:	08 95       	ret
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    28d0:	80 e0       	ldi	r24, 0x00	; 0
    28d2:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    28d4:	82 e0       	ldi	r24, 0x02	; 2
    28d6:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    28d8:	83 e0       	ldi	r24, 0x03	; 3
    28da:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    28dc:	81 e0       	ldi	r24, 0x01	; 1

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    28de:	08 95       	ret

000028e0 <USB_Init_Device>:

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
    28e0:	cf 93       	push	r28
    28e2:	df 93       	push	r29
    28e4:	10 92 54 14 	sts	0x1454, r1	; 0x801454 <USB_DeviceState>
    28e8:	10 92 50 14 	sts	0x1450, r1	; 0x801450 <USB_Device_ConfigurationNumber>
    28ec:	10 92 52 14 	sts	0x1452, r1	; 0x801452 <USB_Device_RemoteWakeupEnabled>
    28f0:	10 92 51 14 	sts	0x1451, r1	; 0x801451 <USB_Device_CurrentlySelfPowered>
    28f4:	c0 ee       	ldi	r28, 0xE0	; 224
    28f6:	d0 e0       	ldi	r29, 0x00	; 0
    28f8:	88 81       	ld	r24, Y
    28fa:	8b 7f       	andi	r24, 0xFB	; 251
    28fc:	88 83       	st	Y, r24
    28fe:	e8 ed       	ldi	r30, 0xD8	; 216
    2900:	f0 e0       	ldi	r31, 0x00	; 0
    2902:	80 81       	ld	r24, Z
    2904:	81 60       	ori	r24, 0x01	; 1
    2906:	80 83       	st	Z, r24
    2908:	42 e0       	ldi	r20, 0x02	; 2
    290a:	60 e0       	ldi	r22, 0x00	; 0
    290c:	80 e0       	ldi	r24, 0x00	; 0
    290e:	13 df       	rcall	.-474    	; 0x2736 <Endpoint_ConfigureEndpoint_Prv>
    2910:	e1 ee       	ldi	r30, 0xE1	; 225
    2912:	f0 e0       	ldi	r31, 0x00	; 0
    2914:	80 81       	ld	r24, Z
    2916:	8e 7f       	andi	r24, 0xFE	; 254
    2918:	80 83       	st	Z, r24
    291a:	e2 ee       	ldi	r30, 0xE2	; 226
    291c:	f0 e0       	ldi	r31, 0x00	; 0
    291e:	80 81       	ld	r24, Z
    2920:	81 60       	ori	r24, 0x01	; 1
    2922:	80 83       	st	Z, r24
    2924:	80 81       	ld	r24, Z
    2926:	88 60       	ori	r24, 0x08	; 8
    2928:	80 83       	st	Z, r24
    292a:	88 81       	ld	r24, Y
    292c:	8e 7f       	andi	r24, 0xFE	; 254
    292e:	88 83       	st	Y, r24
    2930:	df 91       	pop	r29
    2932:	cf 91       	pop	r28
    2934:	08 95       	ret

00002936 <USB_ResetInterface>:
}

void USB_ResetInterface(void)
{
    2936:	cf 93       	push	r28
    2938:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    293a:	28 d0       	rcall	.+80     	; 0x298c <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    293c:	2f d0       	rcall	.+94     	; 0x299c <USB_INT_ClearAllInterrupts>
    293e:	c8 ed       	ldi	r28, 0xD8	; 216
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    2940:	d0 e0       	ldi	r29, 0x00	; 0
    2942:	88 81       	ld	r24, Y
    2944:	8f 77       	andi	r24, 0x7F	; 127
    2946:	88 83       	st	Y, r24
    2948:	88 81       	ld	r24, Y
				USBCON |=  (1 << USBE);
    294a:	80 68       	ori	r24, 0x80	; 128
    294c:	88 83       	st	Y, r24
    294e:	88 81       	ld	r24, Y
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    2950:	8f 7d       	andi	r24, 0xDF	; 223
    2952:	88 83       	st	Y, r24
    2954:	e7 ed       	ldi	r30, 0xD7	; 215

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    2956:	f0 e0       	ldi	r31, 0x00	; 0
    2958:	80 81       	ld	r24, Z
    295a:	80 68       	ori	r24, 0x80	; 128
    295c:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    295e:	19 bc       	out	0x29, r1	; 41
			#else
			USB_PLL_Off();
			#endif
		}

		USB_Init_Device();
    2960:	bf df       	rcall	.-130    	; 0x28e0 <USB_Init_Device>
    2962:	88 81       	ld	r24, Y

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    2964:	80 61       	ori	r24, 0x10	; 16
    2966:	88 83       	st	Y, r24
    2968:	df 91       	pop	r29
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    296a:	cf 91       	pop	r28
    296c:	08 95       	ret

0000296e <USB_Init>:
    296e:	e8 ed       	ldi	r30, 0xD8	; 216
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    2970:	f0 e0       	ldi	r31, 0x00	; 0
    2972:	80 81       	ld	r24, Z
    2974:	8f 7e       	andi	r24, 0xEF	; 239
    2976:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    2978:	e7 ed       	ldi	r30, 0xD7	; 215
    297a:	f0 e0       	ldi	r31, 0x00	; 0
    297c:	80 81       	ld	r24, Z
    297e:	81 60       	ori	r24, 0x01	; 1
    2980:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    2982:	81 e0       	ldi	r24, 0x01	; 1
    2984:	80 93 53 14 	sts	0x1453, r24	; 0x801453 <USB_IsInitialized>

	USB_ResetInterface();
    2988:	d6 cf       	rjmp	.-84     	; 0x2936 <USB_ResetInterface>
    298a:	08 95       	ret

0000298c <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    298c:	e8 ed       	ldi	r30, 0xD8	; 216
    298e:	f0 e0       	ldi	r31, 0x00	; 0
    2990:	80 81       	ld	r24, Z
    2992:	8c 7f       	andi	r24, 0xFC	; 252
    2994:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    2996:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    299a:	08 95       	ret

0000299c <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    299c:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    29a0:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
    29a4:	08 95       	ret

000029a6 <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    29a6:	1f 92       	push	r1
    29a8:	0f 92       	push	r0
    29aa:	0f b6       	in	r0, 0x3f	; 63
    29ac:	0f 92       	push	r0
    29ae:	11 24       	eor	r1, r1
    29b0:	0b b6       	in	r0, 0x3b	; 59
    29b2:	0f 92       	push	r0
    29b4:	2f 93       	push	r18
    29b6:	3f 93       	push	r19
    29b8:	4f 93       	push	r20
    29ba:	5f 93       	push	r21
    29bc:	6f 93       	push	r22
    29be:	7f 93       	push	r23
    29c0:	8f 93       	push	r24
    29c2:	9f 93       	push	r25
    29c4:	af 93       	push	r26
    29c6:	bf 93       	push	r27
    29c8:	ef 93       	push	r30
    29ca:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    29cc:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    29d0:	82 ff       	sbrs	r24, 2
    29d2:	0a c0       	rjmp	.+20     	; 0x29e8 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    29d4:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    29d8:	82 ff       	sbrs	r24, 2
    29da:	06 c0       	rjmp	.+12     	; 0x29e8 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    29dc:	e1 ee       	ldi	r30, 0xE1	; 225
    29de:	f0 e0       	ldi	r31, 0x00	; 0
    29e0:	80 81       	ld	r24, Z
    29e2:	8b 7f       	andi	r24, 0xFB	; 251
    29e4:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    29e6:	49 d2       	rcall	.+1170   	; 0x2e7a <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    29e8:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__TEXT_REGION_LENGTH__+0x7e00da>
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    29ec:	80 ff       	sbrs	r24, 0
    29ee:	1f c0       	rjmp	.+62     	; 0x2a2e <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    29f0:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__TEXT_REGION_LENGTH__+0x7e00d8>
    29f4:	80 ff       	sbrs	r24, 0
    29f6:	1b c0       	rjmp	.+54     	; 0x2a2e <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    29f8:	ea ed       	ldi	r30, 0xDA	; 218
    29fa:	f0 e0       	ldi	r31, 0x00	; 0
    29fc:	80 81       	ld	r24, Z
    29fe:	8e 7f       	andi	r24, 0xFE	; 254
    2a00:	80 83       	st	Z, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    2a02:	80 91 d9 00 	lds	r24, 0x00D9	; 0x8000d9 <__TEXT_REGION_LENGTH__+0x7e00d9>
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    2a06:	80 ff       	sbrs	r24, 0
    2a08:	0d c0       	rjmp	.+26     	; 0x2a24 <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2a0a:	84 e1       	ldi	r24, 0x14	; 20
    2a0c:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    2a0e:	86 e1       	ldi	r24, 0x16	; 22
    2a10:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    2a12:	09 b4       	in	r0, 0x29	; 41
    2a14:	00 fe       	sbrs	r0, 0
    2a16:	fd cf       	rjmp	.-6      	; 0x2a12 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    2a18:	81 e0       	ldi	r24, 0x01	; 1
    2a1a:	80 93 54 14 	sts	0x1454, r24	; 0x801454 <USB_DeviceState>
			EVENT_USB_Device_Connect();
    2a1e:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <EVENT_USB_Device_Connect>
    2a22:	05 c0       	rjmp	.+10     	; 0x2a2e <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2a24:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    2a26:	10 92 54 14 	sts	0x1454, r1	; 0x801454 <USB_DeviceState>
			EVENT_USB_Device_Disconnect();
    2a2a:	0e 94 ef 0c 	call	0x19de	; 0x19de <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    2a2e:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    2a32:	80 ff       	sbrs	r24, 0
    2a34:	16 c0       	rjmp	.+44     	; 0x2a62 <__vector_10+0xbc>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    2a36:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    2a3a:	80 ff       	sbrs	r24, 0
    2a3c:	12 c0       	rjmp	.+36     	; 0x2a62 <__vector_10+0xbc>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    2a3e:	e2 ee       	ldi	r30, 0xE2	; 226
    2a40:	f0 e0       	ldi	r31, 0x00	; 0
    2a42:	80 81       	ld	r24, Z
    2a44:	8e 7f       	andi	r24, 0xFE	; 254
    2a46:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    2a48:	80 81       	ld	r24, Z
    2a4a:	80 61       	ori	r24, 0x10	; 16
    2a4c:	80 83       	st	Z, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    2a4e:	e8 ed       	ldi	r30, 0xD8	; 216
    2a50:	f0 e0       	ldi	r31, 0x00	; 0
    2a52:	80 81       	ld	r24, Z
    2a54:	80 62       	ori	r24, 0x20	; 32
    2a56:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2a58:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    2a5a:	85 e0       	ldi	r24, 0x05	; 5
    2a5c:	80 93 54 14 	sts	0x1454, r24	; 0x801454 <USB_DeviceState>
		EVENT_USB_Device_Suspend();
    2a60:	0c d2       	rcall	.+1048   	; 0x2e7a <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    2a62:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    2a66:	84 ff       	sbrs	r24, 4
    2a68:	2f c0       	rjmp	.+94     	; 0x2ac8 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    2a6a:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    2a6e:	84 ff       	sbrs	r24, 4
    2a70:	2b c0       	rjmp	.+86     	; 0x2ac8 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2a72:	84 e1       	ldi	r24, 0x14	; 20
    2a74:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    2a76:	86 e1       	ldi	r24, 0x16	; 22
    2a78:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    2a7a:	09 b4       	in	r0, 0x29	; 41
    2a7c:	00 fe       	sbrs	r0, 0
    2a7e:	fd cf       	rjmp	.-6      	; 0x2a7a <__vector_10+0xd4>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    2a80:	e8 ed       	ldi	r30, 0xD8	; 216
    2a82:	f0 e0       	ldi	r31, 0x00	; 0
    2a84:	80 81       	ld	r24, Z
    2a86:	8f 7d       	andi	r24, 0xDF	; 223
    2a88:	80 83       	st	Z, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    2a8a:	e1 ee       	ldi	r30, 0xE1	; 225
    2a8c:	f0 e0       	ldi	r31, 0x00	; 0
    2a8e:	80 81       	ld	r24, Z
    2a90:	8f 7e       	andi	r24, 0xEF	; 239
    2a92:	80 83       	st	Z, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    2a94:	e2 ee       	ldi	r30, 0xE2	; 226
    2a96:	f0 e0       	ldi	r31, 0x00	; 0
    2a98:	80 81       	ld	r24, Z
    2a9a:	8f 7e       	andi	r24, 0xEF	; 239
    2a9c:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    2a9e:	80 81       	ld	r24, Z
    2aa0:	81 60       	ori	r24, 0x01	; 1
    2aa2:	80 83       	st	Z, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    2aa4:	80 91 50 14 	lds	r24, 0x1450	; 0x801450 <USB_Device_ConfigurationNumber>
    2aa8:	88 23       	and	r24, r24
    2aaa:	21 f0       	breq	.+8      	; 0x2ab4 <__vector_10+0x10e>
		  USB_DeviceState = DEVICE_STATE_Configured;
    2aac:	84 e0       	ldi	r24, 0x04	; 4
    2aae:	80 93 54 14 	sts	0x1454, r24	; 0x801454 <USB_DeviceState>
    2ab2:	09 c0       	rjmp	.+18     	; 0x2ac6 <__vector_10+0x120>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2ab4:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    2ab8:	88 23       	and	r24, r24
    2aba:	14 f4       	brge	.+4      	; 0x2ac0 <__vector_10+0x11a>
    2abc:	83 e0       	ldi	r24, 0x03	; 3
    2abe:	01 c0       	rjmp	.+2      	; 0x2ac2 <__vector_10+0x11c>
    2ac0:	81 e0       	ldi	r24, 0x01	; 1
    2ac2:	80 93 54 14 	sts	0x1454, r24	; 0x801454 <USB_DeviceState>

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    2ac6:	d9 d1       	rcall	.+946    	; 0x2e7a <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    2ac8:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__TEXT_REGION_LENGTH__+0x7e00e1>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    2acc:	83 ff       	sbrs	r24, 3
    2ace:	1e c0       	rjmp	.+60     	; 0x2b0c <__vector_10+0x166>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    2ad0:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__TEXT_REGION_LENGTH__+0x7e00e2>
    2ad4:	83 ff       	sbrs	r24, 3
    2ad6:	1a c0       	rjmp	.+52     	; 0x2b0c <__vector_10+0x166>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    2ad8:	e1 ee       	ldi	r30, 0xE1	; 225
    2ada:	f0 e0       	ldi	r31, 0x00	; 0
    2adc:	80 81       	ld	r24, Z
    2ade:	87 7f       	andi	r24, 0xF7	; 247
    2ae0:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    2ae2:	82 e0       	ldi	r24, 0x02	; 2
    2ae4:	80 93 54 14 	sts	0x1454, r24	; 0x801454 <USB_DeviceState>
		USB_Device_ConfigurationNumber = 0;
    2ae8:	10 92 50 14 	sts	0x1450, r1	; 0x801450 <USB_Device_ConfigurationNumber>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    2aec:	80 81       	ld	r24, Z
    2aee:	8e 7f       	andi	r24, 0xFE	; 254
    2af0:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    2af2:	e2 ee       	ldi	r30, 0xE2	; 226
    2af4:	f0 e0       	ldi	r31, 0x00	; 0
    2af6:	80 81       	ld	r24, Z
    2af8:	8e 7f       	andi	r24, 0xFE	; 254
    2afa:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    2afc:	80 81       	ld	r24, Z
    2afe:	80 61       	ori	r24, 0x10	; 16
    2b00:	80 83       	st	Z, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    2b02:	42 e0       	ldi	r20, 0x02	; 2
    2b04:	60 e0       	ldi	r22, 0x00	; 0
    2b06:	80 e0       	ldi	r24, 0x00	; 0

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    2b08:	16 de       	rcall	.-980    	; 0x2736 <Endpoint_ConfigureEndpoint_Prv>
    2b0a:	b7 d1       	rcall	.+878    	; 0x2e7a <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    2b0c:	ff 91       	pop	r31
    2b0e:	ef 91       	pop	r30
    2b10:	bf 91       	pop	r27
    2b12:	af 91       	pop	r26
    2b14:	9f 91       	pop	r25
    2b16:	8f 91       	pop	r24
    2b18:	7f 91       	pop	r23
    2b1a:	6f 91       	pop	r22
    2b1c:	5f 91       	pop	r21
    2b1e:	4f 91       	pop	r20
    2b20:	3f 91       	pop	r19
    2b22:	2f 91       	pop	r18
    2b24:	0f 90       	pop	r0
    2b26:	0b be       	out	0x3b, r0	; 59
    2b28:	0f 90       	pop	r0
    2b2a:	0f be       	out	0x3f, r0	; 63
    2b2c:	0f 90       	pop	r0
    2b2e:	1f 90       	pop	r1
    2b30:	18 95       	reti

00002b32 <USB_Device_GetStatus>:

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;

	switch (USB_ControlRequest.bmRequestType)
    2b32:	80 91 55 14 	lds	r24, 0x1455	; 0x801455 <USB_ControlRequest>
    2b36:	80 38       	cpi	r24, 0x80	; 128
    2b38:	19 f0       	breq	.+6      	; 0x2b40 <USB_Device_GetStatus+0xe>
    2b3a:	82 38       	cpi	r24, 0x82	; 130
    2b3c:	71 f0       	breq	.+28     	; 0x2b5a <USB_Device_GetStatus+0x28>
    2b3e:	08 95       	ret
	{
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE):
		{
			#if !defined(NO_DEVICE_SELF_POWER)
			if (USB_Device_CurrentlySelfPowered)
    2b40:	80 91 51 14 	lds	r24, 0x1451	; 0x801451 <USB_Device_CurrentlySelfPowered>
    2b44:	81 11       	cpse	r24, r1
    2b46:	02 c0       	rjmp	.+4      	; 0x2b4c <USB_Device_GetStatus+0x1a>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    2b48:	90 e0       	ldi	r25, 0x00	; 0
    2b4a:	01 c0       	rjmp	.+2      	; 0x2b4e <USB_Device_GetStatus+0x1c>
	{
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE):
		{
			#if !defined(NO_DEVICE_SELF_POWER)
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
    2b4c:	91 e0       	ldi	r25, 0x01	; 1
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    2b4e:	80 91 52 14 	lds	r24, 0x1452	; 0x801452 <USB_Device_RemoteWakeupEnabled>
    2b52:	88 23       	and	r24, r24
    2b54:	81 f0       	breq	.+32     	; 0x2b76 <USB_Device_GetStatus+0x44>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    2b56:	92 60       	ori	r25, 0x02	; 2
    2b58:	0e c0       	rjmp	.+28     	; 0x2b76 <USB_Device_GetStatus+0x44>
			break;
		}
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
		{
			#if !defined(CONTROL_ONLY_DEVICE)
			uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2b5a:	80 91 59 14 	lds	r24, 0x1459	; 0x801459 <USB_ControlRequest+0x4>
    2b5e:	8f 70       	andi	r24, 0x0F	; 15

			if (EndpointIndex >= ENDPOINT_TOTAL_ENDPOINTS)
    2b60:	87 30       	cpi	r24, 0x07	; 7
    2b62:	b0 f4       	brcc	.+44     	; 0x2b90 <USB_Device_GetStatus+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2b64:	e9 ee       	ldi	r30, 0xE9	; 233
    2b66:	f0 e0       	ldi	r31, 0x00	; 0
    2b68:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2b6a:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
    2b6e:	95 fb       	bst	r25, 5
    2b70:	99 27       	eor	r25, r25
    2b72:	90 f9       	bld	r25, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2b74:	10 82       	st	Z, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2b76:	e8 ee       	ldi	r30, 0xE8	; 232
    2b78:	f0 e0       	ldi	r31, 0x00	; 0
    2b7a:	80 81       	ld	r24, Z
    2b7c:	87 7f       	andi	r24, 0xF7	; 247
    2b7e:	80 83       	st	Z, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    2b80:	a1 ef       	ldi	r26, 0xF1	; 241
    2b82:	b0 e0       	ldi	r27, 0x00	; 0
    2b84:	9c 93       	st	X, r25
				UEDATX = (Data >> 8);
    2b86:	1c 92       	st	X, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2b88:	80 81       	ld	r24, Z
    2b8a:	8e 77       	andi	r24, 0x7E	; 126
    2b8c:	80 83       	st	Z, r24
	Endpoint_ClearSETUP();

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2b8e:	4d ce       	rjmp	.-870    	; 0x282a <Endpoint_ClearStatusStage>
    2b90:	08 95       	ret

00002b92 <USB_Device_ClearSetFeature>:
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    2b92:	80 91 55 14 	lds	r24, 0x1455	; 0x801455 <USB_ControlRequest>
    2b96:	8f 71       	andi	r24, 0x1F	; 31
    2b98:	19 f0       	breq	.+6      	; 0x2ba0 <USB_Device_ClearSetFeature+0xe>
    2b9a:	82 30       	cpi	r24, 0x02	; 2
    2b9c:	71 f0       	breq	.+28     	; 0x2bba <USB_Device_ClearSetFeature+0x28>
    2b9e:	08 95       	ret
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
		{
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    2ba0:	80 91 57 14 	lds	r24, 0x1457	; 0x801457 <USB_ControlRequest+0x2>
    2ba4:	81 30       	cpi	r24, 0x01	; 1
    2ba6:	09 f0       	breq	.+2      	; 0x2baa <USB_Device_ClearSetFeature+0x18>
    2ba8:	3f c0       	rjmp	.+126    	; 0x2c28 <USB_Device_ClearSetFeature+0x96>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    2baa:	90 91 56 14 	lds	r25, 0x1456	; 0x801456 <USB_ControlRequest+0x1>
    2bae:	93 30       	cpi	r25, 0x03	; 3
    2bb0:	09 f0       	breq	.+2      	; 0x2bb4 <USB_Device_ClearSetFeature+0x22>
    2bb2:	80 e0       	ldi	r24, 0x00	; 0
    2bb4:	80 93 52 14 	sts	0x1452, r24	; 0x801452 <USB_Device_RemoteWakeupEnabled>
			else
			  return;

			break;
    2bb8:	2f c0       	rjmp	.+94     	; 0x2c18 <USB_Device_ClearSetFeature+0x86>
		}
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
		{
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    2bba:	80 91 57 14 	lds	r24, 0x1457	; 0x801457 <USB_ControlRequest+0x2>
    2bbe:	81 11       	cpse	r24, r1
    2bc0:	2b c0       	rjmp	.+86     	; 0x2c18 <USB_Device_ClearSetFeature+0x86>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2bc2:	80 91 59 14 	lds	r24, 0x1459	; 0x801459 <USB_ControlRequest+0x4>
    2bc6:	8f 70       	andi	r24, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP || EndpointIndex >= ENDPOINT_TOTAL_ENDPOINTS)
    2bc8:	9f ef       	ldi	r25, 0xFF	; 255
    2bca:	98 0f       	add	r25, r24
    2bcc:	96 30       	cpi	r25, 0x06	; 6
    2bce:	60 f5       	brcc	.+88     	; 0x2c28 <USB_Device_ClearSetFeature+0x96>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2bd0:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    2bd4:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__TEXT_REGION_LENGTH__+0x7e00eb>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    2bd8:	90 ff       	sbrs	r25, 0
    2bda:	1e c0       	rjmp	.+60     	; 0x2c18 <USB_Device_ClearSetFeature+0x86>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    2bdc:	90 91 56 14 	lds	r25, 0x1456	; 0x801456 <USB_ControlRequest+0x1>
    2be0:	93 30       	cpi	r25, 0x03	; 3
    2be2:	31 f4       	brne	.+12     	; 0x2bf0 <USB_Device_ClearSetFeature+0x5e>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2be4:	eb ee       	ldi	r30, 0xEB	; 235
    2be6:	f0 e0       	ldi	r31, 0x00	; 0
    2be8:	80 81       	ld	r24, Z
    2bea:	80 62       	ori	r24, 0x20	; 32
    2bec:	80 83       	st	Z, r24
    2bee:	14 c0       	rjmp	.+40     	; 0x2c18 <USB_Device_ClearSetFeature+0x86>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    2bf0:	eb ee       	ldi	r30, 0xEB	; 235
    2bf2:	f0 e0       	ldi	r31, 0x00	; 0
    2bf4:	90 81       	ld	r25, Z
    2bf6:	90 61       	ori	r25, 0x10	; 16
    2bf8:	90 83       	st	Z, r25
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    2bfa:	21 e0       	ldi	r18, 0x01	; 1
    2bfc:	30 e0       	ldi	r19, 0x00	; 0
    2bfe:	a9 01       	movw	r20, r18
    2c00:	02 c0       	rjmp	.+4      	; 0x2c06 <USB_Device_ClearSetFeature+0x74>
    2c02:	44 0f       	add	r20, r20
    2c04:	55 1f       	adc	r21, r21
    2c06:	8a 95       	dec	r24
    2c08:	e2 f7       	brpl	.-8      	; 0x2c02 <USB_Device_ClearSetFeature+0x70>
    2c0a:	aa ee       	ldi	r26, 0xEA	; 234
    2c0c:	b0 e0       	ldi	r27, 0x00	; 0
    2c0e:	4c 93       	st	X, r20
				UERST = 0;
    2c10:	1c 92       	st	X, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2c12:	80 81       	ld	r24, Z
    2c14:	88 60       	ori	r24, 0x08	; 8
    2c16:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2c18:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2c1c:	e8 ee       	ldi	r30, 0xE8	; 232
    2c1e:	f0 e0       	ldi	r31, 0x00	; 0
    2c20:	80 81       	ld	r24, Z
    2c22:	87 7f       	andi	r24, 0xF7	; 247
    2c24:	80 83       	st	Z, r24

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    2c26:	01 ce       	rjmp	.-1022   	; 0x282a <Endpoint_ClearStatusStage>
    2c28:	08 95       	ret

00002c2a <USB_Device_SetAddress>:
		Endpoint_StallTransaction();
	}
}

static void USB_Device_SetAddress(void)
{
    2c2a:	cf 93       	push	r28
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    2c2c:	c0 91 57 14 	lds	r28, 0x1457	; 0x801457 <USB_ControlRequest+0x2>
    2c30:	cf 77       	andi	r28, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2c32:	e3 ee       	ldi	r30, 0xE3	; 227
    2c34:	f0 e0       	ldi	r31, 0x00	; 0
    2c36:	80 81       	ld	r24, Z
    2c38:	80 78       	andi	r24, 0x80	; 128
    2c3a:	8c 2b       	or	r24, r28
    2c3c:	80 83       	st	Z, r24
    2c3e:	e8 ee       	ldi	r30, 0xE8	; 232
    2c40:	f0 e0       	ldi	r31, 0x00	; 0
    2c42:	80 81       	ld	r24, Z
    2c44:	87 7f       	andi	r24, 0xF7	; 247
    2c46:	80 83       	st	Z, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    2c48:	f0 dd       	rcall	.-1056   	; 0x282a <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2c4a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	while (!(Endpoint_IsINReady()));
    2c4e:	80 ff       	sbrs	r24, 0
    2c50:	fc cf       	rjmp	.-8      	; 0x2c4a <USB_Device_SetAddress+0x20>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    2c52:	e3 ee       	ldi	r30, 0xE3	; 227
    2c54:	f0 e0       	ldi	r31, 0x00	; 0
    2c56:	80 81       	ld	r24, Z
    2c58:	80 68       	ori	r24, 0x80	; 128
    2c5a:	80 83       	st	Z, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2c5c:	cc 23       	and	r28, r28
    2c5e:	11 f0       	breq	.+4      	; 0x2c64 <USB_Device_SetAddress+0x3a>
    2c60:	83 e0       	ldi	r24, 0x03	; 3
    2c62:	01 c0       	rjmp	.+2      	; 0x2c66 <USB_Device_SetAddress+0x3c>
    2c64:	82 e0       	ldi	r24, 0x02	; 2
    2c66:	80 93 54 14 	sts	0x1454, r24	; 0x801454 <USB_DeviceState>
}
    2c6a:	cf 91       	pop	r28
    2c6c:	08 95       	ret

00002c6e <USB_Device_GetConfiguration>:
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2c6e:	e8 ee       	ldi	r30, 0xE8	; 232
    2c70:	f0 e0       	ldi	r31, 0x00	; 0
    2c72:	80 81       	ld	r24, Z
    2c74:	87 7f       	andi	r24, 0xF7	; 247
    2c76:	80 83       	st	Z, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2c78:	80 91 50 14 	lds	r24, 0x1450	; 0x801450 <USB_Device_ConfigurationNumber>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2c7c:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2c80:	80 81       	ld	r24, Z
    2c82:	8e 77       	andi	r24, 0x7E	; 126
    2c84:	80 83       	st	Z, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2c86:	d1 cd       	rjmp	.-1118   	; 0x282a <Endpoint_ClearStatusStage>
    2c88:	08 95       	ret

00002c8a <USB_Device_GetInternalSerialDescriptor>:
}

#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
static void USB_Device_GetInternalSerialDescriptor(void)
{
    2c8a:	0f 93       	push	r16
    2c8c:	1f 93       	push	r17
    2c8e:	cf 93       	push	r28
    2c90:	df 93       	push	r29
    2c92:	cd b7       	in	r28, 0x3d	; 61
    2c94:	de b7       	in	r29, 0x3e	; 62
    2c96:	aa 97       	sbiw	r28, 0x2a	; 42
    2c98:	0f b6       	in	r0, 0x3f	; 63
    2c9a:	f8 94       	cli
    2c9c:	de bf       	out	0x3e, r29	; 62
    2c9e:	0f be       	out	0x3f, r0	; 63
    2ca0:	cd bf       	out	0x3d, r28	; 61
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    2ca2:	83 e0       	ldi	r24, 0x03	; 3
    2ca4:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    2ca6:	8a e2       	ldi	r24, 0x2A	; 42
    2ca8:	89 83       	std	Y+1, r24	; 0x01
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2caa:	3f b7       	in	r19, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2cac:	f8 94       	cli
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    2cae:	90 e0       	ldi	r25, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    2cb0:	2e e0       	ldi	r18, 0x0E	; 14
    2cb2:	20 c0       	rjmp	.+64     	; 0x2cf4 <USB_Device_GetInternalSerialDescriptor+0x6a>

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    2cb4:	e2 2f       	mov	r30, r18
    2cb6:	f0 e0       	ldi	r31, 0x00	; 0
    2cb8:	81 e2       	ldi	r24, 0x21	; 33
    2cba:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    2cbe:	e4 91       	lpm	r30, Z

					if (SerialCharNum & 0x01)
    2cc0:	90 ff       	sbrs	r25, 0
    2cc2:	03 c0       	rjmp	.+6      	; 0x2cca <USB_Device_GetInternalSerialDescriptor+0x40>
					{
						SerialByte >>= 4;
    2cc4:	e2 95       	swap	r30
    2cc6:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    2cc8:	2f 5f       	subi	r18, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    2cca:	ef 70       	andi	r30, 0x0F	; 15

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    2ccc:	a9 2f       	mov	r26, r25
    2cce:	b0 e0       	ldi	r27, 0x00	; 0
    2cd0:	aa 0f       	add	r26, r26
    2cd2:	bb 1f       	adc	r27, r27
    2cd4:	43 e0       	ldi	r20, 0x03	; 3
    2cd6:	50 e0       	ldi	r21, 0x00	; 0
    2cd8:	4c 0f       	add	r20, r28
    2cda:	5d 1f       	adc	r21, r29
    2cdc:	a4 0f       	add	r26, r20
    2cde:	b5 1f       	adc	r27, r21
    2ce0:	ea 30       	cpi	r30, 0x0A	; 10
    2ce2:	18 f0       	brcs	.+6      	; 0x2cea <USB_Device_GetInternalSerialDescriptor+0x60>
    2ce4:	f0 e0       	ldi	r31, 0x00	; 0
    2ce6:	f7 96       	adiw	r30, 0x37	; 55
    2ce8:	02 c0       	rjmp	.+4      	; 0x2cee <USB_Device_GetInternalSerialDescriptor+0x64>
    2cea:	f0 e0       	ldi	r31, 0x00	; 0
    2cec:	f0 96       	adiw	r30, 0x30	; 48
    2cee:	ed 93       	st	X+, r30
    2cf0:	fc 93       	st	X, r31
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    2cf2:	9f 5f       	subi	r25, 0xFF	; 255
    2cf4:	94 31       	cpi	r25, 0x14	; 20
    2cf6:	f0 f2       	brcs	.-68     	; 0x2cb4 <USB_Device_GetInternalSerialDescriptor+0x2a>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2cf8:	3f bf       	out	0x3f, r19	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2cfa:	08 ee       	ldi	r16, 0xE8	; 232
    2cfc:	10 e0       	ldi	r17, 0x00	; 0
    2cfe:	f8 01       	movw	r30, r16
    2d00:	80 81       	ld	r24, Z
    2d02:	87 7f       	andi	r24, 0xF7	; 247
    2d04:	80 83       	st	Z, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    2d06:	6a e2       	ldi	r22, 0x2A	; 42
    2d08:	70 e0       	ldi	r23, 0x00	; 0
    2d0a:	ce 01       	movw	r24, r28
    2d0c:	01 96       	adiw	r24, 0x01	; 1
    2d0e:	fb db       	rcall	.-2058   	; 0x2506 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2d10:	f8 01       	movw	r30, r16
    2d12:	80 81       	ld	r24, Z
    2d14:	8b 77       	andi	r24, 0x7B	; 123
    2d16:	80 83       	st	Z, r24
	Endpoint_ClearOUT();
}
    2d18:	aa 96       	adiw	r28, 0x2a	; 42
    2d1a:	0f b6       	in	r0, 0x3f	; 63
    2d1c:	f8 94       	cli
    2d1e:	de bf       	out	0x3e, r29	; 62
    2d20:	0f be       	out	0x3f, r0	; 63
    2d22:	cd bf       	out	0x3d, r28	; 61
    2d24:	df 91       	pop	r29
    2d26:	cf 91       	pop	r28
    2d28:	1f 91       	pop	r17
    2d2a:	0f 91       	pop	r16
    2d2c:	08 95       	ret

00002d2e <USB_Device_GetDescriptor>:
#endif

static void USB_Device_GetDescriptor(void)
{
    2d2e:	0f 93       	push	r16
    2d30:	1f 93       	push	r17
    2d32:	cf 93       	push	r28
    2d34:	df 93       	push	r29
    2d36:	00 d0       	rcall	.+0      	; 0x2d38 <USB_Device_GetDescriptor+0xa>
    2d38:	cd b7       	in	r28, 0x3d	; 61
    2d3a:	de b7       	in	r29, 0x3e	; 62
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    2d3c:	80 91 57 14 	lds	r24, 0x1457	; 0x801457 <USB_ControlRequest+0x2>
    2d40:	90 91 58 14 	lds	r25, 0x1458	; 0x801458 <USB_ControlRequest+0x3>
    2d44:	8c 3d       	cpi	r24, 0xDC	; 220
    2d46:	23 e0       	ldi	r18, 0x03	; 3
    2d48:	92 07       	cpc	r25, r18
    2d4a:	11 f4       	brne	.+4      	; 0x2d50 <USB_Device_GetDescriptor+0x22>
	{
		USB_Device_GetInternalSerialDescriptor();
    2d4c:	9e df       	rcall	.-196    	; 0x2c8a <USB_Device_GetInternalSerialDescriptor>
		return;
    2d4e:	19 c0       	rjmp	.+50     	; 0x2d82 <USB_Device_GetDescriptor+0x54>
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    2d50:	60 91 59 14 	lds	r22, 0x1459	; 0x801459 <USB_ControlRequest+0x4>
    2d54:	70 91 5a 14 	lds	r23, 0x145A	; 0x80145a <USB_ControlRequest+0x5>
    2d58:	ae 01       	movw	r20, r28
    2d5a:	4f 5f       	subi	r20, 0xFF	; 255
    2d5c:	5f 4f       	sbci	r21, 0xFF	; 255
    2d5e:	0e 94 31 02 	call	0x462	; 0x462 <CALLBACK_USB_GetDescriptor>
    2d62:	00 97       	sbiw	r24, 0x00	; 0
    2d64:	71 f0       	breq	.+28     	; 0x2d82 <USB_Device_GetDescriptor+0x54>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2d66:	08 ee       	ldi	r16, 0xE8	; 232
    2d68:	10 e0       	ldi	r17, 0x00	; 0
    2d6a:	f8 01       	movw	r30, r16
    2d6c:	20 81       	ld	r18, Z
    2d6e:	27 7f       	andi	r18, 0xF7	; 247
    2d70:	20 83       	st	Z, r18
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2d72:	bc 01       	movw	r22, r24
    2d74:	89 81       	ldd	r24, Y+1	; 0x01
    2d76:	9a 81       	ldd	r25, Y+2	; 0x02
    2d78:	75 dc       	rcall	.-1814   	; 0x2664 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2d7a:	f8 01       	movw	r30, r16
    2d7c:	80 81       	ld	r24, Z
    2d7e:	8b 77       	andi	r24, 0x7B	; 123
    2d80:	80 83       	st	Z, r24
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#endif

	Endpoint_ClearOUT();
}
    2d82:	0f 90       	pop	r0
    2d84:	0f 90       	pop	r0
    2d86:	df 91       	pop	r29
    2d88:	cf 91       	pop	r28
    2d8a:	1f 91       	pop	r17
    2d8c:	0f 91       	pop	r16
    2d8e:	08 95       	ret

00002d90 <USB_Device_SetConfiguration>:
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2d90:	80 91 57 14 	lds	r24, 0x1457	; 0x801457 <USB_ControlRequest+0x2>
    2d94:	90 91 58 14 	lds	r25, 0x1458	; 0x801458 <USB_ControlRequest+0x3>
    2d98:	99 27       	eor	r25, r25
    2d9a:	02 97       	sbiw	r24, 0x02	; 2
    2d9c:	ec f4       	brge	.+58     	; 0x2dd8 <USB_Device_SetConfiguration+0x48>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2d9e:	e8 ee       	ldi	r30, 0xE8	; 232
    2da0:	f0 e0       	ldi	r31, 0x00	; 0
    2da2:	80 81       	ld	r24, Z
    2da4:	87 7f       	andi	r24, 0xF7	; 247
    2da6:	80 83       	st	Z, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2da8:	80 91 57 14 	lds	r24, 0x1457	; 0x801457 <USB_ControlRequest+0x2>
    2dac:	80 93 50 14 	sts	0x1450, r24	; 0x801450 <USB_Device_ConfigurationNumber>

	Endpoint_ClearStatusStage();
    2db0:	3c dd       	rcall	.-1416   	; 0x282a <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    2db2:	80 91 50 14 	lds	r24, 0x1450	; 0x801450 <USB_Device_ConfigurationNumber>
    2db6:	88 23       	and	r24, r24
    2db8:	21 f0       	breq	.+8      	; 0x2dc2 <USB_Device_SetConfiguration+0x32>
	  USB_DeviceState = DEVICE_STATE_Configured;
    2dba:	84 e0       	ldi	r24, 0x04	; 4
    2dbc:	80 93 54 14 	sts	0x1454, r24	; 0x801454 <USB_DeviceState>
    2dc0:	09 c0       	rjmp	.+18     	; 0x2dd4 <USB_Device_SetConfiguration+0x44>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2dc2:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__TEXT_REGION_LENGTH__+0x7e00e3>
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2dc6:	88 23       	and	r24, r24
    2dc8:	14 f4       	brge	.+4      	; 0x2dce <USB_Device_SetConfiguration+0x3e>
    2dca:	84 e0       	ldi	r24, 0x04	; 4
    2dcc:	01 c0       	rjmp	.+2      	; 0x2dd0 <USB_Device_SetConfiguration+0x40>
    2dce:	81 e0       	ldi	r24, 0x01	; 1
    2dd0:	80 93 54 14 	sts	0x1454, r24	; 0x801454 <USB_DeviceState>

	EVENT_USB_Device_ConfigurationChanged();
    2dd4:	0c 94 f0 0c 	jmp	0x19e0	; 0x19e0 <EVENT_USB_Device_ConfigurationChanged>
    2dd8:	08 95       	ret

00002dda <USB_Device_ProcessControlRequest>:
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    2dda:	80 e0       	ldi	r24, 0x00	; 0
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
    2ddc:	e5 e5       	ldi	r30, 0x55	; 85
    2dde:	f4 e1       	ldi	r31, 0x14	; 20

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    2de0:	05 c0       	rjmp	.+10     	; 0x2dec <USB_Device_ProcessControlRequest+0x12>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    2de2:	90 91 f1 00 	lds	r25, 0x00F1	; 0x8000f1 <__TEXT_REGION_LENGTH__+0x7e00f1>
	  *(RequestHeader++) = Endpoint_Read_8();
    2de6:	90 83       	st	Z, r25
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    2de8:	8f 5f       	subi	r24, 0xFF	; 255
	  *(RequestHeader++) = Endpoint_Read_8();
    2dea:	31 96       	adiw	r30, 0x01	; 1
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    2dec:	88 30       	cpi	r24, 0x08	; 8
    2dee:	c8 f3       	brcs	.-14     	; 0x2de2 <USB_Device_ProcessControlRequest+0x8>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    2df0:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2df4:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	if (Endpoint_IsSETUPReceived())
    2df8:	83 ff       	sbrs	r24, 3
    2dfa:	30 c0       	rjmp	.+96     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    2dfc:	e5 e5       	ldi	r30, 0x55	; 85
    2dfe:	f4 e1       	ldi	r31, 0x14	; 20
    2e00:	90 81       	ld	r25, Z

		switch (USB_ControlRequest.bRequest)
    2e02:	81 81       	ldd	r24, Z+1	; 0x01
    2e04:	85 30       	cpi	r24, 0x05	; 5
    2e06:	d1 f0       	breq	.+52     	; 0x2e3c <USB_Device_ProcessControlRequest+0x62>
    2e08:	30 f4       	brcc	.+12     	; 0x2e16 <USB_Device_ProcessControlRequest+0x3c>
    2e0a:	81 30       	cpi	r24, 0x01	; 1
    2e0c:	89 f0       	breq	.+34     	; 0x2e30 <USB_Device_ProcessControlRequest+0x56>
    2e0e:	50 f0       	brcs	.+20     	; 0x2e24 <USB_Device_ProcessControlRequest+0x4a>
    2e10:	83 30       	cpi	r24, 0x03	; 3
    2e12:	71 f0       	breq	.+28     	; 0x2e30 <USB_Device_ProcessControlRequest+0x56>
    2e14:	23 c0       	rjmp	.+70     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e16:	88 30       	cpi	r24, 0x08	; 8
    2e18:	d1 f0       	breq	.+52     	; 0x2e4e <USB_Device_ProcessControlRequest+0x74>
    2e1a:	89 30       	cpi	r24, 0x09	; 9
    2e1c:	e1 f0       	breq	.+56     	; 0x2e56 <USB_Device_ProcessControlRequest+0x7c>
    2e1e:	86 30       	cpi	r24, 0x06	; 6
    2e20:	e9 f4       	brne	.+58     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e22:	10 c0       	rjmp	.+32     	; 0x2e44 <USB_Device_ProcessControlRequest+0x6a>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2e24:	90 38       	cpi	r25, 0x80	; 128
    2e26:	11 f0       	breq	.+4      	; 0x2e2c <USB_Device_ProcessControlRequest+0x52>
    2e28:	92 38       	cpi	r25, 0x82	; 130
    2e2a:	c1 f4       	brne	.+48     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
					(bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT)))
				{
					USB_Device_GetStatus();
    2e2c:	82 de       	rcall	.-764    	; 0x2b32 <USB_Device_GetStatus>
    2e2e:	16 c0       	rjmp	.+44     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2e30:	99 23       	and	r25, r25
    2e32:	11 f0       	breq	.+4      	; 0x2e38 <USB_Device_ProcessControlRequest+0x5e>
    2e34:	92 30       	cpi	r25, 0x02	; 2
					(bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_ENDPOINT)))
				{
					USB_Device_ClearSetFeature();
    2e36:	91 f4       	brne	.+36     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e38:	ac de       	rcall	.-680    	; 0x2b92 <USB_Device_ClearSetFeature>
    2e3a:	10 c0       	rjmp	.+32     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2e3c:	91 11       	cpse	r25, r1
				  USB_Device_SetAddress();
    2e3e:	0e c0       	rjmp	.+28     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e40:	f4 de       	rcall	.-536    	; 0x2c2a <USB_Device_SetAddress>
    2e42:	0c c0       	rjmp	.+24     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2e44:	90 58       	subi	r25, 0x80	; 128
    2e46:	92 30       	cpi	r25, 0x02	; 2
					(bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_INTERFACE)))
				{
					USB_Device_GetDescriptor();
    2e48:	48 f4       	brcc	.+18     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e4a:	71 df       	rcall	.-286    	; 0x2d2e <USB_Device_GetDescriptor>
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    2e4c:	07 c0       	rjmp	.+14     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e4e:	90 38       	cpi	r25, 0x80	; 128
				  USB_Device_GetConfiguration();
    2e50:	29 f4       	brne	.+10     	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e52:	0d df       	rcall	.-486    	; 0x2c6e <USB_Device_GetConfiguration>

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2e54:	03 c0       	rjmp	.+6      	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e56:	91 11       	cpse	r25, r1
				  USB_Device_SetConfiguration();
    2e58:	01 c0       	rjmp	.+2      	; 0x2e5c <USB_Device_ProcessControlRequest+0x82>
    2e5a:	9a df       	rcall	.-204    	; 0x2d90 <USB_Device_SetConfiguration>
    2e5c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2e60:	83 ff       	sbrs	r24, 3
    2e62:	0a c0       	rjmp	.+20     	; 0x2e78 <USB_Device_ProcessControlRequest+0x9e>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2e64:	e8 ee       	ldi	r30, 0xE8	; 232
    2e66:	f0 e0       	ldi	r31, 0x00	; 0
    2e68:	80 81       	ld	r24, Z
    2e6a:	87 7f       	andi	r24, 0xF7	; 247
    2e6c:	80 83       	st	Z, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2e6e:	eb ee       	ldi	r30, 0xEB	; 235
    2e70:	f0 e0       	ldi	r31, 0x00	; 0
    2e72:	80 81       	ld	r24, Z
    2e74:	80 62       	ori	r24, 0x20	; 32
    2e76:	80 83       	st	Z, r24
    2e78:	08 95       	ret

00002e7a <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    2e7a:	08 95       	ret

00002e7c <USB_DeviceTask>:
	#endif
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
    2e7c:	cf 93       	push	r28
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    2e7e:	80 91 54 14 	lds	r24, 0x1454	; 0x801454 <USB_DeviceState>
    2e82:	88 23       	and	r24, r24
    2e84:	99 f0       	breq	.+38     	; 0x2eac <USB_DeviceTask+0x30>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    2e86:	c0 91 e9 00 	lds	r28, 0x00E9	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
    2e8a:	cf 70       	andi	r28, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    2e8c:	80 91 ec 00 	lds	r24, 0x00EC	; 0x8000ec <__TEXT_REGION_LENGTH__+0x7e00ec>
    2e90:	98 2f       	mov	r25, r24
    2e92:	91 70       	andi	r25, 0x01	; 1
    2e94:	80 fd       	sbrc	r24, 0
    2e96:	90 e8       	ldi	r25, 0x80	; 128
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    2e98:	c9 2b       	or	r28, r25
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2e9a:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2e9e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__TEXT_REGION_LENGTH__+0x7e00e8>

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    2ea2:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    2ea4:	9a df       	rcall	.-204    	; 0x2dda <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    2ea6:	cf 70       	andi	r28, 0x0F	; 15
    2ea8:	c0 93 e9 00 	sts	0x00E9, r28	; 0x8000e9 <__TEXT_REGION_LENGTH__+0x7e00e9>

	Endpoint_SelectEndpoint(PrevEndpoint);
}
    2eac:	cf 91       	pop	r28
    2eae:	08 95       	ret

00002eb0 <USB_USBTask>:
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
    2eb0:	e5 cf       	rjmp	.-54     	; 0x2e7c <USB_DeviceTask>
    2eb2:	08 95       	ret

00002eb4 <memcpy_P>:
    2eb4:	fb 01       	movw	r30, r22
    2eb6:	dc 01       	movw	r26, r24
    2eb8:	02 c0       	rjmp	.+4      	; 0x2ebe <memcpy_P+0xa>
    2eba:	05 90       	lpm	r0, Z+
    2ebc:	0d 92       	st	X+, r0
    2ebe:	41 50       	subi	r20, 0x01	; 1
    2ec0:	50 40       	sbci	r21, 0x00	; 0
    2ec2:	d8 f7       	brcc	.-10     	; 0x2eba <memcpy_P+0x6>
    2ec4:	08 95       	ret

00002ec6 <strcpy_P>:
    2ec6:	fb 01       	movw	r30, r22
    2ec8:	dc 01       	movw	r26, r24
    2eca:	05 90       	lpm	r0, Z+
    2ecc:	0d 92       	st	X+, r0
    2ece:	00 20       	and	r0, r0
    2ed0:	e1 f7       	brne	.-8      	; 0x2eca <strcpy_P+0x4>
    2ed2:	08 95       	ret

00002ed4 <__strlen_P>:
    2ed4:	fc 01       	movw	r30, r24
    2ed6:	05 90       	lpm	r0, Z+
    2ed8:	00 20       	and	r0, r0
    2eda:	e9 f7       	brne	.-6      	; 0x2ed6 <__strlen_P+0x2>
    2edc:	80 95       	com	r24
    2ede:	90 95       	com	r25
    2ee0:	8e 0f       	add	r24, r30
    2ee2:	9f 1f       	adc	r25, r31
    2ee4:	08 95       	ret

00002ee6 <strncpy_P>:
    2ee6:	fb 01       	movw	r30, r22
    2ee8:	dc 01       	movw	r26, r24
    2eea:	41 50       	subi	r20, 0x01	; 1
    2eec:	50 40       	sbci	r21, 0x00	; 0
    2eee:	48 f0       	brcs	.+18     	; 0x2f02 <strncpy_P+0x1c>
    2ef0:	05 90       	lpm	r0, Z+
    2ef2:	0d 92       	st	X+, r0
    2ef4:	00 20       	and	r0, r0
    2ef6:	c9 f7       	brne	.-14     	; 0x2eea <strncpy_P+0x4>
    2ef8:	01 c0       	rjmp	.+2      	; 0x2efc <strncpy_P+0x16>
    2efa:	1d 92       	st	X+, r1
    2efc:	41 50       	subi	r20, 0x01	; 1
    2efe:	50 40       	sbci	r21, 0x00	; 0
    2f00:	e0 f7       	brcc	.-8      	; 0x2efa <strncpy_P+0x14>
    2f02:	08 95       	ret

00002f04 <memcmp>:
    2f04:	fb 01       	movw	r30, r22
    2f06:	dc 01       	movw	r26, r24
    2f08:	04 c0       	rjmp	.+8      	; 0x2f12 <memcmp+0xe>
    2f0a:	8d 91       	ld	r24, X+
    2f0c:	01 90       	ld	r0, Z+
    2f0e:	80 19       	sub	r24, r0
    2f10:	21 f4       	brne	.+8      	; 0x2f1a <memcmp+0x16>
    2f12:	41 50       	subi	r20, 0x01	; 1
    2f14:	50 40       	sbci	r21, 0x00	; 0
    2f16:	c8 f7       	brcc	.-14     	; 0x2f0a <memcmp+0x6>
    2f18:	88 1b       	sub	r24, r24
    2f1a:	99 0b       	sbc	r25, r25
    2f1c:	08 95       	ret

00002f1e <memcpy>:
    2f1e:	fb 01       	movw	r30, r22
    2f20:	dc 01       	movw	r26, r24
    2f22:	02 c0       	rjmp	.+4      	; 0x2f28 <memcpy+0xa>
    2f24:	01 90       	ld	r0, Z+
    2f26:	0d 92       	st	X+, r0
    2f28:	41 50       	subi	r20, 0x01	; 1
    2f2a:	50 40       	sbci	r21, 0x00	; 0
    2f2c:	d8 f7       	brcc	.-10     	; 0x2f24 <memcpy+0x6>
    2f2e:	08 95       	ret

00002f30 <memmove>:
    2f30:	68 17       	cp	r22, r24
    2f32:	79 07       	cpc	r23, r25
    2f34:	68 f4       	brcc	.+26     	; 0x2f50 <memmove+0x20>
    2f36:	fb 01       	movw	r30, r22
    2f38:	dc 01       	movw	r26, r24
    2f3a:	e4 0f       	add	r30, r20
    2f3c:	f5 1f       	adc	r31, r21
    2f3e:	a4 0f       	add	r26, r20
    2f40:	b5 1f       	adc	r27, r21
    2f42:	02 c0       	rjmp	.+4      	; 0x2f48 <memmove+0x18>
    2f44:	02 90       	ld	r0, -Z
    2f46:	0e 92       	st	-X, r0
    2f48:	41 50       	subi	r20, 0x01	; 1
    2f4a:	50 40       	sbci	r21, 0x00	; 0
    2f4c:	d8 f7       	brcc	.-10     	; 0x2f44 <memmove+0x14>
    2f4e:	08 95       	ret
    2f50:	e6 cf       	rjmp	.-52     	; 0x2f1e <memcpy>

00002f52 <strncmp>:
    2f52:	fb 01       	movw	r30, r22
    2f54:	dc 01       	movw	r26, r24
    2f56:	41 50       	subi	r20, 0x01	; 1
    2f58:	50 40       	sbci	r21, 0x00	; 0
    2f5a:	30 f0       	brcs	.+12     	; 0x2f68 <strncmp+0x16>
    2f5c:	8d 91       	ld	r24, X+
    2f5e:	01 90       	ld	r0, Z+
    2f60:	80 19       	sub	r24, r0
    2f62:	19 f4       	brne	.+6      	; 0x2f6a <strncmp+0x18>
    2f64:	00 20       	and	r0, r0
    2f66:	b9 f7       	brne	.-18     	; 0x2f56 <strncmp+0x4>
    2f68:	88 1b       	sub	r24, r24
    2f6a:	99 0b       	sbc	r25, r25
    2f6c:	08 95       	ret

00002f6e <_exit>:
    2f6e:	f8 94       	cli

00002f70 <__stop_program>:
    2f70:	ff cf       	rjmp	.-2      	; 0x2f70 <__stop_program>
